import {
  NamedType,
  Argument,
  Field,
  InlineFragment,
  Operation,
  Selection,
  SelectionSet,
  Variable,
  Executor,
  Client,
  TypeConditionError,
} from "../../src";

export const VERSION = "unversioned";

export const SCHEMA_SHA = "6b2a2be";

export enum AuditLogOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum CheckAnnotationLevel {
  FAILURE = "FAILURE",
  NOTICE = "NOTICE",
  WARNING = "WARNING",
}

export enum CheckConclusionState {
  ACTION_REQUIRED = "ACTION_REQUIRED",
  CANCELLED = "CANCELLED",
  FAILURE = "FAILURE",
  NEUTRAL = "NEUTRAL",
  SKIPPED = "SKIPPED",
  STALE = "STALE",
  STARTUP_FAILURE = "STARTUP_FAILURE",
  SUCCESS = "SUCCESS",
  TIMED_OUT = "TIMED_OUT",
}

export enum CheckRunType {
  ALL = "ALL",
  LATEST = "LATEST",
}

export enum CheckStatusState {
  COMPLETED = "COMPLETED",
  IN_PROGRESS = "IN_PROGRESS",
  QUEUED = "QUEUED",
  REQUESTED = "REQUESTED",
}

export enum CollaboratorAffiliation {
  ALL = "ALL",
  DIRECT = "DIRECT",
  OUTSIDE = "OUTSIDE",
}

export enum CommentAuthorAssociation {
  COLLABORATOR = "COLLABORATOR",
  CONTRIBUTOR = "CONTRIBUTOR",
  FIRST_TIMER = "FIRST_TIMER",
  FIRST_TIME_CONTRIBUTOR = "FIRST_TIME_CONTRIBUTOR",
  MANNEQUIN = "MANNEQUIN",
  MEMBER = "MEMBER",
  NONE = "NONE",
  OWNER = "OWNER",
}

export enum CommentCannotUpdateReason {
  ARCHIVED = "ARCHIVED",
  DENIED = "DENIED",
  INSUFFICIENT_ACCESS = "INSUFFICIENT_ACCESS",
  LOCKED = "LOCKED",
  LOGIN_REQUIRED = "LOGIN_REQUIRED",
  MAINTENANCE = "MAINTENANCE",
  VERIFIED_EMAIL_REQUIRED = "VERIFIED_EMAIL_REQUIRED",
}

export enum CommitContributionOrderField {
  COMMIT_COUNT = "COMMIT_COUNT",
  OCCURRED_AT = "OCCURRED_AT",
}

export enum DefaultRepositoryPermissionField {
  ADMIN = "ADMIN",
  NONE = "NONE",
  READ = "READ",
  WRITE = "WRITE",
}

export enum DeploymentOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum DeploymentState {
  ABANDONED = "ABANDONED",
  ACTIVE = "ACTIVE",
  DESTROYED = "DESTROYED",
  ERROR = "ERROR",
  FAILURE = "FAILURE",
  INACTIVE = "INACTIVE",
  IN_PROGRESS = "IN_PROGRESS",
  PENDING = "PENDING",
  QUEUED = "QUEUED",
  WAITING = "WAITING",
}

export enum DeploymentStatusState {
  ERROR = "ERROR",
  FAILURE = "FAILURE",
  INACTIVE = "INACTIVE",
  IN_PROGRESS = "IN_PROGRESS",
  PENDING = "PENDING",
  QUEUED = "QUEUED",
  SUCCESS = "SUCCESS",
}

export enum DiffSide {
  LEFT = "LEFT",
  RIGHT = "RIGHT",
}

export enum EnterpriseAdministratorInvitationOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum EnterpriseAdministratorRole {
  BILLING_MANAGER = "BILLING_MANAGER",
  OWNER = "OWNER",
}

export enum EnterpriseDefaultRepositoryPermissionSettingValue {
  ADMIN = "ADMIN",
  NONE = "NONE",
  NO_POLICY = "NO_POLICY",
  READ = "READ",
  WRITE = "WRITE",
}

export enum EnterpriseEnabledDisabledSettingValue {
  DISABLED = "DISABLED",
  ENABLED = "ENABLED",
  NO_POLICY = "NO_POLICY",
}

export enum EnterpriseEnabledSettingValue {
  ENABLED = "ENABLED",
  NO_POLICY = "NO_POLICY",
}

export enum EnterpriseMemberOrderField {
  CREATED_AT = "CREATED_AT",
  LOGIN = "LOGIN",
}

export enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  ALL = "ALL",
  DISABLED = "DISABLED",
  NO_POLICY = "NO_POLICY",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum EnterpriseMembersCanMakePurchasesSettingValue {
  DISABLED = "DISABLED",
  ENABLED = "ENABLED",
}

export enum EnterpriseServerInstallationOrderField {
  CREATED_AT = "CREATED_AT",
  CUSTOMER_NAME = "CUSTOMER_NAME",
  HOST_NAME = "HOST_NAME",
}

export enum EnterpriseServerUserAccountEmailOrderField {
  EMAIL = "EMAIL",
}

export enum EnterpriseServerUserAccountOrderField {
  LOGIN = "LOGIN",
  REMOTE_CREATED_AT = "REMOTE_CREATED_AT",
}

export enum EnterpriseServerUserAccountsUploadOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum EnterpriseServerUserAccountsUploadSyncState {
  FAILURE = "FAILURE",
  PENDING = "PENDING",
  SUCCESS = "SUCCESS",
}

export enum EnterpriseUserAccountMembershipRole {
  MEMBER = "MEMBER",
  OWNER = "OWNER",
}

export enum EnterpriseUserDeployment {
  CLOUD = "CLOUD",
  SERVER = "SERVER",
}

export enum FileViewedState {
  DISMISSED = "DISMISSED",
  UNVIEWED = "UNVIEWED",
  VIEWED = "VIEWED",
}

export enum FundingPlatform {
  COMMUNITY_BRIDGE = "COMMUNITY_BRIDGE",
  CUSTOM = "CUSTOM",
  GITHUB = "GITHUB",
  ISSUEHUNT = "ISSUEHUNT",
  KO_FI = "KO_FI",
  LIBERAPAY = "LIBERAPAY",
  OPEN_COLLECTIVE = "OPEN_COLLECTIVE",
  OTECHIE = "OTECHIE",
  PATREON = "PATREON",
  TIDELIFT = "TIDELIFT",
}

export enum GistOrderField {
  CREATED_AT = "CREATED_AT",
  PUSHED_AT = "PUSHED_AT",
  UPDATED_AT = "UPDATED_AT",
}

export enum GistPrivacy {
  ALL = "ALL",
  PUBLIC = "PUBLIC",
  SECRET = "SECRET",
}

export enum GitSignatureState {
  BAD_CERT = "BAD_CERT",
  BAD_EMAIL = "BAD_EMAIL",
  EXPIRED_KEY = "EXPIRED_KEY",
  GPGVERIFY_ERROR = "GPGVERIFY_ERROR",
  GPGVERIFY_UNAVAILABLE = "GPGVERIFY_UNAVAILABLE",
  INVALID = "INVALID",
  MALFORMED_SIG = "MALFORMED_SIG",
  NOT_SIGNING_KEY = "NOT_SIGNING_KEY",
  NO_USER = "NO_USER",
  OCSP_ERROR = "OCSP_ERROR",
  OCSP_PENDING = "OCSP_PENDING",
  OCSP_REVOKED = "OCSP_REVOKED",
  UNKNOWN_KEY = "UNKNOWN_KEY",
  UNKNOWN_SIG_TYPE = "UNKNOWN_SIG_TYPE",
  UNSIGNED = "UNSIGNED",
  UNVERIFIED_EMAIL = "UNVERIFIED_EMAIL",
  VALID = "VALID",
}

export enum IdentityProviderConfigurationState {
  CONFIGURED = "CONFIGURED",
  ENFORCED = "ENFORCED",
  UNCONFIGURED = "UNCONFIGURED",
}

export enum IpAllowListEnabledSettingValue {
  DISABLED = "DISABLED",
  ENABLED = "ENABLED",
}

export enum IpAllowListEntryOrderField {
  ALLOW_LIST_VALUE = "ALLOW_LIST_VALUE",
  CREATED_AT = "CREATED_AT",
}

export enum IssueCommentOrderField {
  UPDATED_AT = "UPDATED_AT",
}

export enum IssueOrderField {
  COMMENTS = "COMMENTS",
  CREATED_AT = "CREATED_AT",
  UPDATED_AT = "UPDATED_AT",
}

export enum IssueState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

export enum IssueTimelineItemsItemType {
  ADDED_TO_PROJECT_EVENT = "ADDED_TO_PROJECT_EVENT",
  ASSIGNED_EVENT = "ASSIGNED_EVENT",
  CLOSED_EVENT = "CLOSED_EVENT",
  COMMENT_DELETED_EVENT = "COMMENT_DELETED_EVENT",
  CONNECTED_EVENT = "CONNECTED_EVENT",
  CONVERTED_NOTE_TO_ISSUE_EVENT = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  CROSS_REFERENCED_EVENT = "CROSS_REFERENCED_EVENT",
  DEMILESTONED_EVENT = "DEMILESTONED_EVENT",
  DISCONNECTED_EVENT = "DISCONNECTED_EVENT",
  ISSUE_COMMENT = "ISSUE_COMMENT",
  LABELED_EVENT = "LABELED_EVENT",
  LOCKED_EVENT = "LOCKED_EVENT",
  MARKED_AS_DUPLICATE_EVENT = "MARKED_AS_DUPLICATE_EVENT",
  MENTIONED_EVENT = "MENTIONED_EVENT",
  MILESTONED_EVENT = "MILESTONED_EVENT",
  MOVED_COLUMNS_IN_PROJECT_EVENT = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  PINNED_EVENT = "PINNED_EVENT",
  REFERENCED_EVENT = "REFERENCED_EVENT",
  REMOVED_FROM_PROJECT_EVENT = "REMOVED_FROM_PROJECT_EVENT",
  RENAMED_TITLE_EVENT = "RENAMED_TITLE_EVENT",
  REOPENED_EVENT = "REOPENED_EVENT",
  SUBSCRIBED_EVENT = "SUBSCRIBED_EVENT",
  TRANSFERRED_EVENT = "TRANSFERRED_EVENT",
  UNASSIGNED_EVENT = "UNASSIGNED_EVENT",
  UNLABELED_EVENT = "UNLABELED_EVENT",
  UNLOCKED_EVENT = "UNLOCKED_EVENT",
  UNMARKED_AS_DUPLICATE_EVENT = "UNMARKED_AS_DUPLICATE_EVENT",
  UNPINNED_EVENT = "UNPINNED_EVENT",
  UNSUBSCRIBED_EVENT = "UNSUBSCRIBED_EVENT",
  USER_BLOCKED_EVENT = "USER_BLOCKED_EVENT",
}

export enum LabelOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
}

export enum LanguageOrderField {
  SIZE = "SIZE",
}

export enum LockReason {
  OFF_TOPIC = "OFF_TOPIC",
  RESOLVED = "RESOLVED",
  SPAM = "SPAM",
  TOO_HEATED = "TOO_HEATED",
}

export enum MergeableState {
  CONFLICTING = "CONFLICTING",
  MERGEABLE = "MERGEABLE",
  UNKNOWN = "UNKNOWN",
}

export enum MilestoneOrderField {
  CREATED_AT = "CREATED_AT",
  DUE_DATE = "DUE_DATE",
  NUMBER = "NUMBER",
  UPDATED_AT = "UPDATED_AT",
}

export enum MilestoneState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

export enum OauthApplicationCreateAuditEntryState {
  ACTIVE = "ACTIVE",
  PENDING_DELETION = "PENDING_DELETION",
  SUSPENDED = "SUSPENDED",
}

export enum OperationType {
  ACCESS = "ACCESS",
  AUTHENTICATION = "AUTHENTICATION",
  CREATE = "CREATE",
  MODIFY = "MODIFY",
  REMOVE = "REMOVE",
  RESTORE = "RESTORE",
  TRANSFER = "TRANSFER",
}

export enum OrderDirection {
  ASC = "ASC",
  DESC = "DESC",
}

export enum OrgAddMemberAuditEntryPermission {
  ADMIN = "ADMIN",
  READ = "READ",
}

export enum OrgCreateAuditEntryBillingPlan {
  BUSINESS = "BUSINESS",
  BUSINESS_PLUS = "BUSINESS_PLUS",
  FREE = "FREE",
  TIERED_PER_SEAT = "TIERED_PER_SEAT",
  UNLIMITED = "UNLIMITED",
}

export enum OrgRemoveBillingManagerAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING = "SAML_EXTERNAL_IDENTITY_MISSING",
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY",
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
}

export enum OrgRemoveMemberAuditEntryMembershipType {
  ADMIN = "ADMIN",
  BILLING_MANAGER = "BILLING_MANAGER",
  DIRECT_MEMBER = "DIRECT_MEMBER",
  OUTSIDE_COLLABORATOR = "OUTSIDE_COLLABORATOR",
  UNAFFILIATED = "UNAFFILIATED",
}

export enum OrgRemoveMemberAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING = "SAML_EXTERNAL_IDENTITY_MISSING",
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY",
  TWO_FACTOR_ACCOUNT_RECOVERY = "TWO_FACTOR_ACCOUNT_RECOVERY",
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
  USER_ACCOUNT_DELETED = "USER_ACCOUNT_DELETED",
}

export enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  BILLING_MANAGER = "BILLING_MANAGER",
  OUTSIDE_COLLABORATOR = "OUTSIDE_COLLABORATOR",
  UNAFFILIATED = "UNAFFILIATED",
}

export enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING = "SAML_EXTERNAL_IDENTITY_MISSING",
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
}

export enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  ADMIN = "ADMIN",
  NONE = "NONE",
  READ = "READ",
  WRITE = "WRITE",
}

export enum OrgUpdateMemberAuditEntryPermission {
  ADMIN = "ADMIN",
  READ = "READ",
}

export enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  ALL = "ALL",
  INTERNAL = "INTERNAL",
  NONE = "NONE",
  PRIVATE = "PRIVATE",
  PRIVATE_INTERNAL = "PRIVATE_INTERNAL",
  PUBLIC = "PUBLIC",
  PUBLIC_INTERNAL = "PUBLIC_INTERNAL",
  PUBLIC_PRIVATE = "PUBLIC_PRIVATE",
}

export enum OrganizationInvitationRole {
  ADMIN = "ADMIN",
  BILLING_MANAGER = "BILLING_MANAGER",
  DIRECT_MEMBER = "DIRECT_MEMBER",
  REINSTATE = "REINSTATE",
}

export enum OrganizationInvitationType {
  EMAIL = "EMAIL",
  USER = "USER",
}

export enum OrganizationMemberRole {
  ADMIN = "ADMIN",
  MEMBER = "MEMBER",
}

export enum OrganizationMembersCanCreateRepositoriesSettingValue {
  ALL = "ALL",
  DISABLED = "DISABLED",
  PRIVATE = "PRIVATE",
}

export enum OrganizationOrderField {
  CREATED_AT = "CREATED_AT",
  LOGIN = "LOGIN",
}

export enum PackageFileOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum PackageOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum PackageType {
  DEBIAN = "DEBIAN",
  DOCKER = "DOCKER",
  MAVEN = "MAVEN",
  NPM = "NPM",
  NUGET = "NUGET",
  PYPI = "PYPI",
  RUBYGEMS = "RUBYGEMS",
}

export enum PackageVersionOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum PinnableItemType {
  GIST = "GIST",
  ISSUE = "ISSUE",
  ORGANIZATION = "ORGANIZATION",
  PROJECT = "PROJECT",
  PULL_REQUEST = "PULL_REQUEST",
  REPOSITORY = "REPOSITORY",
  TEAM = "TEAM",
  USER = "USER",
}

export enum ProjectCardArchivedState {
  ARCHIVED = "ARCHIVED",
  NOT_ARCHIVED = "NOT_ARCHIVED",
}

export enum ProjectCardState {
  CONTENT_ONLY = "CONTENT_ONLY",
  NOTE_ONLY = "NOTE_ONLY",
  REDACTED = "REDACTED",
}

export enum ProjectColumnPurpose {
  DONE = "DONE",
  IN_PROGRESS = "IN_PROGRESS",
  TODO = "TODO",
}

export enum ProjectOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  UPDATED_AT = "UPDATED_AT",
}

export enum ProjectState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

export enum ProjectTemplate {
  AUTOMATED_KANBAN_V2 = "AUTOMATED_KANBAN_V2",
  AUTOMATED_REVIEWS_KANBAN = "AUTOMATED_REVIEWS_KANBAN",
  BASIC_KANBAN = "BASIC_KANBAN",
  BUG_TRIAGE = "BUG_TRIAGE",
}

export enum PullRequestMergeMethod {
  MERGE = "MERGE",
  REBASE = "REBASE",
  SQUASH = "SQUASH",
}

export enum PullRequestOrderField {
  CREATED_AT = "CREATED_AT",
  UPDATED_AT = "UPDATED_AT",
}

export enum PullRequestReviewCommentState {
  PENDING = "PENDING",
  SUBMITTED = "SUBMITTED",
}

export enum PullRequestReviewDecision {
  APPROVED = "APPROVED",
  CHANGES_REQUESTED = "CHANGES_REQUESTED",
  REVIEW_REQUIRED = "REVIEW_REQUIRED",
}

export enum PullRequestReviewEvent {
  APPROVE = "APPROVE",
  COMMENT = "COMMENT",
  DISMISS = "DISMISS",
  REQUEST_CHANGES = "REQUEST_CHANGES",
}

export enum PullRequestReviewState {
  APPROVED = "APPROVED",
  CHANGES_REQUESTED = "CHANGES_REQUESTED",
  COMMENTED = "COMMENTED",
  DISMISSED = "DISMISSED",
  PENDING = "PENDING",
}

export enum PullRequestState {
  CLOSED = "CLOSED",
  MERGED = "MERGED",
  OPEN = "OPEN",
}

export enum PullRequestTimelineItemsItemType {
  ADDED_TO_PROJECT_EVENT = "ADDED_TO_PROJECT_EVENT",
  ASSIGNED_EVENT = "ASSIGNED_EVENT",
  AUTOMATIC_BASE_CHANGE_FAILED_EVENT = "AUTOMATIC_BASE_CHANGE_FAILED_EVENT",
  AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT = "AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT",
  BASE_REF_CHANGED_EVENT = "BASE_REF_CHANGED_EVENT",
  BASE_REF_DELETED_EVENT = "BASE_REF_DELETED_EVENT",
  BASE_REF_FORCE_PUSHED_EVENT = "BASE_REF_FORCE_PUSHED_EVENT",
  CLOSED_EVENT = "CLOSED_EVENT",
  COMMENT_DELETED_EVENT = "COMMENT_DELETED_EVENT",
  CONNECTED_EVENT = "CONNECTED_EVENT",
  CONVERTED_NOTE_TO_ISSUE_EVENT = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  CONVERT_TO_DRAFT_EVENT = "CONVERT_TO_DRAFT_EVENT",
  CROSS_REFERENCED_EVENT = "CROSS_REFERENCED_EVENT",
  DEMILESTONED_EVENT = "DEMILESTONED_EVENT",
  DEPLOYED_EVENT = "DEPLOYED_EVENT",
  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT = "DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT",
  DISCONNECTED_EVENT = "DISCONNECTED_EVENT",
  HEAD_REF_DELETED_EVENT = "HEAD_REF_DELETED_EVENT",
  HEAD_REF_FORCE_PUSHED_EVENT = "HEAD_REF_FORCE_PUSHED_EVENT",
  HEAD_REF_RESTORED_EVENT = "HEAD_REF_RESTORED_EVENT",
  ISSUE_COMMENT = "ISSUE_COMMENT",
  LABELED_EVENT = "LABELED_EVENT",
  LOCKED_EVENT = "LOCKED_EVENT",
  MARKED_AS_DUPLICATE_EVENT = "MARKED_AS_DUPLICATE_EVENT",
  MENTIONED_EVENT = "MENTIONED_EVENT",
  MERGED_EVENT = "MERGED_EVENT",
  MILESTONED_EVENT = "MILESTONED_EVENT",
  MOVED_COLUMNS_IN_PROJECT_EVENT = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  PINNED_EVENT = "PINNED_EVENT",
  PULL_REQUEST_COMMIT = "PULL_REQUEST_COMMIT",
  PULL_REQUEST_COMMIT_COMMENT_THREAD = "PULL_REQUEST_COMMIT_COMMENT_THREAD",
  PULL_REQUEST_REVIEW = "PULL_REQUEST_REVIEW",
  PULL_REQUEST_REVIEW_THREAD = "PULL_REQUEST_REVIEW_THREAD",
  PULL_REQUEST_REVISION_MARKER = "PULL_REQUEST_REVISION_MARKER",
  READY_FOR_REVIEW_EVENT = "READY_FOR_REVIEW_EVENT",
  REFERENCED_EVENT = "REFERENCED_EVENT",
  REMOVED_FROM_PROJECT_EVENT = "REMOVED_FROM_PROJECT_EVENT",
  RENAMED_TITLE_EVENT = "RENAMED_TITLE_EVENT",
  REOPENED_EVENT = "REOPENED_EVENT",
  REVIEW_DISMISSED_EVENT = "REVIEW_DISMISSED_EVENT",
  REVIEW_REQUESTED_EVENT = "REVIEW_REQUESTED_EVENT",
  REVIEW_REQUEST_REMOVED_EVENT = "REVIEW_REQUEST_REMOVED_EVENT",
  SUBSCRIBED_EVENT = "SUBSCRIBED_EVENT",
  TRANSFERRED_EVENT = "TRANSFERRED_EVENT",
  UNASSIGNED_EVENT = "UNASSIGNED_EVENT",
  UNLABELED_EVENT = "UNLABELED_EVENT",
  UNLOCKED_EVENT = "UNLOCKED_EVENT",
  UNMARKED_AS_DUPLICATE_EVENT = "UNMARKED_AS_DUPLICATE_EVENT",
  UNPINNED_EVENT = "UNPINNED_EVENT",
  UNSUBSCRIBED_EVENT = "UNSUBSCRIBED_EVENT",
  USER_BLOCKED_EVENT = "USER_BLOCKED_EVENT",
}

export enum PullRequestUpdateState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

export enum ReactionContent {
  CONFUSED = "CONFUSED",
  EYES = "EYES",
  HEART = "HEART",
  HOORAY = "HOORAY",
  LAUGH = "LAUGH",
  ROCKET = "ROCKET",
  THUMBS_DOWN = "THUMBS_DOWN",
  THUMBS_UP = "THUMBS_UP",
}

export enum ReactionOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum RefOrderField {
  ALPHABETICAL = "ALPHABETICAL",
  TAG_COMMIT_DATE = "TAG_COMMIT_DATE",
}

export enum ReleaseOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
}

export enum RepoAccessAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoAddMemberAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoArchivedAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoChangeMergeSettingAuditEntryMergeType {
  MERGE = "MERGE",
  REBASE = "REBASE",
  SQUASH = "SQUASH",
}

export enum RepoCreateAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoDestroyAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoRemoveMemberAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum ReportedContentClassifiers {
  ABUSE = "ABUSE",
  DUPLICATE = "DUPLICATE",
  OFF_TOPIC = "OFF_TOPIC",
  OUTDATED = "OUTDATED",
  RESOLVED = "RESOLVED",
  SPAM = "SPAM",
}

export enum RepositoryAffiliation {
  COLLABORATOR = "COLLABORATOR",
  ORGANIZATION_MEMBER = "ORGANIZATION_MEMBER",
  OWNER = "OWNER",
}

export enum RepositoryContributionType {
  COMMIT = "COMMIT",
  ISSUE = "ISSUE",
  PULL_REQUEST = "PULL_REQUEST",
  PULL_REQUEST_REVIEW = "PULL_REQUEST_REVIEW",
  REPOSITORY = "REPOSITORY",
}

export enum RepositoryInteractionLimit {
  COLLABORATORS_ONLY = "COLLABORATORS_ONLY",
  CONTRIBUTORS_ONLY = "CONTRIBUTORS_ONLY",
  EXISTING_USERS = "EXISTING_USERS",
  NO_LIMIT = "NO_LIMIT",
}

export enum RepositoryInteractionLimitExpiry {
  ONE_DAY = "ONE_DAY",
  ONE_MONTH = "ONE_MONTH",
  ONE_WEEK = "ONE_WEEK",
  SIX_MONTHS = "SIX_MONTHS",
  THREE_DAYS = "THREE_DAYS",
}

export enum RepositoryInteractionLimitOrigin {
  ORGANIZATION = "ORGANIZATION",
  REPOSITORY = "REPOSITORY",
  USER = "USER",
}

export enum RepositoryInvitationOrderField {
  CREATED_AT = "CREATED_AT",
  INVITEE_LOGIN = "INVITEE_LOGIN",
}

export enum RepositoryLockReason {
  BILLING = "BILLING",
  MIGRATING = "MIGRATING",
  MOVING = "MOVING",
  RENAME = "RENAME",
}

export enum RepositoryOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  PUSHED_AT = "PUSHED_AT",
  STARGAZERS = "STARGAZERS",
  UPDATED_AT = "UPDATED_AT",
}

export enum RepositoryPermission {
  ADMIN = "ADMIN",
  MAINTAIN = "MAINTAIN",
  READ = "READ",
  TRIAGE = "TRIAGE",
  WRITE = "WRITE",
}

export enum RepositoryPrivacy {
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepositoryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RequestableCheckStatusState {
  COMPLETED = "COMPLETED",
  IN_PROGRESS = "IN_PROGRESS",
  QUEUED = "QUEUED",
}

export enum SamlDigestAlgorithm {
  SHA1 = "SHA1",
  SHA256 = "SHA256",
  SHA384 = "SHA384",
  SHA512 = "SHA512",
}

export enum SamlSignatureAlgorithm {
  RSA_SHA1 = "RSA_SHA1",
  RSA_SHA256 = "RSA_SHA256",
  RSA_SHA384 = "RSA_SHA384",
  RSA_SHA512 = "RSA_SHA512",
}

export enum SavedReplyOrderField {
  UPDATED_AT = "UPDATED_AT",
}

export enum SearchType {
  ISSUE = "ISSUE",
  REPOSITORY = "REPOSITORY",
  USER = "USER",
}

export enum SecurityAdvisoryEcosystem {
  COMPOSER = "COMPOSER",
  MAVEN = "MAVEN",
  NPM = "NPM",
  NUGET = "NUGET",
  PIP = "PIP",
  RUBYGEMS = "RUBYGEMS",
}

export enum SecurityAdvisoryIdentifierType {
  CVE = "CVE",
  GHSA = "GHSA",
}

export enum SecurityAdvisoryOrderField {
  PUBLISHED_AT = "PUBLISHED_AT",
  UPDATED_AT = "UPDATED_AT",
}

export enum SecurityAdvisorySeverity {
  CRITICAL = "CRITICAL",
  HIGH = "HIGH",
  LOW = "LOW",
  MODERATE = "MODERATE",
}

export enum SecurityVulnerabilityOrderField {
  UPDATED_AT = "UPDATED_AT",
}

export enum SponsorsTierOrderField {
  CREATED_AT = "CREATED_AT",
  MONTHLY_PRICE_IN_CENTS = "MONTHLY_PRICE_IN_CENTS",
}

export enum SponsorshipOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum SponsorshipPrivacy {
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum StarOrderField {
  STARRED_AT = "STARRED_AT",
}

export enum StatusState {
  ERROR = "ERROR",
  EXPECTED = "EXPECTED",
  FAILURE = "FAILURE",
  PENDING = "PENDING",
  SUCCESS = "SUCCESS",
}

export enum SubscriptionState {
  IGNORED = "IGNORED",
  SUBSCRIBED = "SUBSCRIBED",
  UNSUBSCRIBED = "UNSUBSCRIBED",
}

export enum TeamDiscussionCommentOrderField {
  NUMBER = "NUMBER",
}

export enum TeamDiscussionOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum TeamMemberOrderField {
  CREATED_AT = "CREATED_AT",
  LOGIN = "LOGIN",
}

export enum TeamMemberRole {
  MAINTAINER = "MAINTAINER",
  MEMBER = "MEMBER",
}

export enum TeamMembershipType {
  ALL = "ALL",
  CHILD_TEAM = "CHILD_TEAM",
  IMMEDIATE = "IMMEDIATE",
}

export enum TeamOrderField {
  NAME = "NAME",
}

export enum TeamPrivacy {
  SECRET = "SECRET",
  VISIBLE = "VISIBLE",
}

export enum TeamRepositoryOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  PERMISSION = "PERMISSION",
  PUSHED_AT = "PUSHED_AT",
  STARGAZERS = "STARGAZERS",
  UPDATED_AT = "UPDATED_AT",
}

export enum TeamRole {
  ADMIN = "ADMIN",
  MEMBER = "MEMBER",
}

export enum TopicSuggestionDeclineReason {
  NOT_RELEVANT = "NOT_RELEVANT",
  PERSONAL_PREFERENCE = "PERSONAL_PREFERENCE",
  TOO_GENERAL = "TOO_GENERAL",
  TOO_SPECIFIC = "TOO_SPECIFIC",
}

export enum UserBlockDuration {
  ONE_DAY = "ONE_DAY",
  ONE_MONTH = "ONE_MONTH",
  ONE_WEEK = "ONE_WEEK",
  PERMANENT = "PERMANENT",
  THREE_DAYS = "THREE_DAYS",
}

export enum UserStatusOrderField {
  UPDATED_AT = "UPDATED_AT",
}

export interface AcceptEnterpriseAdministratorInvitationInput {
  readonly clientMutationId?: string;
  readonly invitationId: string;
}

export interface AcceptTopicSuggestionInput {
  readonly clientMutationId?: string;
  readonly name: string;
  readonly repositoryId: string;
}

export interface AddAssigneesToAssignableInput {
  readonly assignableId: string;
  readonly assigneeIds: string;
  readonly clientMutationId?: string;
}

export interface AddCommentInput {
  readonly body: string;
  readonly clientMutationId?: string;
  readonly subjectId: string;
}

export interface AddLabelsToLabelableInput {
  readonly clientMutationId?: string;
  readonly labelIds: string;
  readonly labelableId: string;
}

export interface AddProjectCardInput {
  readonly clientMutationId?: string;
  readonly contentId?: string;
  readonly note?: string;
  readonly projectColumnId: string;
}

export interface AddProjectColumnInput {
  readonly clientMutationId?: string;
  readonly name: string;
  readonly projectId: string;
}

export interface AddPullRequestReviewCommentInput {
  readonly body: string;
  readonly clientMutationId?: string;
  readonly commitOID?: unknown;
  readonly inReplyTo?: string;
  readonly path?: string;
  readonly position?: number;
  readonly pullRequestId?: string;
  readonly pullRequestReviewId?: string;
}

export interface AddPullRequestReviewInput {
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly comments?: DraftPullRequestReviewComment[];
  readonly commitOID?: unknown;
  readonly event?: PullRequestReviewEvent;
  readonly pullRequestId: string;
  readonly threads?: DraftPullRequestReviewThread[];
}

export interface AddPullRequestReviewThreadInput {
  readonly body: string;
  readonly clientMutationId?: string;
  readonly line: number;
  readonly path: string;
  readonly pullRequestId?: string;
  readonly pullRequestReviewId?: string;
  readonly side?: DiffSide;
  readonly startLine?: number;
  readonly startSide?: DiffSide;
}

export interface AddReactionInput {
  readonly clientMutationId?: string;
  readonly content: ReactionContent;
  readonly subjectId: string;
}

export interface AddStarInput {
  readonly clientMutationId?: string;
  readonly starrableId: string;
}

export interface ArchiveRepositoryInput {
  readonly clientMutationId?: string;
  readonly repositoryId: string;
}

export interface AuditLogOrder {
  readonly direction?: OrderDirection;
  readonly field?: AuditLogOrderField;
}

export interface CancelEnterpriseAdminInvitationInput {
  readonly clientMutationId?: string;
  readonly invitationId: string;
}

export interface ChangeUserStatusInput {
  readonly clientMutationId?: string;
  readonly emoji?: string;
  readonly expiresAt?: unknown;
  readonly limitedAvailability?: boolean;
  readonly message?: string;
  readonly organizationId?: string;
}

export interface CheckAnnotationData {
  readonly annotationLevel: CheckAnnotationLevel;
  readonly location: CheckAnnotationRange;
  readonly message: string;
  readonly path: string;
  readonly rawDetails?: string;
  readonly title?: string;
}

export interface CheckAnnotationRange {
  readonly endColumn?: number;
  readonly endLine: number;
  readonly startColumn?: number;
  readonly startLine: number;
}

export interface CheckRunAction {
  readonly description: string;
  readonly identifier: string;
  readonly label: string;
}

export interface CheckRunFilter {
  readonly appId?: number;
  readonly checkName?: string;
  readonly checkType?: CheckRunType;
  readonly status?: CheckStatusState;
}

export interface CheckRunOutput {
  readonly annotations?: CheckAnnotationData[];
  readonly images?: CheckRunOutputImage[];
  readonly summary: string;
  readonly text?: string;
  readonly title: string;
}

export interface CheckRunOutputImage {
  readonly alt: string;
  readonly caption?: string;
  readonly imageUrl: unknown;
}

export interface CheckSuiteAutoTriggerPreference {
  readonly appId: string;
  readonly setting: boolean;
}

export interface CheckSuiteFilter {
  readonly appId?: number;
  readonly checkName?: string;
}

export interface ClearLabelsFromLabelableInput {
  readonly clientMutationId?: string;
  readonly labelableId: string;
}

export interface CloneProjectInput {
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly includeWorkflows: boolean;
  readonly name: string;
  readonly public?: boolean;
  readonly sourceId: string;
  readonly targetOwnerId: string;
}

export interface CloneTemplateRepositoryInput {
  readonly clientMutationId?: string;
  readonly description?: string;
  readonly includeAllBranches?: boolean;
  readonly name: string;
  readonly ownerId: string;
  readonly repositoryId: string;
  readonly visibility: RepositoryVisibility;
}

export interface CloseIssueInput {
  readonly clientMutationId?: string;
  readonly issueId: string;
}

export interface ClosePullRequestInput {
  readonly clientMutationId?: string;
  readonly pullRequestId: string;
}

export interface CommitAuthor {
  readonly emails?: string[];
  readonly id?: string;
}

export interface CommitContributionOrder {
  readonly direction: OrderDirection;
  readonly field: CommitContributionOrderField;
}

export interface ContributionOrder {
  readonly direction: OrderDirection;
}

export interface ConvertProjectCardNoteToIssueInput {
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly projectCardId: string;
  readonly repositoryId: string;
  readonly title?: string;
}

export interface CreateBranchProtectionRuleInput {
  readonly allowsDeletions?: boolean;
  readonly allowsForcePushes?: boolean;
  readonly clientMutationId?: string;
  readonly dismissesStaleReviews?: boolean;
  readonly isAdminEnforced?: boolean;
  readonly pattern: string;
  readonly pushActorIds?: string[];
  readonly repositoryId: string;
  readonly requiredApprovingReviewCount?: number;
  readonly requiredStatusCheckContexts?: string[];
  readonly requiresApprovingReviews?: boolean;
  readonly requiresCodeOwnerReviews?: boolean;
  readonly requiresCommitSignatures?: boolean;
  readonly requiresLinearHistory?: boolean;
  readonly requiresStatusChecks?: boolean;
  readonly requiresStrictStatusChecks?: boolean;
  readonly restrictsPushes?: boolean;
  readonly restrictsReviewDismissals?: boolean;
  readonly reviewDismissalActorIds?: string[];
}

export interface CreateCheckRunInput {
  readonly actions?: CheckRunAction[];
  readonly clientMutationId?: string;
  readonly completedAt?: unknown;
  readonly conclusion?: CheckConclusionState;
  readonly detailsUrl?: unknown;
  readonly externalId?: string;
  readonly headSha: unknown;
  readonly name: string;
  readonly output?: CheckRunOutput;
  readonly repositoryId: string;
  readonly startedAt?: unknown;
  readonly status?: RequestableCheckStatusState;
}

export interface CreateCheckSuiteInput {
  readonly clientMutationId?: string;
  readonly headSha: unknown;
  readonly repositoryId: string;
}

export interface CreateEnterpriseOrganizationInput {
  readonly adminLogins: string;
  readonly billingEmail: string;
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly login: string;
  readonly profileName: string;
}

export interface CreateIpAllowListEntryInput {
  readonly allowListValue: string;
  readonly clientMutationId?: string;
  readonly isActive: boolean;
  readonly name?: string;
  readonly ownerId: string;
}

export interface CreateIssueInput {
  readonly assigneeIds?: string[];
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly issueTemplate?: string;
  readonly labelIds?: string[];
  readonly milestoneId?: string;
  readonly projectIds?: string[];
  readonly repositoryId: string;
  readonly title: string;
}

export interface CreateProjectInput {
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly name: string;
  readonly ownerId: string;
  readonly repositoryIds?: string[];
  readonly template?: ProjectTemplate;
}

export interface CreatePullRequestInput {
  readonly baseRefName: string;
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly draft?: boolean;
  readonly headRefName: string;
  readonly maintainerCanModify?: boolean;
  readonly repositoryId: string;
  readonly title: string;
}

export interface CreateRefInput {
  readonly clientMutationId?: string;
  readonly name: string;
  readonly oid: unknown;
  readonly repositoryId: string;
}

export interface CreateRepositoryInput {
  readonly clientMutationId?: string;
  readonly description?: string;
  readonly hasIssuesEnabled?: boolean;
  readonly hasWikiEnabled?: boolean;
  readonly homepageUrl?: unknown;
  readonly name: string;
  readonly ownerId?: string;
  readonly teamId?: string;
  readonly template?: boolean;
  readonly visibility: RepositoryVisibility;
}

export interface CreateTeamDiscussionCommentInput {
  readonly body: string;
  readonly clientMutationId?: string;
  readonly discussionId: string;
}

export interface CreateTeamDiscussionInput {
  readonly body: string;
  readonly clientMutationId?: string;
  readonly private?: boolean;
  readonly teamId: string;
  readonly title: string;
}

export interface DeclineTopicSuggestionInput {
  readonly clientMutationId?: string;
  readonly name: string;
  readonly reason: TopicSuggestionDeclineReason;
  readonly repositoryId: string;
}

export interface DeleteBranchProtectionRuleInput {
  readonly branchProtectionRuleId: string;
  readonly clientMutationId?: string;
}

export interface DeleteDeploymentInput {
  readonly clientMutationId?: string;
  readonly id: string;
}

export interface DeleteIpAllowListEntryInput {
  readonly clientMutationId?: string;
  readonly ipAllowListEntryId: string;
}

export interface DeleteIssueCommentInput {
  readonly clientMutationId?: string;
  readonly id: string;
}

export interface DeleteIssueInput {
  readonly clientMutationId?: string;
  readonly issueId: string;
}

export interface DeleteProjectCardInput {
  readonly cardId: string;
  readonly clientMutationId?: string;
}

export interface DeleteProjectColumnInput {
  readonly clientMutationId?: string;
  readonly columnId: string;
}

export interface DeleteProjectInput {
  readonly clientMutationId?: string;
  readonly projectId: string;
}

export interface DeletePullRequestReviewCommentInput {
  readonly clientMutationId?: string;
  readonly id: string;
}

export interface DeletePullRequestReviewInput {
  readonly clientMutationId?: string;
  readonly pullRequestReviewId: string;
}

export interface DeleteRefInput {
  readonly clientMutationId?: string;
  readonly refId: string;
}

export interface DeleteTeamDiscussionCommentInput {
  readonly clientMutationId?: string;
  readonly id: string;
}

export interface DeleteTeamDiscussionInput {
  readonly clientMutationId?: string;
  readonly id: string;
}

export interface DeploymentOrder {
  readonly direction: OrderDirection;
  readonly field: DeploymentOrderField;
}

export interface DismissPullRequestReviewInput {
  readonly clientMutationId?: string;
  readonly message: string;
  readonly pullRequestReviewId: string;
}

export interface DraftPullRequestReviewComment {
  readonly body: string;
  readonly path: string;
  readonly position: number;
}

export interface DraftPullRequestReviewThread {
  readonly body: string;
  readonly line: number;
  readonly path: string;
  readonly side?: DiffSide;
  readonly startLine?: number;
  readonly startSide?: DiffSide;
}

export interface EnterpriseAdministratorInvitationOrder {
  readonly direction: OrderDirection;
  readonly field: EnterpriseAdministratorInvitationOrderField;
}

export interface EnterpriseMemberOrder {
  readonly direction: OrderDirection;
  readonly field: EnterpriseMemberOrderField;
}

export interface EnterpriseServerInstallationOrder {
  readonly direction: OrderDirection;
  readonly field: EnterpriseServerInstallationOrderField;
}

export interface EnterpriseServerUserAccountEmailOrder {
  readonly direction: OrderDirection;
  readonly field: EnterpriseServerUserAccountEmailOrderField;
}

export interface EnterpriseServerUserAccountOrder {
  readonly direction: OrderDirection;
  readonly field: EnterpriseServerUserAccountOrderField;
}

export interface EnterpriseServerUserAccountsUploadOrder {
  readonly direction: OrderDirection;
  readonly field: EnterpriseServerUserAccountsUploadOrderField;
}

export interface FollowUserInput {
  readonly clientMutationId?: string;
  readonly userId: string;
}

export interface GistOrder {
  readonly direction: OrderDirection;
  readonly field: GistOrderField;
}

export interface InviteEnterpriseAdminInput {
  readonly clientMutationId?: string;
  readonly email?: string;
  readonly enterpriseId: string;
  readonly invitee?: string;
  readonly role?: EnterpriseAdministratorRole;
}

export interface IpAllowListEntryOrder {
  readonly direction: OrderDirection;
  readonly field: IpAllowListEntryOrderField;
}

export interface IssueCommentOrder {
  readonly direction: OrderDirection;
  readonly field: IssueCommentOrderField;
}

export interface IssueFilters {
  readonly assignee?: string;
  readonly createdBy?: string;
  readonly labels?: string[];
  readonly mentioned?: string;
  readonly milestone?: string;
  readonly since?: unknown;
  readonly states?: IssueState[];
  readonly viewerSubscribed?: boolean;
}

export interface IssueOrder {
  readonly direction: OrderDirection;
  readonly field: IssueOrderField;
}

export interface LabelOrder {
  readonly direction: OrderDirection;
  readonly field: LabelOrderField;
}

export interface LanguageOrder {
  readonly direction: OrderDirection;
  readonly field: LanguageOrderField;
}

export interface LinkRepositoryToProjectInput {
  readonly clientMutationId?: string;
  readonly projectId: string;
  readonly repositoryId: string;
}

export interface LockLockableInput {
  readonly clientMutationId?: string;
  readonly lockReason?: LockReason;
  readonly lockableId: string;
}

export interface MarkFileAsViewedInput {
  readonly clientMutationId?: string;
  readonly path: string;
  readonly pullRequestId: string;
}

export interface MarkPullRequestReadyForReviewInput {
  readonly clientMutationId?: string;
  readonly pullRequestId: string;
}

export interface MergeBranchInput {
  readonly authorEmail?: string;
  readonly base: string;
  readonly clientMutationId?: string;
  readonly commitMessage?: string;
  readonly head: string;
  readonly repositoryId: string;
}

export interface MergePullRequestInput {
  readonly authorEmail?: string;
  readonly clientMutationId?: string;
  readonly commitBody?: string;
  readonly commitHeadline?: string;
  readonly expectedHeadOid?: unknown;
  readonly mergeMethod?: PullRequestMergeMethod;
  readonly pullRequestId: string;
}

export interface MilestoneOrder {
  readonly direction: OrderDirection;
  readonly field: MilestoneOrderField;
}

export interface MinimizeCommentInput {
  readonly classifier: ReportedContentClassifiers;
  readonly clientMutationId?: string;
  readonly subjectId: string;
}

export interface MoveProjectCardInput {
  readonly afterCardId?: string;
  readonly cardId: string;
  readonly clientMutationId?: string;
  readonly columnId: string;
}

export interface MoveProjectColumnInput {
  readonly afterColumnId?: string;
  readonly clientMutationId?: string;
  readonly columnId: string;
}

export interface OrganizationOrder {
  readonly direction: OrderDirection;
  readonly field: OrganizationOrderField;
}

export interface PackageFileOrder {
  readonly direction?: OrderDirection;
  readonly field?: PackageFileOrderField;
}

export interface PackageOrder {
  readonly direction?: OrderDirection;
  readonly field?: PackageOrderField;
}

export interface PackageVersionOrder {
  readonly direction?: OrderDirection;
  readonly field?: PackageVersionOrderField;
}

export interface ProjectOrder {
  readonly direction: OrderDirection;
  readonly field: ProjectOrderField;
}

export interface PullRequestOrder {
  readonly direction: OrderDirection;
  readonly field: PullRequestOrderField;
}

export interface ReactionOrder {
  readonly direction: OrderDirection;
  readonly field: ReactionOrderField;
}

export interface RefOrder {
  readonly direction: OrderDirection;
  readonly field: RefOrderField;
}

export interface RegenerateEnterpriseIdentityProviderRecoveryCodesInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
}

export interface ReleaseOrder {
  readonly direction: OrderDirection;
  readonly field: ReleaseOrderField;
}

export interface RemoveAssigneesFromAssignableInput {
  readonly assignableId: string;
  readonly assigneeIds: string;
  readonly clientMutationId?: string;
}

export interface RemoveEnterpriseAdminInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly login: string;
}

export interface RemoveEnterpriseIdentityProviderInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
}

export interface RemoveEnterpriseOrganizationInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly organizationId: string;
}

export interface RemoveLabelsFromLabelableInput {
  readonly clientMutationId?: string;
  readonly labelIds: string;
  readonly labelableId: string;
}

export interface RemoveOutsideCollaboratorInput {
  readonly clientMutationId?: string;
  readonly organizationId: string;
  readonly userId: string;
}

export interface RemoveReactionInput {
  readonly clientMutationId?: string;
  readonly content: ReactionContent;
  readonly subjectId: string;
}

export interface RemoveStarInput {
  readonly clientMutationId?: string;
  readonly starrableId: string;
}

export interface ReopenIssueInput {
  readonly clientMutationId?: string;
  readonly issueId: string;
}

export interface ReopenPullRequestInput {
  readonly clientMutationId?: string;
  readonly pullRequestId: string;
}

export interface RepositoryInvitationOrder {
  readonly direction: OrderDirection;
  readonly field: RepositoryInvitationOrderField;
}

export interface RepositoryOrder {
  readonly direction: OrderDirection;
  readonly field: RepositoryOrderField;
}

export interface RequestReviewsInput {
  readonly clientMutationId?: string;
  readonly pullRequestId: string;
  readonly teamIds?: string[];
  readonly union?: boolean;
  readonly userIds?: string[];
}

export interface RerequestCheckSuiteInput {
  readonly checkSuiteId: string;
  readonly clientMutationId?: string;
  readonly repositoryId: string;
}

export interface ResolveReviewThreadInput {
  readonly clientMutationId?: string;
  readonly threadId: string;
}

export interface SavedReplyOrder {
  readonly direction: OrderDirection;
  readonly field: SavedReplyOrderField;
}

export interface SecurityAdvisoryIdentifierFilter {
  readonly type: SecurityAdvisoryIdentifierType;
  readonly value: string;
}

export interface SecurityAdvisoryOrder {
  readonly direction: OrderDirection;
  readonly field: SecurityAdvisoryOrderField;
}

export interface SecurityVulnerabilityOrder {
  readonly direction: OrderDirection;
  readonly field: SecurityVulnerabilityOrderField;
}

export interface SetEnterpriseIdentityProviderInput {
  readonly clientMutationId?: string;
  readonly digestMethod: SamlDigestAlgorithm;
  readonly enterpriseId: string;
  readonly idpCertificate: string;
  readonly issuer?: string;
  readonly signatureMethod: SamlSignatureAlgorithm;
  readonly ssoUrl: unknown;
}

export interface SetOrganizationInteractionLimitInput {
  readonly clientMutationId?: string;
  readonly expiry?: RepositoryInteractionLimitExpiry;
  readonly limit: RepositoryInteractionLimit;
  readonly organizationId: string;
}

export interface SetRepositoryInteractionLimitInput {
  readonly clientMutationId?: string;
  readonly expiry?: RepositoryInteractionLimitExpiry;
  readonly limit: RepositoryInteractionLimit;
  readonly repositoryId: string;
}

export interface SetUserInteractionLimitInput {
  readonly clientMutationId?: string;
  readonly expiry?: RepositoryInteractionLimitExpiry;
  readonly limit: RepositoryInteractionLimit;
  readonly userId: string;
}

export interface SponsorsTierOrder {
  readonly direction: OrderDirection;
  readonly field: SponsorsTierOrderField;
}

export interface SponsorshipOrder {
  readonly direction: OrderDirection;
  readonly field: SponsorshipOrderField;
}

export interface StarOrder {
  readonly direction: OrderDirection;
  readonly field: StarOrderField;
}

export interface SubmitPullRequestReviewInput {
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly event: PullRequestReviewEvent;
  readonly pullRequestId?: string;
  readonly pullRequestReviewId?: string;
}

export interface TeamDiscussionCommentOrder {
  readonly direction: OrderDirection;
  readonly field: TeamDiscussionCommentOrderField;
}

export interface TeamDiscussionOrder {
  readonly direction: OrderDirection;
  readonly field: TeamDiscussionOrderField;
}

export interface TeamMemberOrder {
  readonly direction: OrderDirection;
  readonly field: TeamMemberOrderField;
}

export interface TeamOrder {
  readonly direction: OrderDirection;
  readonly field: TeamOrderField;
}

export interface TeamRepositoryOrder {
  readonly direction: OrderDirection;
  readonly field: TeamRepositoryOrderField;
}

export interface TransferIssueInput {
  readonly clientMutationId?: string;
  readonly issueId: string;
  readonly repositoryId: string;
}

export interface UnarchiveRepositoryInput {
  readonly clientMutationId?: string;
  readonly repositoryId: string;
}

export interface UnfollowUserInput {
  readonly clientMutationId?: string;
  readonly userId: string;
}

export interface UnlinkRepositoryFromProjectInput {
  readonly clientMutationId?: string;
  readonly projectId: string;
  readonly repositoryId: string;
}

export interface UnlockLockableInput {
  readonly clientMutationId?: string;
  readonly lockableId: string;
}

export interface UnmarkFileAsViewedInput {
  readonly clientMutationId?: string;
  readonly path: string;
  readonly pullRequestId: string;
}

export interface UnmarkIssueAsDuplicateInput {
  readonly canonicalId: string;
  readonly clientMutationId?: string;
  readonly duplicateId: string;
}

export interface UnminimizeCommentInput {
  readonly clientMutationId?: string;
  readonly subjectId: string;
}

export interface UnresolveReviewThreadInput {
  readonly clientMutationId?: string;
  readonly threadId: string;
}

export interface UpdateBranchProtectionRuleInput {
  readonly allowsDeletions?: boolean;
  readonly allowsForcePushes?: boolean;
  readonly branchProtectionRuleId: string;
  readonly clientMutationId?: string;
  readonly dismissesStaleReviews?: boolean;
  readonly isAdminEnforced?: boolean;
  readonly pattern?: string;
  readonly pushActorIds?: string[];
  readonly requiredApprovingReviewCount?: number;
  readonly requiredStatusCheckContexts?: string[];
  readonly requiresApprovingReviews?: boolean;
  readonly requiresCodeOwnerReviews?: boolean;
  readonly requiresCommitSignatures?: boolean;
  readonly requiresLinearHistory?: boolean;
  readonly requiresStatusChecks?: boolean;
  readonly requiresStrictStatusChecks?: boolean;
  readonly restrictsPushes?: boolean;
  readonly restrictsReviewDismissals?: boolean;
  readonly reviewDismissalActorIds?: string[];
}

export interface UpdateCheckRunInput {
  readonly actions?: CheckRunAction[];
  readonly checkRunId: string;
  readonly clientMutationId?: string;
  readonly completedAt?: unknown;
  readonly conclusion?: CheckConclusionState;
  readonly detailsUrl?: unknown;
  readonly externalId?: string;
  readonly name?: string;
  readonly output?: CheckRunOutput;
  readonly repositoryId: string;
  readonly startedAt?: unknown;
  readonly status?: RequestableCheckStatusState;
}

export interface UpdateCheckSuitePreferencesInput {
  readonly autoTriggerPreferences: CheckSuiteAutoTriggerPreference;
  readonly clientMutationId?: string;
  readonly repositoryId: string;
}

export interface UpdateEnterpriseAdministratorRoleInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly login: string;
  readonly role: EnterpriseAdministratorRole;
}

export interface UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseDefaultRepositoryPermissionSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
}

export interface UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanCreateRepositoriesSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly membersCanCreateInternalRepositories?: boolean;
  readonly membersCanCreatePrivateRepositories?: boolean;
  readonly membersCanCreatePublicRepositories?: boolean;
  readonly membersCanCreateRepositoriesPolicyEnabled?: boolean;
  readonly settingValue?: EnterpriseMembersCanCreateRepositoriesSettingValue;
}

export interface UpdateEnterpriseMembersCanDeleteIssuesSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanMakePurchasesSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseMembersCanMakePurchasesSettingValue;
}

export interface UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseOrganizationProjectsSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseProfileInput {
  readonly clientMutationId?: string;
  readonly description?: string;
  readonly enterpriseId: string;
  readonly location?: string;
  readonly name?: string;
  readonly websiteUrl?: string;
}

export interface UpdateEnterpriseRepositoryProjectsSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseTeamDiscussionsSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput {
  readonly clientMutationId?: string;
  readonly enterpriseId: string;
  readonly settingValue: EnterpriseEnabledSettingValue;
}

export interface UpdateIpAllowListEnabledSettingInput {
  readonly clientMutationId?: string;
  readonly ownerId: string;
  readonly settingValue: IpAllowListEnabledSettingValue;
}

export interface UpdateIpAllowListEntryInput {
  readonly allowListValue: string;
  readonly clientMutationId?: string;
  readonly ipAllowListEntryId: string;
  readonly isActive: boolean;
  readonly name?: string;
}

export interface UpdateIssueCommentInput {
  readonly body: string;
  readonly clientMutationId?: string;
  readonly id: string;
}

export interface UpdateIssueInput {
  readonly assigneeIds?: string[];
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly id: string;
  readonly labelIds?: string[];
  readonly milestoneId?: string;
  readonly projectIds?: string[];
  readonly state?: IssueState;
  readonly title?: string;
}

export interface UpdateProjectCardInput {
  readonly clientMutationId?: string;
  readonly isArchived?: boolean;
  readonly note?: string;
  readonly projectCardId: string;
}

export interface UpdateProjectColumnInput {
  readonly clientMutationId?: string;
  readonly name: string;
  readonly projectColumnId: string;
}

export interface UpdateProjectInput {
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly name?: string;
  readonly projectId: string;
  readonly public?: boolean;
  readonly state?: ProjectState;
}

export interface UpdatePullRequestInput {
  readonly assigneeIds?: string[];
  readonly baseRefName?: string;
  readonly body?: string;
  readonly clientMutationId?: string;
  readonly labelIds?: string[];
  readonly maintainerCanModify?: boolean;
  readonly milestoneId?: string;
  readonly projectIds?: string[];
  readonly pullRequestId: string;
  readonly state?: PullRequestUpdateState;
  readonly title?: string;
}

export interface UpdatePullRequestReviewCommentInput {
  readonly body: string;
  readonly clientMutationId?: string;
  readonly pullRequestReviewCommentId: string;
}

export interface UpdatePullRequestReviewInput {
  readonly body: string;
  readonly clientMutationId?: string;
  readonly pullRequestReviewId: string;
}

export interface UpdateRefInput {
  readonly clientMutationId?: string;
  readonly force?: boolean;
  readonly oid: unknown;
  readonly refId: string;
}

export interface UpdateRepositoryInput {
  readonly clientMutationId?: string;
  readonly description?: string;
  readonly hasIssuesEnabled?: boolean;
  readonly hasProjectsEnabled?: boolean;
  readonly hasWikiEnabled?: boolean;
  readonly homepageUrl?: unknown;
  readonly name?: string;
  readonly repositoryId: string;
  readonly template?: boolean;
}

export interface UpdateSubscriptionInput {
  readonly clientMutationId?: string;
  readonly state: SubscriptionState;
  readonly subscribableId: string;
}

export interface UpdateTeamDiscussionCommentInput {
  readonly body: string;
  readonly bodyVersion?: string;
  readonly clientMutationId?: string;
  readonly id: string;
}

export interface UpdateTeamDiscussionInput {
  readonly body?: string;
  readonly bodyVersion?: string;
  readonly clientMutationId?: string;
  readonly id: string;
  readonly pinned?: boolean;
  readonly title?: string;
}

export interface UpdateTopicsInput {
  readonly clientMutationId?: string;
  readonly repositoryId: string;
  readonly topicNames: string;
}

export interface UserStatusOrder {
  readonly direction: OrderDirection;
  readonly field: UserStatusOrderField;
}

type IAssignee = IBot | IMannequin | IOrganization | IUser;

export const isAssignee = (
  object: Record<string, any>
): object is Partial<IAssignee> => {
  return object.__typename === "Assignee";
};

interface AssigneeSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "Bot" | "Mannequin" | "Organization" | "User"
  >(
    type: F,
    select: (
      t: F extends "Bot"
        ? BotSelector
        : F extends "Mannequin"
        ? MannequinSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Bot"
        ? IBot
        : F extends "Mannequin"
        ? IMannequin
        : F extends "Organization"
        ? IOrganization
        : F extends "User"
        ? IUser
        : never
    >,
    SelectionSet<T>
  >;
}

export const Assignee: AssigneeSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Assignee",
        });
    }
  },
};

type IAuditEntryActor = IBot | IOrganization | IUser;

export const isAuditEntryActor = (
  object: Record<string, any>
): object is Partial<IAuditEntryActor> => {
  return object.__typename === "AuditEntryActor";
};

interface AuditEntryActorSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "Bot" | "Organization" | "User"
  >(
    type: F,
    select: (
      t: F extends "Bot"
        ? BotSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Bot"
        ? IBot
        : F extends "Organization"
        ? IOrganization
        : F extends "User"
        ? IUser
        : never
    >,
    SelectionSet<T>
  >;
}

export const AuditEntryActor: AuditEntryActorSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "AuditEntryActor",
        });
    }
  },
};

type ICloser = ICommit | IPullRequest;

export const isCloser = (
  object: Record<string, any>
): object is Partial<ICloser> => {
  return object.__typename === "Closer";
};

interface CloserSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Commit" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Commit"
        ? CommitSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Commit"
        ? ICommit
        : F extends "PullRequest"
        ? IPullRequest
        : never
    >,
    SelectionSet<T>
  >;
}

export const Closer: CloserSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Closer",
        });
    }
  },
};

type ICreatedIssueOrRestrictedContribution =
  | ICreatedIssueContribution
  | IRestrictedContribution;

export const isCreatedIssueOrRestrictedContribution = (
  object: Record<string, any>
): object is Partial<ICreatedIssueOrRestrictedContribution> => {
  return object.__typename === "CreatedIssueOrRestrictedContribution";
};

interface CreatedIssueOrRestrictedContributionSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "CreatedIssueContribution" | "RestrictedContribution"
  >(
    type: F,
    select: (
      t: F extends "CreatedIssueContribution"
        ? CreatedIssueContributionSelector
        : F extends "RestrictedContribution"
        ? RestrictedContributionSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "CreatedIssueContribution"
        ? ICreatedIssueContribution
        : F extends "RestrictedContribution"
        ? IRestrictedContribution
        : never
    >,
    SelectionSet<T>
  >;
}

export const CreatedIssueOrRestrictedContribution: CreatedIssueOrRestrictedContributionSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "CreatedIssueContribution": {
        return new InlineFragment(
          new NamedType("CreatedIssueContribution") as any,
          new SelectionSet(select(CreatedIssueContribution as any))
        );
      }

      case "RestrictedContribution": {
        return new InlineFragment(
          new NamedType("RestrictedContribution") as any,
          new SelectionSet(select(RestrictedContribution as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "CreatedIssueOrRestrictedContribution",
        });
    }
  },
};

type ICreatedPullRequestOrRestrictedContribution =
  | ICreatedPullRequestContribution
  | IRestrictedContribution;

export const isCreatedPullRequestOrRestrictedContribution = (
  object: Record<string, any>
): object is Partial<ICreatedPullRequestOrRestrictedContribution> => {
  return object.__typename === "CreatedPullRequestOrRestrictedContribution";
};

interface CreatedPullRequestOrRestrictedContributionSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "CreatedPullRequestContribution" | "RestrictedContribution"
  >(
    type: F,
    select: (
      t: F extends "CreatedPullRequestContribution"
        ? CreatedPullRequestContributionSelector
        : F extends "RestrictedContribution"
        ? RestrictedContributionSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "CreatedPullRequestContribution"
        ? ICreatedPullRequestContribution
        : F extends "RestrictedContribution"
        ? IRestrictedContribution
        : never
    >,
    SelectionSet<T>
  >;
}

export const CreatedPullRequestOrRestrictedContribution: CreatedPullRequestOrRestrictedContributionSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "CreatedPullRequestContribution": {
        return new InlineFragment(
          new NamedType("CreatedPullRequestContribution") as any,
          new SelectionSet(select(CreatedPullRequestContribution as any))
        );
      }

      case "RestrictedContribution": {
        return new InlineFragment(
          new NamedType("RestrictedContribution") as any,
          new SelectionSet(select(RestrictedContribution as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "CreatedPullRequestOrRestrictedContribution",
        });
    }
  },
};

type ICreatedRepositoryOrRestrictedContribution =
  | ICreatedRepositoryContribution
  | IRestrictedContribution;

export const isCreatedRepositoryOrRestrictedContribution = (
  object: Record<string, any>
): object is Partial<ICreatedRepositoryOrRestrictedContribution> => {
  return object.__typename === "CreatedRepositoryOrRestrictedContribution";
};

interface CreatedRepositoryOrRestrictedContributionSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "CreatedRepositoryContribution" | "RestrictedContribution"
  >(
    type: F,
    select: (
      t: F extends "CreatedRepositoryContribution"
        ? CreatedRepositoryContributionSelector
        : F extends "RestrictedContribution"
        ? RestrictedContributionSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "CreatedRepositoryContribution"
        ? ICreatedRepositoryContribution
        : F extends "RestrictedContribution"
        ? IRestrictedContribution
        : never
    >,
    SelectionSet<T>
  >;
}

export const CreatedRepositoryOrRestrictedContribution: CreatedRepositoryOrRestrictedContributionSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "CreatedRepositoryContribution": {
        return new InlineFragment(
          new NamedType("CreatedRepositoryContribution") as any,
          new SelectionSet(select(CreatedRepositoryContribution as any))
        );
      }

      case "RestrictedContribution": {
        return new InlineFragment(
          new NamedType("RestrictedContribution") as any,
          new SelectionSet(select(RestrictedContribution as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "CreatedRepositoryOrRestrictedContribution",
        });
    }
  },
};

type IEnterpriseMember = IEnterpriseUserAccount | IUser;

export const isEnterpriseMember = (
  object: Record<string, any>
): object is Partial<IEnterpriseMember> => {
  return object.__typename === "EnterpriseMember";
};

interface EnterpriseMemberSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "EnterpriseUserAccount" | "User"
  >(
    type: F,
    select: (
      t: F extends "EnterpriseUserAccount"
        ? EnterpriseUserAccountSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "EnterpriseUserAccount"
        ? IEnterpriseUserAccount
        : F extends "User"
        ? IUser
        : never
    >,
    SelectionSet<T>
  >;
}

export const EnterpriseMember: EnterpriseMemberSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "EnterpriseUserAccount": {
        return new InlineFragment(
          new NamedType("EnterpriseUserAccount") as any,
          new SelectionSet(select(EnterpriseUserAccount as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "EnterpriseMember",
        });
    }
  },
};

type IIpAllowListOwner = IEnterprise | IOrganization;

export const isIpAllowListOwner = (
  object: Record<string, any>
): object is Partial<IIpAllowListOwner> => {
  return object.__typename === "IpAllowListOwner";
};

interface IpAllowListOwnerSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "Enterprise" | "Organization"
  >(
    type: F,
    select: (
      t: F extends "Enterprise"
        ? EnterpriseSelector
        : F extends "Organization"
        ? OrganizationSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Enterprise"
        ? IEnterprise
        : F extends "Organization"
        ? IOrganization
        : never
    >,
    SelectionSet<T>
  >;
}

export const IpAllowListOwner: IpAllowListOwnerSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Enterprise": {
        return new InlineFragment(
          new NamedType("Enterprise") as any,
          new SelectionSet(select(Enterprise as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "IpAllowListOwner",
        });
    }
  },
};

type IIssueOrPullRequest = IIssue | IPullRequest;

export const isIssueOrPullRequest = (
  object: Record<string, any>
): object is Partial<IIssueOrPullRequest> => {
  return object.__typename === "IssueOrPullRequest";
};

interface IssueOrPullRequestSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Issue"
        ? IIssue
        : F extends "PullRequest"
        ? IPullRequest
        : never
    >,
    SelectionSet<T>
  >;
}

export const IssueOrPullRequest: IssueOrPullRequestSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "IssueOrPullRequest",
        });
    }
  },
};

type IIssueTimelineItem =
  | IAssignedEvent
  | IClosedEvent
  | ICommit
  | ICrossReferencedEvent
  | IDemilestonedEvent
  | IIssueComment
  | ILabeledEvent
  | ILockedEvent
  | IMilestonedEvent
  | IReferencedEvent
  | IRenamedTitleEvent
  | IReopenedEvent
  | ISubscribedEvent
  | ITransferredEvent
  | IUnassignedEvent
  | IUnlabeledEvent
  | IUnlockedEvent
  | IUnsubscribedEvent
  | IUserBlockedEvent;

export const isIssueTimelineItem = (
  object: Record<string, any>
): object is Partial<IIssueTimelineItem> => {
  return object.__typename === "IssueTimelineItem";
};

interface IssueTimelineItemSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "AssignedEvent"
      | "ClosedEvent"
      | "Commit"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "IssueComment"
      | "LabeledEvent"
      | "LockedEvent"
      | "MilestonedEvent"
      | "ReferencedEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "SubscribedEvent"
      | "TransferredEvent"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnsubscribedEvent"
      | "UserBlockedEvent"
  >(
    type: F,
    select: (
      t: F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "TransferredEvent"
        ? TransferredEventSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "AssignedEvent"
        ? IAssignedEvent
        : F extends "ClosedEvent"
        ? IClosedEvent
        : F extends "Commit"
        ? ICommit
        : F extends "CrossReferencedEvent"
        ? ICrossReferencedEvent
        : F extends "DemilestonedEvent"
        ? IDemilestonedEvent
        : F extends "IssueComment"
        ? IIssueComment
        : F extends "LabeledEvent"
        ? ILabeledEvent
        : F extends "LockedEvent"
        ? ILockedEvent
        : F extends "MilestonedEvent"
        ? IMilestonedEvent
        : F extends "ReferencedEvent"
        ? IReferencedEvent
        : F extends "RenamedTitleEvent"
        ? IRenamedTitleEvent
        : F extends "ReopenedEvent"
        ? IReopenedEvent
        : F extends "SubscribedEvent"
        ? ISubscribedEvent
        : F extends "TransferredEvent"
        ? ITransferredEvent
        : F extends "UnassignedEvent"
        ? IUnassignedEvent
        : F extends "UnlabeledEvent"
        ? IUnlabeledEvent
        : F extends "UnlockedEvent"
        ? IUnlockedEvent
        : F extends "UnsubscribedEvent"
        ? IUnsubscribedEvent
        : F extends "UserBlockedEvent"
        ? IUserBlockedEvent
        : never
    >,
    SelectionSet<T>
  >;
}

export const IssueTimelineItem: IssueTimelineItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "TransferredEvent": {
        return new InlineFragment(
          new NamedType("TransferredEvent") as any,
          new SelectionSet(select(TransferredEvent as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "IssueTimelineItem",
        });
    }
  },
};

type IIssueTimelineItems =
  | IAddedToProjectEvent
  | IAssignedEvent
  | IClosedEvent
  | ICommentDeletedEvent
  | IConnectedEvent
  | IConvertedNoteToIssueEvent
  | ICrossReferencedEvent
  | IDemilestonedEvent
  | IDisconnectedEvent
  | IIssueComment
  | ILabeledEvent
  | ILockedEvent
  | IMarkedAsDuplicateEvent
  | IMentionedEvent
  | IMilestonedEvent
  | IMovedColumnsInProjectEvent
  | IPinnedEvent
  | IReferencedEvent
  | IRemovedFromProjectEvent
  | IRenamedTitleEvent
  | IReopenedEvent
  | ISubscribedEvent
  | ITransferredEvent
  | IUnassignedEvent
  | IUnlabeledEvent
  | IUnlockedEvent
  | IUnmarkedAsDuplicateEvent
  | IUnpinnedEvent
  | IUnsubscribedEvent
  | IUserBlockedEvent;

export const isIssueTimelineItems = (
  object: Record<string, any>
): object is Partial<IIssueTimelineItems> => {
  return object.__typename === "IssueTimelineItems";
};

interface IssueTimelineItemsSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "AddedToProjectEvent"
      | "AssignedEvent"
      | "ClosedEvent"
      | "CommentDeletedEvent"
      | "ConnectedEvent"
      | "ConvertedNoteToIssueEvent"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "DisconnectedEvent"
      | "IssueComment"
      | "LabeledEvent"
      | "LockedEvent"
      | "MarkedAsDuplicateEvent"
      | "MentionedEvent"
      | "MilestonedEvent"
      | "MovedColumnsInProjectEvent"
      | "PinnedEvent"
      | "ReferencedEvent"
      | "RemovedFromProjectEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "SubscribedEvent"
      | "TransferredEvent"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnmarkedAsDuplicateEvent"
      | "UnpinnedEvent"
      | "UnsubscribedEvent"
      | "UserBlockedEvent"
  >(
    type: F,
    select: (
      t: F extends "AddedToProjectEvent"
        ? AddedToProjectEventSelector
        : F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "CommentDeletedEvent"
        ? CommentDeletedEventSelector
        : F extends "ConnectedEvent"
        ? ConnectedEventSelector
        : F extends "ConvertedNoteToIssueEvent"
        ? ConvertedNoteToIssueEventSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "DisconnectedEvent"
        ? DisconnectedEventSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "MarkedAsDuplicateEvent"
        ? MarkedAsDuplicateEventSelector
        : F extends "MentionedEvent"
        ? MentionedEventSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "MovedColumnsInProjectEvent"
        ? MovedColumnsInProjectEventSelector
        : F extends "PinnedEvent"
        ? PinnedEventSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "RemovedFromProjectEvent"
        ? RemovedFromProjectEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "TransferredEvent"
        ? TransferredEventSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnmarkedAsDuplicateEvent"
        ? UnmarkedAsDuplicateEventSelector
        : F extends "UnpinnedEvent"
        ? UnpinnedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "AddedToProjectEvent"
        ? IAddedToProjectEvent
        : F extends "AssignedEvent"
        ? IAssignedEvent
        : F extends "ClosedEvent"
        ? IClosedEvent
        : F extends "CommentDeletedEvent"
        ? ICommentDeletedEvent
        : F extends "ConnectedEvent"
        ? IConnectedEvent
        : F extends "ConvertedNoteToIssueEvent"
        ? IConvertedNoteToIssueEvent
        : F extends "CrossReferencedEvent"
        ? ICrossReferencedEvent
        : F extends "DemilestonedEvent"
        ? IDemilestonedEvent
        : F extends "DisconnectedEvent"
        ? IDisconnectedEvent
        : F extends "IssueComment"
        ? IIssueComment
        : F extends "LabeledEvent"
        ? ILabeledEvent
        : F extends "LockedEvent"
        ? ILockedEvent
        : F extends "MarkedAsDuplicateEvent"
        ? IMarkedAsDuplicateEvent
        : F extends "MentionedEvent"
        ? IMentionedEvent
        : F extends "MilestonedEvent"
        ? IMilestonedEvent
        : F extends "MovedColumnsInProjectEvent"
        ? IMovedColumnsInProjectEvent
        : F extends "PinnedEvent"
        ? IPinnedEvent
        : F extends "ReferencedEvent"
        ? IReferencedEvent
        : F extends "RemovedFromProjectEvent"
        ? IRemovedFromProjectEvent
        : F extends "RenamedTitleEvent"
        ? IRenamedTitleEvent
        : F extends "ReopenedEvent"
        ? IReopenedEvent
        : F extends "SubscribedEvent"
        ? ISubscribedEvent
        : F extends "TransferredEvent"
        ? ITransferredEvent
        : F extends "UnassignedEvent"
        ? IUnassignedEvent
        : F extends "UnlabeledEvent"
        ? IUnlabeledEvent
        : F extends "UnlockedEvent"
        ? IUnlockedEvent
        : F extends "UnmarkedAsDuplicateEvent"
        ? IUnmarkedAsDuplicateEvent
        : F extends "UnpinnedEvent"
        ? IUnpinnedEvent
        : F extends "UnsubscribedEvent"
        ? IUnsubscribedEvent
        : F extends "UserBlockedEvent"
        ? IUserBlockedEvent
        : never
    >,
    SelectionSet<T>
  >;
}

export const IssueTimelineItems: IssueTimelineItemsSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "AddedToProjectEvent": {
        return new InlineFragment(
          new NamedType("AddedToProjectEvent") as any,
          new SelectionSet(select(AddedToProjectEvent as any))
        );
      }

      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "CommentDeletedEvent": {
        return new InlineFragment(
          new NamedType("CommentDeletedEvent") as any,
          new SelectionSet(select(CommentDeletedEvent as any))
        );
      }

      case "ConnectedEvent": {
        return new InlineFragment(
          new NamedType("ConnectedEvent") as any,
          new SelectionSet(select(ConnectedEvent as any))
        );
      }

      case "ConvertedNoteToIssueEvent": {
        return new InlineFragment(
          new NamedType("ConvertedNoteToIssueEvent") as any,
          new SelectionSet(select(ConvertedNoteToIssueEvent as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "DisconnectedEvent": {
        return new InlineFragment(
          new NamedType("DisconnectedEvent") as any,
          new SelectionSet(select(DisconnectedEvent as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "MarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("MarkedAsDuplicateEvent") as any,
          new SelectionSet(select(MarkedAsDuplicateEvent as any))
        );
      }

      case "MentionedEvent": {
        return new InlineFragment(
          new NamedType("MentionedEvent") as any,
          new SelectionSet(select(MentionedEvent as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "MovedColumnsInProjectEvent": {
        return new InlineFragment(
          new NamedType("MovedColumnsInProjectEvent") as any,
          new SelectionSet(select(MovedColumnsInProjectEvent as any))
        );
      }

      case "PinnedEvent": {
        return new InlineFragment(
          new NamedType("PinnedEvent") as any,
          new SelectionSet(select(PinnedEvent as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "RemovedFromProjectEvent": {
        return new InlineFragment(
          new NamedType("RemovedFromProjectEvent") as any,
          new SelectionSet(select(RemovedFromProjectEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "TransferredEvent": {
        return new InlineFragment(
          new NamedType("TransferredEvent") as any,
          new SelectionSet(select(TransferredEvent as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnmarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("UnmarkedAsDuplicateEvent") as any,
          new SelectionSet(select(UnmarkedAsDuplicateEvent as any))
        );
      }

      case "UnpinnedEvent": {
        return new InlineFragment(
          new NamedType("UnpinnedEvent") as any,
          new SelectionSet(select(UnpinnedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "IssueTimelineItems",
        });
    }
  },
};

type IMilestoneItem = IIssue | IPullRequest;

export const isMilestoneItem = (
  object: Record<string, any>
): object is Partial<IMilestoneItem> => {
  return object.__typename === "MilestoneItem";
};

interface MilestoneItemSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Issue"
        ? IIssue
        : F extends "PullRequest"
        ? IPullRequest
        : never
    >,
    SelectionSet<T>
  >;
}

export const MilestoneItem: MilestoneItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "MilestoneItem",
        });
    }
  },
};

type IOrgRestoreMemberAuditEntryMembership =
  | IOrgRestoreMemberMembershipOrganizationAuditEntryData
  | IOrgRestoreMemberMembershipRepositoryAuditEntryData
  | IOrgRestoreMemberMembershipTeamAuditEntryData;

export const isOrgRestoreMemberAuditEntryMembership = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberAuditEntryMembership> => {
  return object.__typename === "OrgRestoreMemberAuditEntryMembership";
};

interface OrgRestoreMemberAuditEntryMembershipSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "OrgRestoreMemberMembershipOrganizationAuditEntryData"
      | "OrgRestoreMemberMembershipRepositoryAuditEntryData"
      | "OrgRestoreMemberMembershipTeamAuditEntryData"
  >(
    type: F,
    select: (
      t: F extends "OrgRestoreMemberMembershipOrganizationAuditEntryData"
        ? OrgRestoreMemberMembershipOrganizationAuditEntryDataSelector
        : F extends "OrgRestoreMemberMembershipRepositoryAuditEntryData"
        ? OrgRestoreMemberMembershipRepositoryAuditEntryDataSelector
        : F extends "OrgRestoreMemberMembershipTeamAuditEntryData"
        ? OrgRestoreMemberMembershipTeamAuditEntryDataSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "OrgRestoreMemberMembershipOrganizationAuditEntryData"
        ? IOrgRestoreMemberMembershipOrganizationAuditEntryData
        : F extends "OrgRestoreMemberMembershipRepositoryAuditEntryData"
        ? IOrgRestoreMemberMembershipRepositoryAuditEntryData
        : F extends "OrgRestoreMemberMembershipTeamAuditEntryData"
        ? IOrgRestoreMemberMembershipTeamAuditEntryData
        : never
    >,
    SelectionSet<T>
  >;
}

export const OrgRestoreMemberAuditEntryMembership: OrgRestoreMemberAuditEntryMembershipSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "OrgRestoreMemberMembershipOrganizationAuditEntryData": {
        return new InlineFragment(
          new NamedType(
            "OrgRestoreMemberMembershipOrganizationAuditEntryData"
          ) as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipOrganizationAuditEntryData as any)
          )
        );
      }

      case "OrgRestoreMemberMembershipRepositoryAuditEntryData": {
        return new InlineFragment(
          new NamedType(
            "OrgRestoreMemberMembershipRepositoryAuditEntryData"
          ) as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipRepositoryAuditEntryData as any)
          )
        );
      }

      case "OrgRestoreMemberMembershipTeamAuditEntryData": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberMembershipTeamAuditEntryData") as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipTeamAuditEntryData as any)
          )
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "OrgRestoreMemberAuditEntryMembership",
        });
    }
  },
};

type IOrganizationAuditEntry =
  | IMembersCanDeleteReposClearAuditEntry
  | IMembersCanDeleteReposDisableAuditEntry
  | IMembersCanDeleteReposEnableAuditEntry
  | IOauthApplicationCreateAuditEntry
  | IOrgAddBillingManagerAuditEntry
  | IOrgAddMemberAuditEntry
  | IOrgBlockUserAuditEntry
  | IOrgConfigDisableCollaboratorsOnlyAuditEntry
  | IOrgConfigEnableCollaboratorsOnlyAuditEntry
  | IOrgCreateAuditEntry
  | IOrgDisableOauthAppRestrictionsAuditEntry
  | IOrgDisableSamlAuditEntry
  | IOrgDisableTwoFactorRequirementAuditEntry
  | IOrgEnableOauthAppRestrictionsAuditEntry
  | IOrgEnableSamlAuditEntry
  | IOrgEnableTwoFactorRequirementAuditEntry
  | IOrgInviteMemberAuditEntry
  | IOrgInviteToBusinessAuditEntry
  | IOrgOauthAppAccessApprovedAuditEntry
  | IOrgOauthAppAccessDeniedAuditEntry
  | IOrgOauthAppAccessRequestedAuditEntry
  | IOrgRemoveBillingManagerAuditEntry
  | IOrgRemoveMemberAuditEntry
  | IOrgRemoveOutsideCollaboratorAuditEntry
  | IOrgRestoreMemberAuditEntry
  | IOrgUnblockUserAuditEntry
  | IOrgUpdateDefaultRepositoryPermissionAuditEntry
  | IOrgUpdateMemberAuditEntry
  | IOrgUpdateMemberRepositoryCreationPermissionAuditEntry
  | IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry
  | IPrivateRepositoryForkingDisableAuditEntry
  | IPrivateRepositoryForkingEnableAuditEntry
  | IRepoAccessAuditEntry
  | IRepoAddMemberAuditEntry
  | IRepoAddTopicAuditEntry
  | IRepoArchivedAuditEntry
  | IRepoChangeMergeSettingAuditEntry
  | IRepoConfigDisableAnonymousGitAccessAuditEntry
  | IRepoConfigDisableCollaboratorsOnlyAuditEntry
  | IRepoConfigDisableContributorsOnlyAuditEntry
  | IRepoConfigDisableSockpuppetDisallowedAuditEntry
  | IRepoConfigEnableAnonymousGitAccessAuditEntry
  | IRepoConfigEnableCollaboratorsOnlyAuditEntry
  | IRepoConfigEnableContributorsOnlyAuditEntry
  | IRepoConfigEnableSockpuppetDisallowedAuditEntry
  | IRepoConfigLockAnonymousGitAccessAuditEntry
  | IRepoConfigUnlockAnonymousGitAccessAuditEntry
  | IRepoCreateAuditEntry
  | IRepoDestroyAuditEntry
  | IRepoRemoveMemberAuditEntry
  | IRepoRemoveTopicAuditEntry
  | IRepositoryVisibilityChangeDisableAuditEntry
  | IRepositoryVisibilityChangeEnableAuditEntry
  | ITeamAddMemberAuditEntry
  | ITeamAddRepositoryAuditEntry
  | ITeamChangeParentTeamAuditEntry
  | ITeamRemoveMemberAuditEntry
  | ITeamRemoveRepositoryAuditEntry;

export const isOrganizationAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrganizationAuditEntry> => {
  return object.__typename === "OrganizationAuditEntry";
};

interface OrganizationAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "OauthApplicationCreateAuditEntry"
      | "OrgAddBillingManagerAuditEntry"
      | "OrgAddMemberAuditEntry"
      | "OrgBlockUserAuditEntry"
      | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
      | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
      | "OrgCreateAuditEntry"
      | "OrgDisableOauthAppRestrictionsAuditEntry"
      | "OrgDisableSamlAuditEntry"
      | "OrgDisableTwoFactorRequirementAuditEntry"
      | "OrgEnableOauthAppRestrictionsAuditEntry"
      | "OrgEnableSamlAuditEntry"
      | "OrgEnableTwoFactorRequirementAuditEntry"
      | "OrgInviteMemberAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
      | "OrgRemoveBillingManagerAuditEntry"
      | "OrgRemoveMemberAuditEntry"
      | "OrgRemoveOutsideCollaboratorAuditEntry"
      | "OrgRestoreMemberAuditEntry"
      | "OrgUnblockUserAuditEntry"
      | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
      | "OrgUpdateMemberAuditEntry"
      | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
      | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgAddBillingManagerAuditEntry"
        ? OrgAddBillingManagerAuditEntrySelector
        : F extends "OrgAddMemberAuditEntry"
        ? OrgAddMemberAuditEntrySelector
        : F extends "OrgBlockUserAuditEntry"
        ? OrgBlockUserAuditEntrySelector
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? OrgConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? OrgConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgCreateAuditEntry"
        ? OrgCreateAuditEntrySelector
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? OrgDisableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgDisableSamlAuditEntry"
        ? OrgDisableSamlAuditEntrySelector
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? OrgDisableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? OrgEnableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgEnableSamlAuditEntry"
        ? OrgEnableSamlAuditEntrySelector
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? OrgEnableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgInviteMemberAuditEntry"
        ? OrgInviteMemberAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? OrgRemoveBillingManagerAuditEntrySelector
        : F extends "OrgRemoveMemberAuditEntry"
        ? OrgRemoveMemberAuditEntrySelector
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? OrgRemoveOutsideCollaboratorAuditEntrySelector
        : F extends "OrgRestoreMemberAuditEntry"
        ? OrgRestoreMemberAuditEntrySelector
        : F extends "OrgUnblockUserAuditEntry"
        ? OrgUnblockUserAuditEntrySelector
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? OrgUpdateDefaultRepositoryPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberAuditEntry"
        ? OrgUpdateMemberAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "MembersCanDeleteReposClearAuditEntry"
        ? IMembersCanDeleteReposClearAuditEntry
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? IMembersCanDeleteReposDisableAuditEntry
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? IMembersCanDeleteReposEnableAuditEntry
        : F extends "OauthApplicationCreateAuditEntry"
        ? IOauthApplicationCreateAuditEntry
        : F extends "OrgAddBillingManagerAuditEntry"
        ? IOrgAddBillingManagerAuditEntry
        : F extends "OrgAddMemberAuditEntry"
        ? IOrgAddMemberAuditEntry
        : F extends "OrgBlockUserAuditEntry"
        ? IOrgBlockUserAuditEntry
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? IOrgConfigDisableCollaboratorsOnlyAuditEntry
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? IOrgConfigEnableCollaboratorsOnlyAuditEntry
        : F extends "OrgCreateAuditEntry"
        ? IOrgCreateAuditEntry
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? IOrgDisableOauthAppRestrictionsAuditEntry
        : F extends "OrgDisableSamlAuditEntry"
        ? IOrgDisableSamlAuditEntry
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? IOrgDisableTwoFactorRequirementAuditEntry
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? IOrgEnableOauthAppRestrictionsAuditEntry
        : F extends "OrgEnableSamlAuditEntry"
        ? IOrgEnableSamlAuditEntry
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? IOrgEnableTwoFactorRequirementAuditEntry
        : F extends "OrgInviteMemberAuditEntry"
        ? IOrgInviteMemberAuditEntry
        : F extends "OrgInviteToBusinessAuditEntry"
        ? IOrgInviteToBusinessAuditEntry
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? IOrgOauthAppAccessApprovedAuditEntry
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? IOrgOauthAppAccessDeniedAuditEntry
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? IOrgOauthAppAccessRequestedAuditEntry
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? IOrgRemoveBillingManagerAuditEntry
        : F extends "OrgRemoveMemberAuditEntry"
        ? IOrgRemoveMemberAuditEntry
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? IOrgRemoveOutsideCollaboratorAuditEntry
        : F extends "OrgRestoreMemberAuditEntry"
        ? IOrgRestoreMemberAuditEntry
        : F extends "OrgUnblockUserAuditEntry"
        ? IOrgUnblockUserAuditEntry
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? IOrgUpdateDefaultRepositoryPermissionAuditEntry
        : F extends "OrgUpdateMemberAuditEntry"
        ? IOrgUpdateMemberAuditEntry
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? IOrgUpdateMemberRepositoryCreationPermissionAuditEntry
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? IPrivateRepositoryForkingDisableAuditEntry
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? IPrivateRepositoryForkingEnableAuditEntry
        : F extends "RepoAccessAuditEntry"
        ? IRepoAccessAuditEntry
        : F extends "RepoAddMemberAuditEntry"
        ? IRepoAddMemberAuditEntry
        : F extends "RepoAddTopicAuditEntry"
        ? IRepoAddTopicAuditEntry
        : F extends "RepoArchivedAuditEntry"
        ? IRepoArchivedAuditEntry
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? IRepoChangeMergeSettingAuditEntry
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? IRepoConfigDisableAnonymousGitAccessAuditEntry
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? IRepoConfigDisableCollaboratorsOnlyAuditEntry
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? IRepoConfigDisableContributorsOnlyAuditEntry
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? IRepoConfigDisableSockpuppetDisallowedAuditEntry
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? IRepoConfigEnableAnonymousGitAccessAuditEntry
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? IRepoConfigEnableCollaboratorsOnlyAuditEntry
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? IRepoConfigEnableContributorsOnlyAuditEntry
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? IRepoConfigEnableSockpuppetDisallowedAuditEntry
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? IRepoConfigLockAnonymousGitAccessAuditEntry
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? IRepoConfigUnlockAnonymousGitAccessAuditEntry
        : F extends "RepoCreateAuditEntry"
        ? IRepoCreateAuditEntry
        : F extends "RepoDestroyAuditEntry"
        ? IRepoDestroyAuditEntry
        : F extends "RepoRemoveMemberAuditEntry"
        ? IRepoRemoveMemberAuditEntry
        : F extends "RepoRemoveTopicAuditEntry"
        ? IRepoRemoveTopicAuditEntry
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? IRepositoryVisibilityChangeDisableAuditEntry
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? IRepositoryVisibilityChangeEnableAuditEntry
        : F extends "TeamAddMemberAuditEntry"
        ? ITeamAddMemberAuditEntry
        : F extends "TeamAddRepositoryAuditEntry"
        ? ITeamAddRepositoryAuditEntry
        : F extends "TeamChangeParentTeamAuditEntry"
        ? ITeamChangeParentTeamAuditEntry
        : F extends "TeamRemoveMemberAuditEntry"
        ? ITeamRemoveMemberAuditEntry
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? ITeamRemoveRepositoryAuditEntry
        : never
    >,
    SelectionSet<T>
  >;
}

export const OrganizationAuditEntry: OrganizationAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgAddBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgAddBillingManagerAuditEntry as any))
        );
      }

      case "OrgAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddMemberAuditEntry") as any,
          new SelectionSet(select(OrgAddMemberAuditEntry as any))
        );
      }

      case "OrgBlockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgBlockUserAuditEntry") as any,
          new SelectionSet(select(OrgBlockUserAuditEntry as any))
        );
      }

      case "OrgConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgCreateAuditEntry") as any,
          new SelectionSet(select(OrgCreateAuditEntry as any))
        );
      }

      case "OrgDisableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgDisableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableSamlAuditEntry") as any,
          new SelectionSet(select(OrgDisableSamlAuditEntry as any))
        );
      }

      case "OrgDisableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgEnableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgEnableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableSamlAuditEntry") as any,
          new SelectionSet(select(OrgEnableSamlAuditEntry as any))
        );
      }

      case "OrgEnableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgInviteMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteMemberAuditEntry") as any,
          new SelectionSet(select(OrgInviteMemberAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      case "OrgRemoveBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgRemoveBillingManagerAuditEntry as any))
        );
      }

      case "OrgRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveMemberAuditEntry") as any,
          new SelectionSet(select(OrgRemoveMemberAuditEntry as any))
        );
      }

      case "OrgRemoveOutsideCollaboratorAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveOutsideCollaboratorAuditEntry") as any,
          new SelectionSet(
            select(OrgRemoveOutsideCollaboratorAuditEntry as any)
          )
        );
      }

      case "OrgRestoreMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberAuditEntry") as any,
          new SelectionSet(select(OrgRestoreMemberAuditEntry as any))
        );
      }

      case "OrgUnblockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUnblockUserAuditEntry") as any,
          new SelectionSet(select(OrgUnblockUserAuditEntry as any))
        );
      }

      case "OrgUpdateDefaultRepositoryPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateDefaultRepositoryPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateDefaultRepositoryPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUpdateMemberAuditEntry") as any,
          new SelectionSet(select(OrgUpdateMemberAuditEntry as any))
        );
      }

      case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateMemberRepositoryCreationPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(
              OrgUpdateMemberRepositoryInvitationPermissionAuditEntry as any
            )
          )
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "OrganizationAuditEntry",
        });
    }
  },
};

type IPermissionGranter = IOrganization | IRepository | ITeam;

export const isPermissionGranter = (
  object: Record<string, any>
): object is Partial<IPermissionGranter> => {
  return object.__typename === "PermissionGranter";
};

interface PermissionGranterSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "Organization" | "Repository" | "Team"
  >(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "Team"
        ? TeamSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Organization"
        ? IOrganization
        : F extends "Repository"
        ? IRepository
        : F extends "Team"
        ? ITeam
        : never
    >,
    SelectionSet<T>
  >;
}

export const PermissionGranter: PermissionGranterSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "PermissionGranter",
        });
    }
  },
};

type IPinnableItem = IGist | IRepository;

export const isPinnableItem = (
  object: Record<string, any>
): object is Partial<IPinnableItem> => {
  return object.__typename === "PinnableItem";
};

interface PinnableItemSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Gist" | "Repository">(
    type: F,
    select: (
      t: F extends "Gist"
        ? GistSelector
        : F extends "Repository"
        ? RepositorySelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Gist" ? IGist : F extends "Repository" ? IRepository : never
    >,
    SelectionSet<T>
  >;
}

export const PinnableItem: PinnableItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Gist": {
        return new InlineFragment(
          new NamedType("Gist") as any,
          new SelectionSet(select(Gist as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "PinnableItem",
        });
    }
  },
};

type IProjectCardItem = IIssue | IPullRequest;

export const isProjectCardItem = (
  object: Record<string, any>
): object is Partial<IProjectCardItem> => {
  return object.__typename === "ProjectCardItem";
};

interface ProjectCardItemSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Issue"
        ? IIssue
        : F extends "PullRequest"
        ? IPullRequest
        : never
    >,
    SelectionSet<T>
  >;
}

export const ProjectCardItem: ProjectCardItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "ProjectCardItem",
        });
    }
  },
};

type IPullRequestTimelineItem =
  | IAssignedEvent
  | IBaseRefDeletedEvent
  | IBaseRefForcePushedEvent
  | IClosedEvent
  | ICommit
  | ICommitCommentThread
  | ICrossReferencedEvent
  | IDemilestonedEvent
  | IDeployedEvent
  | IDeploymentEnvironmentChangedEvent
  | IHeadRefDeletedEvent
  | IHeadRefForcePushedEvent
  | IHeadRefRestoredEvent
  | IIssueComment
  | ILabeledEvent
  | ILockedEvent
  | IMergedEvent
  | IMilestonedEvent
  | IPullRequestReview
  | IPullRequestReviewComment
  | IPullRequestReviewThread
  | IReferencedEvent
  | IRenamedTitleEvent
  | IReopenedEvent
  | IReviewDismissedEvent
  | IReviewRequestRemovedEvent
  | IReviewRequestedEvent
  | ISubscribedEvent
  | IUnassignedEvent
  | IUnlabeledEvent
  | IUnlockedEvent
  | IUnsubscribedEvent
  | IUserBlockedEvent;

export const isPullRequestTimelineItem = (
  object: Record<string, any>
): object is Partial<IPullRequestTimelineItem> => {
  return object.__typename === "PullRequestTimelineItem";
};

interface PullRequestTimelineItemSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "AssignedEvent"
      | "BaseRefDeletedEvent"
      | "BaseRefForcePushedEvent"
      | "ClosedEvent"
      | "Commit"
      | "CommitCommentThread"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "DeployedEvent"
      | "DeploymentEnvironmentChangedEvent"
      | "HeadRefDeletedEvent"
      | "HeadRefForcePushedEvent"
      | "HeadRefRestoredEvent"
      | "IssueComment"
      | "LabeledEvent"
      | "LockedEvent"
      | "MergedEvent"
      | "MilestonedEvent"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "PullRequestReviewThread"
      | "ReferencedEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "ReviewDismissedEvent"
      | "ReviewRequestRemovedEvent"
      | "ReviewRequestedEvent"
      | "SubscribedEvent"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnsubscribedEvent"
      | "UserBlockedEvent"
  >(
    type: F,
    select: (
      t: F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "BaseRefDeletedEvent"
        ? BaseRefDeletedEventSelector
        : F extends "BaseRefForcePushedEvent"
        ? BaseRefForcePushedEventSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "CommitCommentThread"
        ? CommitCommentThreadSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "DeployedEvent"
        ? DeployedEventSelector
        : F extends "DeploymentEnvironmentChangedEvent"
        ? DeploymentEnvironmentChangedEventSelector
        : F extends "HeadRefDeletedEvent"
        ? HeadRefDeletedEventSelector
        : F extends "HeadRefForcePushedEvent"
        ? HeadRefForcePushedEventSelector
        : F extends "HeadRefRestoredEvent"
        ? HeadRefRestoredEventSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "MergedEvent"
        ? MergedEventSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "PullRequestReviewThread"
        ? PullRequestReviewThreadSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "ReviewDismissedEvent"
        ? ReviewDismissedEventSelector
        : F extends "ReviewRequestRemovedEvent"
        ? ReviewRequestRemovedEventSelector
        : F extends "ReviewRequestedEvent"
        ? ReviewRequestedEventSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "AssignedEvent"
        ? IAssignedEvent
        : F extends "BaseRefDeletedEvent"
        ? IBaseRefDeletedEvent
        : F extends "BaseRefForcePushedEvent"
        ? IBaseRefForcePushedEvent
        : F extends "ClosedEvent"
        ? IClosedEvent
        : F extends "Commit"
        ? ICommit
        : F extends "CommitCommentThread"
        ? ICommitCommentThread
        : F extends "CrossReferencedEvent"
        ? ICrossReferencedEvent
        : F extends "DemilestonedEvent"
        ? IDemilestonedEvent
        : F extends "DeployedEvent"
        ? IDeployedEvent
        : F extends "DeploymentEnvironmentChangedEvent"
        ? IDeploymentEnvironmentChangedEvent
        : F extends "HeadRefDeletedEvent"
        ? IHeadRefDeletedEvent
        : F extends "HeadRefForcePushedEvent"
        ? IHeadRefForcePushedEvent
        : F extends "HeadRefRestoredEvent"
        ? IHeadRefRestoredEvent
        : F extends "IssueComment"
        ? IIssueComment
        : F extends "LabeledEvent"
        ? ILabeledEvent
        : F extends "LockedEvent"
        ? ILockedEvent
        : F extends "MergedEvent"
        ? IMergedEvent
        : F extends "MilestonedEvent"
        ? IMilestonedEvent
        : F extends "PullRequestReview"
        ? IPullRequestReview
        : F extends "PullRequestReviewComment"
        ? IPullRequestReviewComment
        : F extends "PullRequestReviewThread"
        ? IPullRequestReviewThread
        : F extends "ReferencedEvent"
        ? IReferencedEvent
        : F extends "RenamedTitleEvent"
        ? IRenamedTitleEvent
        : F extends "ReopenedEvent"
        ? IReopenedEvent
        : F extends "ReviewDismissedEvent"
        ? IReviewDismissedEvent
        : F extends "ReviewRequestRemovedEvent"
        ? IReviewRequestRemovedEvent
        : F extends "ReviewRequestedEvent"
        ? IReviewRequestedEvent
        : F extends "SubscribedEvent"
        ? ISubscribedEvent
        : F extends "UnassignedEvent"
        ? IUnassignedEvent
        : F extends "UnlabeledEvent"
        ? IUnlabeledEvent
        : F extends "UnlockedEvent"
        ? IUnlockedEvent
        : F extends "UnsubscribedEvent"
        ? IUnsubscribedEvent
        : F extends "UserBlockedEvent"
        ? IUserBlockedEvent
        : never
    >,
    SelectionSet<T>
  >;
}

export const PullRequestTimelineItem: PullRequestTimelineItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "BaseRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefDeletedEvent") as any,
          new SelectionSet(select(BaseRefDeletedEvent as any))
        );
      }

      case "BaseRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefForcePushedEvent") as any,
          new SelectionSet(select(BaseRefForcePushedEvent as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "CommitCommentThread": {
        return new InlineFragment(
          new NamedType("CommitCommentThread") as any,
          new SelectionSet(select(CommitCommentThread as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "DeployedEvent": {
        return new InlineFragment(
          new NamedType("DeployedEvent") as any,
          new SelectionSet(select(DeployedEvent as any))
        );
      }

      case "DeploymentEnvironmentChangedEvent": {
        return new InlineFragment(
          new NamedType("DeploymentEnvironmentChangedEvent") as any,
          new SelectionSet(select(DeploymentEnvironmentChangedEvent as any))
        );
      }

      case "HeadRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefDeletedEvent") as any,
          new SelectionSet(select(HeadRefDeletedEvent as any))
        );
      }

      case "HeadRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefForcePushedEvent") as any,
          new SelectionSet(select(HeadRefForcePushedEvent as any))
        );
      }

      case "HeadRefRestoredEvent": {
        return new InlineFragment(
          new NamedType("HeadRefRestoredEvent") as any,
          new SelectionSet(select(HeadRefRestoredEvent as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "MergedEvent": {
        return new InlineFragment(
          new NamedType("MergedEvent") as any,
          new SelectionSet(select(MergedEvent as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "PullRequestReviewThread": {
        return new InlineFragment(
          new NamedType("PullRequestReviewThread") as any,
          new SelectionSet(select(PullRequestReviewThread as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "ReviewDismissedEvent": {
        return new InlineFragment(
          new NamedType("ReviewDismissedEvent") as any,
          new SelectionSet(select(ReviewDismissedEvent as any))
        );
      }

      case "ReviewRequestRemovedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestRemovedEvent") as any,
          new SelectionSet(select(ReviewRequestRemovedEvent as any))
        );
      }

      case "ReviewRequestedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestedEvent") as any,
          new SelectionSet(select(ReviewRequestedEvent as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "PullRequestTimelineItem",
        });
    }
  },
};

type IPullRequestTimelineItems =
  | IAddedToProjectEvent
  | IAssignedEvent
  | IAutomaticBaseChangeFailedEvent
  | IAutomaticBaseChangeSucceededEvent
  | IBaseRefChangedEvent
  | IBaseRefDeletedEvent
  | IBaseRefForcePushedEvent
  | IClosedEvent
  | ICommentDeletedEvent
  | IConnectedEvent
  | IConvertToDraftEvent
  | IConvertedNoteToIssueEvent
  | ICrossReferencedEvent
  | IDemilestonedEvent
  | IDeployedEvent
  | IDeploymentEnvironmentChangedEvent
  | IDisconnectedEvent
  | IHeadRefDeletedEvent
  | IHeadRefForcePushedEvent
  | IHeadRefRestoredEvent
  | IIssueComment
  | ILabeledEvent
  | ILockedEvent
  | IMarkedAsDuplicateEvent
  | IMentionedEvent
  | IMergedEvent
  | IMilestonedEvent
  | IMovedColumnsInProjectEvent
  | IPinnedEvent
  | IPullRequestCommit
  | IPullRequestCommitCommentThread
  | IPullRequestReview
  | IPullRequestReviewThread
  | IPullRequestRevisionMarker
  | IReadyForReviewEvent
  | IReferencedEvent
  | IRemovedFromProjectEvent
  | IRenamedTitleEvent
  | IReopenedEvent
  | IReviewDismissedEvent
  | IReviewRequestRemovedEvent
  | IReviewRequestedEvent
  | ISubscribedEvent
  | ITransferredEvent
  | IUnassignedEvent
  | IUnlabeledEvent
  | IUnlockedEvent
  | IUnmarkedAsDuplicateEvent
  | IUnpinnedEvent
  | IUnsubscribedEvent
  | IUserBlockedEvent;

export const isPullRequestTimelineItems = (
  object: Record<string, any>
): object is Partial<IPullRequestTimelineItems> => {
  return object.__typename === "PullRequestTimelineItems";
};

interface PullRequestTimelineItemsSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "AddedToProjectEvent"
      | "AssignedEvent"
      | "AutomaticBaseChangeFailedEvent"
      | "AutomaticBaseChangeSucceededEvent"
      | "BaseRefChangedEvent"
      | "BaseRefDeletedEvent"
      | "BaseRefForcePushedEvent"
      | "ClosedEvent"
      | "CommentDeletedEvent"
      | "ConnectedEvent"
      | "ConvertToDraftEvent"
      | "ConvertedNoteToIssueEvent"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "DeployedEvent"
      | "DeploymentEnvironmentChangedEvent"
      | "DisconnectedEvent"
      | "HeadRefDeletedEvent"
      | "HeadRefForcePushedEvent"
      | "HeadRefRestoredEvent"
      | "IssueComment"
      | "LabeledEvent"
      | "LockedEvent"
      | "MarkedAsDuplicateEvent"
      | "MentionedEvent"
      | "MergedEvent"
      | "MilestonedEvent"
      | "MovedColumnsInProjectEvent"
      | "PinnedEvent"
      | "PullRequestCommit"
      | "PullRequestCommitCommentThread"
      | "PullRequestReview"
      | "PullRequestReviewThread"
      | "PullRequestRevisionMarker"
      | "ReadyForReviewEvent"
      | "ReferencedEvent"
      | "RemovedFromProjectEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "ReviewDismissedEvent"
      | "ReviewRequestRemovedEvent"
      | "ReviewRequestedEvent"
      | "SubscribedEvent"
      | "TransferredEvent"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnmarkedAsDuplicateEvent"
      | "UnpinnedEvent"
      | "UnsubscribedEvent"
      | "UserBlockedEvent"
  >(
    type: F,
    select: (
      t: F extends "AddedToProjectEvent"
        ? AddedToProjectEventSelector
        : F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "AutomaticBaseChangeFailedEvent"
        ? AutomaticBaseChangeFailedEventSelector
        : F extends "AutomaticBaseChangeSucceededEvent"
        ? AutomaticBaseChangeSucceededEventSelector
        : F extends "BaseRefChangedEvent"
        ? BaseRefChangedEventSelector
        : F extends "BaseRefDeletedEvent"
        ? BaseRefDeletedEventSelector
        : F extends "BaseRefForcePushedEvent"
        ? BaseRefForcePushedEventSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "CommentDeletedEvent"
        ? CommentDeletedEventSelector
        : F extends "ConnectedEvent"
        ? ConnectedEventSelector
        : F extends "ConvertToDraftEvent"
        ? ConvertToDraftEventSelector
        : F extends "ConvertedNoteToIssueEvent"
        ? ConvertedNoteToIssueEventSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "DeployedEvent"
        ? DeployedEventSelector
        : F extends "DeploymentEnvironmentChangedEvent"
        ? DeploymentEnvironmentChangedEventSelector
        : F extends "DisconnectedEvent"
        ? DisconnectedEventSelector
        : F extends "HeadRefDeletedEvent"
        ? HeadRefDeletedEventSelector
        : F extends "HeadRefForcePushedEvent"
        ? HeadRefForcePushedEventSelector
        : F extends "HeadRefRestoredEvent"
        ? HeadRefRestoredEventSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "MarkedAsDuplicateEvent"
        ? MarkedAsDuplicateEventSelector
        : F extends "MentionedEvent"
        ? MentionedEventSelector
        : F extends "MergedEvent"
        ? MergedEventSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "MovedColumnsInProjectEvent"
        ? MovedColumnsInProjectEventSelector
        : F extends "PinnedEvent"
        ? PinnedEventSelector
        : F extends "PullRequestCommit"
        ? PullRequestCommitSelector
        : F extends "PullRequestCommitCommentThread"
        ? PullRequestCommitCommentThreadSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewThread"
        ? PullRequestReviewThreadSelector
        : F extends "PullRequestRevisionMarker"
        ? PullRequestRevisionMarkerSelector
        : F extends "ReadyForReviewEvent"
        ? ReadyForReviewEventSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "RemovedFromProjectEvent"
        ? RemovedFromProjectEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "ReviewDismissedEvent"
        ? ReviewDismissedEventSelector
        : F extends "ReviewRequestRemovedEvent"
        ? ReviewRequestRemovedEventSelector
        : F extends "ReviewRequestedEvent"
        ? ReviewRequestedEventSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "TransferredEvent"
        ? TransferredEventSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnmarkedAsDuplicateEvent"
        ? UnmarkedAsDuplicateEventSelector
        : F extends "UnpinnedEvent"
        ? UnpinnedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "AddedToProjectEvent"
        ? IAddedToProjectEvent
        : F extends "AssignedEvent"
        ? IAssignedEvent
        : F extends "AutomaticBaseChangeFailedEvent"
        ? IAutomaticBaseChangeFailedEvent
        : F extends "AutomaticBaseChangeSucceededEvent"
        ? IAutomaticBaseChangeSucceededEvent
        : F extends "BaseRefChangedEvent"
        ? IBaseRefChangedEvent
        : F extends "BaseRefDeletedEvent"
        ? IBaseRefDeletedEvent
        : F extends "BaseRefForcePushedEvent"
        ? IBaseRefForcePushedEvent
        : F extends "ClosedEvent"
        ? IClosedEvent
        : F extends "CommentDeletedEvent"
        ? ICommentDeletedEvent
        : F extends "ConnectedEvent"
        ? IConnectedEvent
        : F extends "ConvertToDraftEvent"
        ? IConvertToDraftEvent
        : F extends "ConvertedNoteToIssueEvent"
        ? IConvertedNoteToIssueEvent
        : F extends "CrossReferencedEvent"
        ? ICrossReferencedEvent
        : F extends "DemilestonedEvent"
        ? IDemilestonedEvent
        : F extends "DeployedEvent"
        ? IDeployedEvent
        : F extends "DeploymentEnvironmentChangedEvent"
        ? IDeploymentEnvironmentChangedEvent
        : F extends "DisconnectedEvent"
        ? IDisconnectedEvent
        : F extends "HeadRefDeletedEvent"
        ? IHeadRefDeletedEvent
        : F extends "HeadRefForcePushedEvent"
        ? IHeadRefForcePushedEvent
        : F extends "HeadRefRestoredEvent"
        ? IHeadRefRestoredEvent
        : F extends "IssueComment"
        ? IIssueComment
        : F extends "LabeledEvent"
        ? ILabeledEvent
        : F extends "LockedEvent"
        ? ILockedEvent
        : F extends "MarkedAsDuplicateEvent"
        ? IMarkedAsDuplicateEvent
        : F extends "MentionedEvent"
        ? IMentionedEvent
        : F extends "MergedEvent"
        ? IMergedEvent
        : F extends "MilestonedEvent"
        ? IMilestonedEvent
        : F extends "MovedColumnsInProjectEvent"
        ? IMovedColumnsInProjectEvent
        : F extends "PinnedEvent"
        ? IPinnedEvent
        : F extends "PullRequestCommit"
        ? IPullRequestCommit
        : F extends "PullRequestCommitCommentThread"
        ? IPullRequestCommitCommentThread
        : F extends "PullRequestReview"
        ? IPullRequestReview
        : F extends "PullRequestReviewThread"
        ? IPullRequestReviewThread
        : F extends "PullRequestRevisionMarker"
        ? IPullRequestRevisionMarker
        : F extends "ReadyForReviewEvent"
        ? IReadyForReviewEvent
        : F extends "ReferencedEvent"
        ? IReferencedEvent
        : F extends "RemovedFromProjectEvent"
        ? IRemovedFromProjectEvent
        : F extends "RenamedTitleEvent"
        ? IRenamedTitleEvent
        : F extends "ReopenedEvent"
        ? IReopenedEvent
        : F extends "ReviewDismissedEvent"
        ? IReviewDismissedEvent
        : F extends "ReviewRequestRemovedEvent"
        ? IReviewRequestRemovedEvent
        : F extends "ReviewRequestedEvent"
        ? IReviewRequestedEvent
        : F extends "SubscribedEvent"
        ? ISubscribedEvent
        : F extends "TransferredEvent"
        ? ITransferredEvent
        : F extends "UnassignedEvent"
        ? IUnassignedEvent
        : F extends "UnlabeledEvent"
        ? IUnlabeledEvent
        : F extends "UnlockedEvent"
        ? IUnlockedEvent
        : F extends "UnmarkedAsDuplicateEvent"
        ? IUnmarkedAsDuplicateEvent
        : F extends "UnpinnedEvent"
        ? IUnpinnedEvent
        : F extends "UnsubscribedEvent"
        ? IUnsubscribedEvent
        : F extends "UserBlockedEvent"
        ? IUserBlockedEvent
        : never
    >,
    SelectionSet<T>
  >;
}

export const PullRequestTimelineItems: PullRequestTimelineItemsSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "AddedToProjectEvent": {
        return new InlineFragment(
          new NamedType("AddedToProjectEvent") as any,
          new SelectionSet(select(AddedToProjectEvent as any))
        );
      }

      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "AutomaticBaseChangeFailedEvent": {
        return new InlineFragment(
          new NamedType("AutomaticBaseChangeFailedEvent") as any,
          new SelectionSet(select(AutomaticBaseChangeFailedEvent as any))
        );
      }

      case "AutomaticBaseChangeSucceededEvent": {
        return new InlineFragment(
          new NamedType("AutomaticBaseChangeSucceededEvent") as any,
          new SelectionSet(select(AutomaticBaseChangeSucceededEvent as any))
        );
      }

      case "BaseRefChangedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefChangedEvent") as any,
          new SelectionSet(select(BaseRefChangedEvent as any))
        );
      }

      case "BaseRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefDeletedEvent") as any,
          new SelectionSet(select(BaseRefDeletedEvent as any))
        );
      }

      case "BaseRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefForcePushedEvent") as any,
          new SelectionSet(select(BaseRefForcePushedEvent as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "CommentDeletedEvent": {
        return new InlineFragment(
          new NamedType("CommentDeletedEvent") as any,
          new SelectionSet(select(CommentDeletedEvent as any))
        );
      }

      case "ConnectedEvent": {
        return new InlineFragment(
          new NamedType("ConnectedEvent") as any,
          new SelectionSet(select(ConnectedEvent as any))
        );
      }

      case "ConvertToDraftEvent": {
        return new InlineFragment(
          new NamedType("ConvertToDraftEvent") as any,
          new SelectionSet(select(ConvertToDraftEvent as any))
        );
      }

      case "ConvertedNoteToIssueEvent": {
        return new InlineFragment(
          new NamedType("ConvertedNoteToIssueEvent") as any,
          new SelectionSet(select(ConvertedNoteToIssueEvent as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "DeployedEvent": {
        return new InlineFragment(
          new NamedType("DeployedEvent") as any,
          new SelectionSet(select(DeployedEvent as any))
        );
      }

      case "DeploymentEnvironmentChangedEvent": {
        return new InlineFragment(
          new NamedType("DeploymentEnvironmentChangedEvent") as any,
          new SelectionSet(select(DeploymentEnvironmentChangedEvent as any))
        );
      }

      case "DisconnectedEvent": {
        return new InlineFragment(
          new NamedType("DisconnectedEvent") as any,
          new SelectionSet(select(DisconnectedEvent as any))
        );
      }

      case "HeadRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefDeletedEvent") as any,
          new SelectionSet(select(HeadRefDeletedEvent as any))
        );
      }

      case "HeadRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefForcePushedEvent") as any,
          new SelectionSet(select(HeadRefForcePushedEvent as any))
        );
      }

      case "HeadRefRestoredEvent": {
        return new InlineFragment(
          new NamedType("HeadRefRestoredEvent") as any,
          new SelectionSet(select(HeadRefRestoredEvent as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "MarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("MarkedAsDuplicateEvent") as any,
          new SelectionSet(select(MarkedAsDuplicateEvent as any))
        );
      }

      case "MentionedEvent": {
        return new InlineFragment(
          new NamedType("MentionedEvent") as any,
          new SelectionSet(select(MentionedEvent as any))
        );
      }

      case "MergedEvent": {
        return new InlineFragment(
          new NamedType("MergedEvent") as any,
          new SelectionSet(select(MergedEvent as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "MovedColumnsInProjectEvent": {
        return new InlineFragment(
          new NamedType("MovedColumnsInProjectEvent") as any,
          new SelectionSet(select(MovedColumnsInProjectEvent as any))
        );
      }

      case "PinnedEvent": {
        return new InlineFragment(
          new NamedType("PinnedEvent") as any,
          new SelectionSet(select(PinnedEvent as any))
        );
      }

      case "PullRequestCommit": {
        return new InlineFragment(
          new NamedType("PullRequestCommit") as any,
          new SelectionSet(select(PullRequestCommit as any))
        );
      }

      case "PullRequestCommitCommentThread": {
        return new InlineFragment(
          new NamedType("PullRequestCommitCommentThread") as any,
          new SelectionSet(select(PullRequestCommitCommentThread as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewThread": {
        return new InlineFragment(
          new NamedType("PullRequestReviewThread") as any,
          new SelectionSet(select(PullRequestReviewThread as any))
        );
      }

      case "PullRequestRevisionMarker": {
        return new InlineFragment(
          new NamedType("PullRequestRevisionMarker") as any,
          new SelectionSet(select(PullRequestRevisionMarker as any))
        );
      }

      case "ReadyForReviewEvent": {
        return new InlineFragment(
          new NamedType("ReadyForReviewEvent") as any,
          new SelectionSet(select(ReadyForReviewEvent as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "RemovedFromProjectEvent": {
        return new InlineFragment(
          new NamedType("RemovedFromProjectEvent") as any,
          new SelectionSet(select(RemovedFromProjectEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "ReviewDismissedEvent": {
        return new InlineFragment(
          new NamedType("ReviewDismissedEvent") as any,
          new SelectionSet(select(ReviewDismissedEvent as any))
        );
      }

      case "ReviewRequestRemovedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestRemovedEvent") as any,
          new SelectionSet(select(ReviewRequestRemovedEvent as any))
        );
      }

      case "ReviewRequestedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestedEvent") as any,
          new SelectionSet(select(ReviewRequestedEvent as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "TransferredEvent": {
        return new InlineFragment(
          new NamedType("TransferredEvent") as any,
          new SelectionSet(select(TransferredEvent as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnmarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("UnmarkedAsDuplicateEvent") as any,
          new SelectionSet(select(UnmarkedAsDuplicateEvent as any))
        );
      }

      case "UnpinnedEvent": {
        return new InlineFragment(
          new NamedType("UnpinnedEvent") as any,
          new SelectionSet(select(UnpinnedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "PullRequestTimelineItems",
        });
    }
  },
};

type IPushAllowanceActor = IApp | ITeam | IUser;

export const isPushAllowanceActor = (
  object: Record<string, any>
): object is Partial<IPushAllowanceActor> => {
  return object.__typename === "PushAllowanceActor";
};

interface PushAllowanceActorSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "App" | "Team" | "User">(
    type: F,
    select: (
      t: F extends "App"
        ? AppSelector
        : F extends "Team"
        ? TeamSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "App"
        ? IApp
        : F extends "Team"
        ? ITeam
        : F extends "User"
        ? IUser
        : never
    >,
    SelectionSet<T>
  >;
}

export const PushAllowanceActor: PushAllowanceActorSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "App": {
        return new InlineFragment(
          new NamedType("App") as any,
          new SelectionSet(select(App as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "PushAllowanceActor",
        });
    }
  },
};

type IReferencedSubject = IIssue | IPullRequest;

export const isReferencedSubject = (
  object: Record<string, any>
): object is Partial<IReferencedSubject> => {
  return object.__typename === "ReferencedSubject";
};

interface ReferencedSubjectSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Issue"
        ? IIssue
        : F extends "PullRequest"
        ? IPullRequest
        : never
    >,
    SelectionSet<T>
  >;
}

export const ReferencedSubject: ReferencedSubjectSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "ReferencedSubject",
        });
    }
  },
};

type IRenamedTitleSubject = IIssue | IPullRequest;

export const isRenamedTitleSubject = (
  object: Record<string, any>
): object is Partial<IRenamedTitleSubject> => {
  return object.__typename === "RenamedTitleSubject";
};

interface RenamedTitleSubjectSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Issue"
        ? IIssue
        : F extends "PullRequest"
        ? IPullRequest
        : never
    >,
    SelectionSet<T>
  >;
}

export const RenamedTitleSubject: RenamedTitleSubjectSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "RenamedTitleSubject",
        });
    }
  },
};

type IRequestedReviewer = IMannequin | ITeam | IUser;

export const isRequestedReviewer = (
  object: Record<string, any>
): object is Partial<IRequestedReviewer> => {
  return object.__typename === "RequestedReviewer";
};

interface RequestedReviewerSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "Mannequin" | "Team" | "User"
  >(
    type: F,
    select: (
      t: F extends "Mannequin"
        ? MannequinSelector
        : F extends "Team"
        ? TeamSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Mannequin"
        ? IMannequin
        : F extends "Team"
        ? ITeam
        : F extends "User"
        ? IUser
        : never
    >,
    SelectionSet<T>
  >;
}

export const RequestedReviewer: RequestedReviewerSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "RequestedReviewer",
        });
    }
  },
};

type IReviewDismissalAllowanceActor = ITeam | IUser;

export const isReviewDismissalAllowanceActor = (
  object: Record<string, any>
): object is Partial<IReviewDismissalAllowanceActor> => {
  return object.__typename === "ReviewDismissalAllowanceActor";
};

interface ReviewDismissalAllowanceActorSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Team" | "User">(
    type: F,
    select: (
      t: F extends "Team"
        ? TeamSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<F, F extends "Team" ? ITeam : F extends "User" ? IUser : never>,
    SelectionSet<T>
  >;
}

export const ReviewDismissalAllowanceActor: ReviewDismissalAllowanceActorSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "ReviewDismissalAllowanceActor",
        });
    }
  },
};

type ISearchResultItem =
  | IApp
  | IIssue
  | IMarketplaceListing
  | IOrganization
  | IPullRequest
  | IRepository
  | IUser;

export const isSearchResultItem = (
  object: Record<string, any>
): object is Partial<ISearchResultItem> => {
  return object.__typename === "SearchResultItem";
};

interface SearchResultItemSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "App"
      | "Issue"
      | "MarketplaceListing"
      | "Organization"
      | "PullRequest"
      | "Repository"
      | "User"
  >(
    type: F,
    select: (
      t: F extends "App"
        ? AppSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "MarketplaceListing"
        ? MarketplaceListingSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "App"
        ? IApp
        : F extends "Issue"
        ? IIssue
        : F extends "MarketplaceListing"
        ? IMarketplaceListing
        : F extends "Organization"
        ? IOrganization
        : F extends "PullRequest"
        ? IPullRequest
        : F extends "Repository"
        ? IRepository
        : F extends "User"
        ? IUser
        : never
    >,
    SelectionSet<T>
  >;
}

export const SearchResultItem: SearchResultItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "App": {
        return new InlineFragment(
          new NamedType("App") as any,
          new SelectionSet(select(App as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "MarketplaceListing": {
        return new InlineFragment(
          new NamedType("MarketplaceListing") as any,
          new SelectionSet(select(MarketplaceListing as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "SearchResultItem",
        });
    }
  },
};

type ISponsor = IOrganization | IUser;

export const isSponsor = (
  object: Record<string, any>
): object is Partial<ISponsor> => {
  return object.__typename === "Sponsor";
};

interface SponsorSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <T extends Array<Selection>, F extends "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "Organization"
        ? IOrganization
        : F extends "User"
        ? IUser
        : never
    >,
    SelectionSet<T>
  >;
}

export const Sponsor: SponsorSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Sponsor",
        });
    }
  },
};

type IStatusCheckRollupContext = ICheckRun | IStatusContext;

export const isStatusCheckRollupContext = (
  object: Record<string, any>
): object is Partial<IStatusCheckRollupContext> => {
  return object.__typename === "StatusCheckRollupContext";
};

interface StatusCheckRollupContextSelector {
  readonly __typename: () => Field<"__typename">;

  readonly on: <
    T extends Array<Selection>,
    F extends "CheckRun" | "StatusContext"
  >(
    type: F,
    select: (
      t: F extends "CheckRun"
        ? CheckRunSelector
        : F extends "StatusContext"
        ? StatusContextSelector
        : never
    ) => T
  ) => InlineFragment<
    NamedType<
      F,
      F extends "CheckRun"
        ? ICheckRun
        : F extends "StatusContext"
        ? IStatusContext
        : never
    >,
    SelectionSet<T>
  >;
}

export const StatusCheckRollupContext: StatusCheckRollupContextSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "CheckRun": {
        return new InlineFragment(
          new NamedType("CheckRun") as any,
          new SelectionSet(select(CheckRun as any))
        );
      }

      case "StatusContext": {
        return new InlineFragment(
          new NamedType("StatusContext") as any,
          new SelectionSet(select(StatusContext as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "StatusCheckRollupContext",
        });
    }
  },
};

export interface IAcceptEnterpriseAdministratorInvitationPayload {
  readonly __typename: "AcceptEnterpriseAdministratorInvitationPayload";
  readonly clientMutationId: string | null;
  readonly invitation: IEnterpriseAdministratorInvitation | null;
  readonly message: string | null;
}

interface AcceptEnterpriseAdministratorInvitationPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The invitation that was accepted.
   */

  readonly invitation: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"invitation", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of accepting an administrator invitation.
   */

  readonly message: () => Field<"message">;
}

export const AcceptEnterpriseAdministratorInvitationPayload: AcceptEnterpriseAdministratorInvitationPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The invitation that was accepted.
   */

  invitation: (select) =>
    new Field(
      "invitation",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description A message confirming the result of accepting an administrator invitation.
   */
  message: () => new Field("message"),
};

export interface IAcceptTopicSuggestionPayload {
  readonly __typename: "AcceptTopicSuggestionPayload";
  readonly clientMutationId: string | null;
  readonly topic: ITopic | null;
}

interface AcceptTopicSuggestionPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The accepted topic.
   */

  readonly topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;
}

export const AcceptTopicSuggestionPayload: AcceptTopicSuggestionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The accepted topic.
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),
};

export interface IActor {
  readonly __typename: string;
  readonly avatarUrl: unknown;
  readonly login: string;
  readonly resourcePath: unknown;
  readonly url: unknown;
}

interface ActorSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the actor's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description The username of the actor.
   */

  readonly login: () => Field<"login">;

  /**
   * @description The HTTP path for this actor.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this actor.
   */

  readonly url: () => Field<"url">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "Bot"
      | "EnterpriseUserAccount"
      | "Mannequin"
      | "Organization"
      | "User"
  >(
    type: F,
    select: (
      t: F extends "Bot"
        ? BotSelector
        : F extends "EnterpriseUserAccount"
        ? EnterpriseUserAccountSelector
        : F extends "Mannequin"
        ? MannequinSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Actor: ActorSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the actor's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description The username of the actor.
   */
  login: () => new Field("login"),

  /**
   * @description The HTTP path for this actor.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this actor.
   */
  url: () => new Field("url"),

  on: (type, select) => {
    switch (type) {
      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "EnterpriseUserAccount": {
        return new InlineFragment(
          new NamedType("EnterpriseUserAccount") as any,
          new SelectionSet(select(EnterpriseUserAccount as any))
        );
      }

      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Actor",
        });
    }
  },
};

export interface IActorLocation {
  readonly __typename: "ActorLocation";
  readonly city: string | null;
  readonly country: string | null;
  readonly countryCode: string | null;
  readonly region: string | null;
  readonly regionCode: string | null;
}

interface ActorLocationSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description City
   */

  readonly city: () => Field<"city">;

  /**
   * @description Country name
   */

  readonly country: () => Field<"country">;

  /**
   * @description Country code
   */

  readonly countryCode: () => Field<"countryCode">;

  /**
   * @description Region name
   */

  readonly region: () => Field<"region">;

  /**
   * @description Region or state code
   */

  readonly regionCode: () => Field<"regionCode">;
}

export const ActorLocation: ActorLocationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description City
   */
  city: () => new Field("city"),

  /**
   * @description Country name
   */
  country: () => new Field("country"),

  /**
   * @description Country code
   */
  countryCode: () => new Field("countryCode"),

  /**
   * @description Region name
   */
  region: () => new Field("region"),

  /**
   * @description Region or state code
   */
  regionCode: () => new Field("regionCode"),
};

export interface IAddAssigneesToAssignablePayload {
  readonly __typename: "AddAssigneesToAssignablePayload";
  readonly assignable: IAssignable | null;
  readonly clientMutationId: string | null;
}

interface AddAssigneesToAssignablePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The item that was assigned.
   */

  readonly assignable: <T extends Array<Selection>>(
    select: (t: AssignableSelector) => T
  ) => Field<"assignable", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const AddAssigneesToAssignablePayload: AddAssigneesToAssignablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The item that was assigned.
   */

  assignable: (select) =>
    new Field(
      "assignable",
      undefined as never,
      new SelectionSet(select(Assignable))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IAddCommentPayload {
  readonly __typename: "AddCommentPayload";
  readonly clientMutationId: string | null;
  readonly commentEdge: IIssueCommentEdge | null;
  readonly subject: INode | null;
  readonly timelineEdge: IIssueTimelineItemEdge | null;
}

interface AddCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The edge from the subject's comment connection.
   */

  readonly commentEdge: <T extends Array<Selection>>(
    select: (t: IssueCommentEdgeSelector) => T
  ) => Field<"commentEdge", never, SelectionSet<T>>;

  /**
   * @description The subject
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: NodeSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;

  /**
   * @description The edge from the subject's timeline connection.
   */

  readonly timelineEdge: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemEdgeSelector) => T
  ) => Field<"timelineEdge", never, SelectionSet<T>>;
}

export const AddCommentPayload: AddCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The edge from the subject's comment connection.
   */

  commentEdge: (select) =>
    new Field(
      "commentEdge",
      undefined as never,
      new SelectionSet(select(IssueCommentEdge))
    ),

  /**
   * @description The subject
   */

  subject: (select) =>
    new Field("subject", undefined as never, new SelectionSet(select(Node))),

  /**
   * @description The edge from the subject's timeline connection.
   */

  timelineEdge: (select) =>
    new Field(
      "timelineEdge",
      undefined as never,
      new SelectionSet(select(IssueTimelineItemEdge))
    ),
};

export interface IAddLabelsToLabelablePayload {
  readonly __typename: "AddLabelsToLabelablePayload";
  readonly clientMutationId: string | null;
  readonly labelable: ILabelable | null;
}

interface AddLabelsToLabelablePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The item that was labeled.
   */

  readonly labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const AddLabelsToLabelablePayload: AddLabelsToLabelablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The item that was labeled.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface IAddProjectCardPayload {
  readonly __typename: "AddProjectCardPayload";
  readonly cardEdge: IProjectCardEdge | null;
  readonly clientMutationId: string | null;
  readonly projectColumn: IProjectColumn | null;
}

interface AddProjectCardPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The edge from the ProjectColumn's card connection.
   */

  readonly cardEdge: <T extends Array<Selection>>(
    select: (t: ProjectCardEdgeSelector) => T
  ) => Field<"cardEdge", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The ProjectColumn
   */

  readonly projectColumn: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"projectColumn", never, SelectionSet<T>>;
}

export const AddProjectCardPayload: AddProjectCardPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The edge from the ProjectColumn's card connection.
   */

  cardEdge: (select) =>
    new Field(
      "cardEdge",
      undefined as never,
      new SelectionSet(select(ProjectCardEdge))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The ProjectColumn
   */

  projectColumn: (select) =>
    new Field(
      "projectColumn",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),
};

export interface IAddProjectColumnPayload {
  readonly __typename: "AddProjectColumnPayload";
  readonly clientMutationId: string | null;
  readonly columnEdge: IProjectColumnEdge | null;
  readonly project: IProject | null;
}

interface AddProjectColumnPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The edge from the project's column connection.
   */

  readonly columnEdge: <T extends Array<Selection>>(
    select: (t: ProjectColumnEdgeSelector) => T
  ) => Field<"columnEdge", never, SelectionSet<T>>;

  /**
   * @description The project
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const AddProjectColumnPayload: AddProjectColumnPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The edge from the project's column connection.
   */

  columnEdge: (select) =>
    new Field(
      "columnEdge",
      undefined as never,
      new SelectionSet(select(ProjectColumnEdge))
    ),

  /**
   * @description The project
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface IAddPullRequestReviewCommentPayload {
  readonly __typename: "AddPullRequestReviewCommentPayload";
  readonly clientMutationId: string | null;
  readonly comment: IPullRequestReviewComment | null;
  readonly commentEdge: IPullRequestReviewCommentEdge | null;
}

interface AddPullRequestReviewCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The newly created comment.
   */

  readonly comment: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"comment", never, SelectionSet<T>>;

  /**
   * @description The edge from the review's comment connection.
   */

  readonly commentEdge: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentEdgeSelector) => T
  ) => Field<"commentEdge", never, SelectionSet<T>>;
}

export const AddPullRequestReviewCommentPayload: AddPullRequestReviewCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The newly created comment.
   */

  comment: (select) =>
    new Field(
      "comment",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),

  /**
   * @description The edge from the review's comment connection.
   */

  commentEdge: (select) =>
    new Field(
      "commentEdge",
      undefined as never,
      new SelectionSet(select(PullRequestReviewCommentEdge))
    ),
};

export interface IAddPullRequestReviewPayload {
  readonly __typename: "AddPullRequestReviewPayload";
  readonly clientMutationId: string | null;
  readonly pullRequestReview: IPullRequestReview | null;
  readonly reviewEdge: IPullRequestReviewEdge | null;
}

interface AddPullRequestReviewPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The newly created pull request review.
   */

  readonly pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;

  /**
   * @description The edge from the pull request's review connection.
   */

  readonly reviewEdge: <T extends Array<Selection>>(
    select: (t: PullRequestReviewEdgeSelector) => T
  ) => Field<"reviewEdge", never, SelectionSet<T>>;
}

export const AddPullRequestReviewPayload: AddPullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The newly created pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description The edge from the pull request's review connection.
   */

  reviewEdge: (select) =>
    new Field(
      "reviewEdge",
      undefined as never,
      new SelectionSet(select(PullRequestReviewEdge))
    ),
};

export interface IAddPullRequestReviewThreadPayload {
  readonly __typename: "AddPullRequestReviewThreadPayload";
  readonly clientMutationId: string | null;
  readonly thread: IPullRequestReviewThread | null;
}

interface AddPullRequestReviewThreadPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The newly created thread.
   */

  readonly thread: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"thread", never, SelectionSet<T>>;
}

export const AddPullRequestReviewThreadPayload: AddPullRequestReviewThreadPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The newly created thread.
   */

  thread: (select) =>
    new Field(
      "thread",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),
};

export interface IAddReactionPayload {
  readonly __typename: "AddReactionPayload";
  readonly clientMutationId: string | null;
  readonly reaction: IReaction | null;
  readonly subject: IReactable | null;
}

interface AddReactionPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The reaction object.
   */

  readonly reaction: <T extends Array<Selection>>(
    select: (t: ReactionSelector) => T
  ) => Field<"reaction", never, SelectionSet<T>>;

  /**
   * @description The reactable subject.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: ReactableSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const AddReactionPayload: AddReactionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The reaction object.
   */

  reaction: (select) =>
    new Field(
      "reaction",
      undefined as never,
      new SelectionSet(select(Reaction))
    ),

  /**
   * @description The reactable subject.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(Reactable))
    ),
};

export interface IAddStarPayload {
  readonly __typename: "AddStarPayload";
  readonly clientMutationId: string | null;
  readonly starrable: IStarrable | null;
}

interface AddStarPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The starrable.
   */

  readonly starrable: <T extends Array<Selection>>(
    select: (t: StarrableSelector) => T
  ) => Field<"starrable", never, SelectionSet<T>>;
}

export const AddStarPayload: AddStarPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The starrable.
   */

  starrable: (select) =>
    new Field(
      "starrable",
      undefined as never,
      new SelectionSet(select(Starrable))
    ),
};

export interface IAddedToProjectEvent extends INode {
  readonly __typename: "AddedToProjectEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
}

interface AddedToProjectEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;
}

export const isAddedToProjectEvent = (
  object: Record<string, any>
): object is Partial<IAddedToProjectEvent> => {
  return object.__typename === "AddedToProjectEvent";
};

export const AddedToProjectEvent: AddedToProjectEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface IApp extends INode {
  readonly __typename: "App";
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly description: string | null;
  readonly logoBackgroundColor: string;
  readonly logoUrl: unknown;
  readonly name: string;
  readonly slug: string;
  readonly updatedAt: unknown;
  readonly url: unknown;
}

interface AppSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The description of the app.
   */

  readonly description: () => Field<"description">;

  readonly id: () => Field<"id">;

  /**
   * @description The hex color code, without the leading '#', for the logo background.
   */

  readonly logoBackgroundColor: () => Field<"logoBackgroundColor">;

  /**
   * @description A URL pointing to the app's logo.
   */

  readonly logoUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"logoUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description The name of the app.
   */

  readonly name: () => Field<"name">;

  /**
   * @description A slug based on the name of the app for use in URLs.
   */

  readonly slug: () => Field<"slug">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The URL to the app's homepage.
   */

  readonly url: () => Field<"url">;
}

export const isApp = (object: Record<string, any>): object is Partial<IApp> => {
  return object.__typename === "App";
};

export const App: AppSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The description of the app.
   */
  description: () => new Field("description"),
  id: () => new Field("id"),

  /**
   * @description The hex color code, without the leading '#', for the logo background.
   */
  logoBackgroundColor: () => new Field("logoBackgroundColor"),

  /**
   * @description A URL pointing to the app's logo.
   */
  logoUrl: (variables) => new Field("logoUrl"),

  /**
   * @description The name of the app.
   */
  name: () => new Field("name"),

  /**
   * @description A slug based on the name of the app for use in URLs.
   */
  slug: () => new Field("slug"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The URL to the app's homepage.
   */
  url: () => new Field("url"),
};

export interface IArchiveRepositoryPayload {
  readonly __typename: "ArchiveRepositoryPayload";
  readonly clientMutationId: string | null;
  readonly repository: IRepository | null;
}

interface ArchiveRepositoryPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository that was marked as archived.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const ArchiveRepositoryPayload: ArchiveRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository that was marked as archived.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IAssignable {
  readonly __typename: string;
  readonly assignees: IUserConnection;
}

interface AssignableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of Users assigned to this object.
   */

  readonly assignees: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "assignees",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  readonly on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Assignable: AssignableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: (variables, select) =>
    new Field(
      "assignees",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Assignable",
        });
    }
  },
};

export interface IAssignedEvent extends INode {
  readonly __typename: "AssignedEvent";
  readonly actor: IActor | null;
  readonly assignable: IAssignable;
  readonly assignee: IAssignee | null;
  readonly createdAt: unknown;
  readonly user: IUser | null;
}

interface AssignedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the assignable associated with the event.
   */

  readonly assignable: <T extends Array<Selection>>(
    select: (t: AssignableSelector) => T
  ) => Field<"assignable", never, SelectionSet<T>>;

  /**
   * @description Identifies the user or mannequin that was assigned.
   */

  readonly assignee: <T extends Array<Selection>>(
    select: (t: AssigneeSelector) => T
  ) => Field<"assignee", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isAssignedEvent = (
  object: Record<string, any>
): object is Partial<IAssignedEvent> => {
  return object.__typename === "AssignedEvent";
};

export const AssignedEvent: AssignedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the assignable associated with the event.
   */

  assignable: (select) =>
    new Field(
      "assignable",
      undefined as never,
      new SelectionSet(select(Assignable))
    ),

  /**
   * @description Identifies the user or mannequin that was assigned.
   */

  assignee: (select) =>
    new Field(
      "assignee",
      undefined as never,
      new SelectionSet(select(Assignee))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IAuditEntry {
  readonly __typename: string;
  readonly action: string;
  readonly actor: IAuditEntryActor | null;
  readonly actorIp: string | null;
  readonly actorLocation: IActorLocation | null;
  readonly actorLogin: string | null;
  readonly actorResourcePath: unknown | null;
  readonly actorUrl: unknown | null;
  readonly createdAt: unknown;
  readonly operationType: OperationType | null;
  readonly user: IUser | null;
  readonly userLogin: string | null;
  readonly userResourcePath: unknown | null;
  readonly userUrl: unknown | null;
}

interface AuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "OauthApplicationCreateAuditEntry"
      | "OrgAddBillingManagerAuditEntry"
      | "OrgAddMemberAuditEntry"
      | "OrgBlockUserAuditEntry"
      | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
      | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
      | "OrgCreateAuditEntry"
      | "OrgDisableOauthAppRestrictionsAuditEntry"
      | "OrgDisableSamlAuditEntry"
      | "OrgDisableTwoFactorRequirementAuditEntry"
      | "OrgEnableOauthAppRestrictionsAuditEntry"
      | "OrgEnableSamlAuditEntry"
      | "OrgEnableTwoFactorRequirementAuditEntry"
      | "OrgInviteMemberAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
      | "OrgRemoveBillingManagerAuditEntry"
      | "OrgRemoveMemberAuditEntry"
      | "OrgRemoveOutsideCollaboratorAuditEntry"
      | "OrgRestoreMemberAuditEntry"
      | "OrgUnblockUserAuditEntry"
      | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
      | "OrgUpdateMemberAuditEntry"
      | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
      | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgAddBillingManagerAuditEntry"
        ? OrgAddBillingManagerAuditEntrySelector
        : F extends "OrgAddMemberAuditEntry"
        ? OrgAddMemberAuditEntrySelector
        : F extends "OrgBlockUserAuditEntry"
        ? OrgBlockUserAuditEntrySelector
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? OrgConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? OrgConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgCreateAuditEntry"
        ? OrgCreateAuditEntrySelector
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? OrgDisableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgDisableSamlAuditEntry"
        ? OrgDisableSamlAuditEntrySelector
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? OrgDisableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? OrgEnableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgEnableSamlAuditEntry"
        ? OrgEnableSamlAuditEntrySelector
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? OrgEnableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgInviteMemberAuditEntry"
        ? OrgInviteMemberAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? OrgRemoveBillingManagerAuditEntrySelector
        : F extends "OrgRemoveMemberAuditEntry"
        ? OrgRemoveMemberAuditEntrySelector
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? OrgRemoveOutsideCollaboratorAuditEntrySelector
        : F extends "OrgRestoreMemberAuditEntry"
        ? OrgRestoreMemberAuditEntrySelector
        : F extends "OrgUnblockUserAuditEntry"
        ? OrgUnblockUserAuditEntrySelector
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? OrgUpdateDefaultRepositoryPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberAuditEntry"
        ? OrgUpdateMemberAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const AuditEntry: AuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  on: (type, select) => {
    switch (type) {
      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgAddBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgAddBillingManagerAuditEntry as any))
        );
      }

      case "OrgAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddMemberAuditEntry") as any,
          new SelectionSet(select(OrgAddMemberAuditEntry as any))
        );
      }

      case "OrgBlockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgBlockUserAuditEntry") as any,
          new SelectionSet(select(OrgBlockUserAuditEntry as any))
        );
      }

      case "OrgConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgCreateAuditEntry") as any,
          new SelectionSet(select(OrgCreateAuditEntry as any))
        );
      }

      case "OrgDisableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgDisableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableSamlAuditEntry") as any,
          new SelectionSet(select(OrgDisableSamlAuditEntry as any))
        );
      }

      case "OrgDisableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgEnableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgEnableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableSamlAuditEntry") as any,
          new SelectionSet(select(OrgEnableSamlAuditEntry as any))
        );
      }

      case "OrgEnableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgInviteMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteMemberAuditEntry") as any,
          new SelectionSet(select(OrgInviteMemberAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      case "OrgRemoveBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgRemoveBillingManagerAuditEntry as any))
        );
      }

      case "OrgRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveMemberAuditEntry") as any,
          new SelectionSet(select(OrgRemoveMemberAuditEntry as any))
        );
      }

      case "OrgRemoveOutsideCollaboratorAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveOutsideCollaboratorAuditEntry") as any,
          new SelectionSet(
            select(OrgRemoveOutsideCollaboratorAuditEntry as any)
          )
        );
      }

      case "OrgRestoreMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberAuditEntry") as any,
          new SelectionSet(select(OrgRestoreMemberAuditEntry as any))
        );
      }

      case "OrgUnblockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUnblockUserAuditEntry") as any,
          new SelectionSet(select(OrgUnblockUserAuditEntry as any))
        );
      }

      case "OrgUpdateDefaultRepositoryPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateDefaultRepositoryPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateDefaultRepositoryPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUpdateMemberAuditEntry") as any,
          new SelectionSet(select(OrgUpdateMemberAuditEntry as any))
        );
      }

      case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateMemberRepositoryCreationPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(
              OrgUpdateMemberRepositoryInvitationPermissionAuditEntry as any
            )
          )
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "AuditEntry",
        });
    }
  },
};

export interface IAutomaticBaseChangeFailedEvent extends INode {
  readonly __typename: "AutomaticBaseChangeFailedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly newBase: string;
  readonly oldBase: string;
  readonly pullRequest: IPullRequest;
}

interface AutomaticBaseChangeFailedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The new base for this PR
   */

  readonly newBase: () => Field<"newBase">;

  /**
   * @description The old base for this PR
   */

  readonly oldBase: () => Field<"oldBase">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isAutomaticBaseChangeFailedEvent = (
  object: Record<string, any>
): object is Partial<IAutomaticBaseChangeFailedEvent> => {
  return object.__typename === "AutomaticBaseChangeFailedEvent";
};

export const AutomaticBaseChangeFailedEvent: AutomaticBaseChangeFailedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The new base for this PR
   */
  newBase: () => new Field("newBase"),

  /**
   * @description The old base for this PR
   */
  oldBase: () => new Field("oldBase"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IAutomaticBaseChangeSucceededEvent extends INode {
  readonly __typename: "AutomaticBaseChangeSucceededEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly newBase: string;
  readonly oldBase: string;
  readonly pullRequest: IPullRequest;
}

interface AutomaticBaseChangeSucceededEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The new base for this PR
   */

  readonly newBase: () => Field<"newBase">;

  /**
   * @description The old base for this PR
   */

  readonly oldBase: () => Field<"oldBase">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isAutomaticBaseChangeSucceededEvent = (
  object: Record<string, any>
): object is Partial<IAutomaticBaseChangeSucceededEvent> => {
  return object.__typename === "AutomaticBaseChangeSucceededEvent";
};

export const AutomaticBaseChangeSucceededEvent: AutomaticBaseChangeSucceededEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The new base for this PR
   */
  newBase: () => new Field("newBase"),

  /**
   * @description The old base for this PR
   */
  oldBase: () => new Field("oldBase"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IBaseRefChangedEvent extends INode {
  readonly __typename: "BaseRefChangedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly currentRefName: string;
  readonly databaseId: number | null;
  readonly previousRefName: string;
  readonly pullRequest: IPullRequest;
}

interface BaseRefChangedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the name of the base ref for the pull request after it was changed.
   */

  readonly currentRefName: () => Field<"currentRefName">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the name of the base ref for the pull request before it was changed.
   */

  readonly previousRefName: () => Field<"previousRefName">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isBaseRefChangedEvent = (
  object: Record<string, any>
): object is Partial<IBaseRefChangedEvent> => {
  return object.__typename === "BaseRefChangedEvent";
};

export const BaseRefChangedEvent: BaseRefChangedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the name of the base ref for the pull request after it was changed.
   */
  currentRefName: () => new Field("currentRefName"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description Identifies the name of the base ref for the pull request before it was changed.
   */
  previousRefName: () => new Field("previousRefName"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IBaseRefDeletedEvent extends INode {
  readonly __typename: "BaseRefDeletedEvent";
  readonly actor: IActor | null;
  readonly baseRefName: string | null;
  readonly createdAt: unknown;
  readonly pullRequest: IPullRequest | null;
}

interface BaseRefDeletedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the Ref associated with the `base_ref_deleted` event.
   */

  readonly baseRefName: () => Field<"baseRefName">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isBaseRefDeletedEvent = (
  object: Record<string, any>
): object is Partial<IBaseRefDeletedEvent> => {
  return object.__typename === "BaseRefDeletedEvent";
};

export const BaseRefDeletedEvent: BaseRefDeletedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the name of the Ref associated with the `base_ref_deleted` event.
   */
  baseRefName: () => new Field("baseRefName"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IBaseRefForcePushedEvent extends INode {
  readonly __typename: "BaseRefForcePushedEvent";
  readonly actor: IActor | null;
  readonly afterCommit: ICommit | null;
  readonly beforeCommit: ICommit | null;
  readonly createdAt: unknown;
  readonly pullRequest: IPullRequest;
  readonly ref: IRef | null;
}

interface BaseRefForcePushedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the after commit SHA for the 'base_ref_force_pushed' event.
   */

  readonly afterCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"afterCommit", never, SelectionSet<T>>;

  /**
   * @description Identifies the before commit SHA for the 'base_ref_force_pushed' event.
   */

  readonly beforeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"beforeCommit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the fully qualified ref name for the 'base_ref_force_pushed' event.
   */

  readonly ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const isBaseRefForcePushedEvent = (
  object: Record<string, any>
): object is Partial<IBaseRefForcePushedEvent> => {
  return object.__typename === "BaseRefForcePushedEvent";
};

export const BaseRefForcePushedEvent: BaseRefForcePushedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the after commit SHA for the 'base_ref_force_pushed' event.
   */

  afterCommit: (select) =>
    new Field(
      "afterCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Identifies the before commit SHA for the 'base_ref_force_pushed' event.
   */

  beforeCommit: (select) =>
    new Field(
      "beforeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the fully qualified ref name for the 'base_ref_force_pushed' event.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IBlame {
  readonly __typename: "Blame";
  readonly ranges: ReadonlyArray<IBlameRange>;
}

interface BlameSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The list of ranges from a Git blame.
   */

  readonly ranges: <T extends Array<Selection>>(
    select: (t: BlameRangeSelector) => T
  ) => Field<"ranges", never, SelectionSet<T>>;
}

export const Blame: BlameSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The list of ranges from a Git blame.
   */

  ranges: (select) =>
    new Field(
      "ranges",
      undefined as never,
      new SelectionSet(select(BlameRange))
    ),
};

export interface IBlameRange {
  readonly __typename: "BlameRange";
  readonly age: number;
  readonly commit: ICommit;
  readonly endingLine: number;
  readonly startingLine: number;
}

interface BlameRangeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description Identifies the recency of the change, from 1 (new) to 10 (old). This is
calculated as a 2-quantile and determines the length of distance between the
median age of all the changes in the file and the recency of the current
range's change.
     */

  readonly age: () => Field<"age">;

  /**
   * @description Identifies the line author
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description The ending line for the range
   */

  readonly endingLine: () => Field<"endingLine">;

  /**
   * @description The starting line for the range
   */

  readonly startingLine: () => Field<"startingLine">;
}

export const BlameRange: BlameRangeSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Identifies the recency of the change, from 1 (new) to 10 (old). This is
calculated as a 2-quantile and determines the length of distance between the
median age of all the changes in the file and the recency of the current
range's change.
     */
  age: () => new Field("age"),

  /**
   * @description Identifies the line author
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description The ending line for the range
   */
  endingLine: () => new Field("endingLine"),

  /**
   * @description The starting line for the range
   */
  startingLine: () => new Field("startingLine"),
};

export interface IBlob extends IGitObject, INode {
  readonly __typename: "Blob";
  readonly byteSize: number;
  readonly isBinary: boolean | null;
  readonly isTruncated: boolean;
  readonly text: string | null;
}

interface BlobSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  readonly abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description Byte size of Blob object
   */

  readonly byteSize: () => Field<"byteSize">;

  /**
   * @description The HTTP path for this Git object
   */

  readonly commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  readonly commitUrl: () => Field<"commitUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding.
   */

  readonly isBinary: () => Field<"isBinary">;

  /**
   * @description Indicates whether the contents is truncated
   */

  readonly isTruncated: () => Field<"isTruncated">;

  /**
   * @description The Git object ID
   */

  readonly oid: () => Field<"oid">;

  /**
   * @description The Repository the Git object belongs to
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description UTF8 text data or null if the Blob is binary
   */

  readonly text: () => Field<"text">;
}

export const isBlob = (
  object: Record<string, any>
): object is Partial<IBlob> => {
  return object.__typename === "Blob";
};

export const Blob: BlobSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description Byte size of Blob object
   */
  byteSize: () => new Field("byteSize"),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),
  id: () => new Field("id"),

  /**
   * @description Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding.
   */
  isBinary: () => new Field("isBinary"),

  /**
   * @description Indicates whether the contents is truncated
   */
  isTruncated: () => new Field("isTruncated"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The Repository the Git object belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description UTF8 text data or null if the Blob is binary
   */
  text: () => new Field("text"),
};

export interface IBot extends IActor, INode, IUniformResourceLocatable {
  readonly __typename: "Bot";
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly updatedAt: unknown;
}

interface BotSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the GitHub App's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description The username of the actor.
   */

  readonly login: () => Field<"login">;

  /**
   * @description The HTTP path for this bot
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this bot
   */

  readonly url: () => Field<"url">;
}

export const isBot = (object: Record<string, any>): object is Partial<IBot> => {
  return object.__typename === "Bot";
};

export const Bot: BotSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the GitHub App's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The username of the actor.
   */
  login: () => new Field("login"),

  /**
   * @description The HTTP path for this bot
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this bot
   */
  url: () => new Field("url"),
};

export interface IBranchProtectionRule extends INode {
  readonly __typename: "BranchProtectionRule";
  readonly allowsDeletions: boolean;
  readonly allowsForcePushes: boolean;
  readonly branchProtectionRuleConflicts: IBranchProtectionRuleConflictConnection;
  readonly creator: IActor | null;
  readonly databaseId: number | null;
  readonly dismissesStaleReviews: boolean;
  readonly isAdminEnforced: boolean;
  readonly matchingRefs: IRefConnection;
  readonly pattern: string;
  readonly pushAllowances: IPushAllowanceConnection;
  readonly repository: IRepository | null;
  readonly requiredApprovingReviewCount: number | null;
  readonly requiredStatusCheckContexts: ReadonlyArray<string> | null;
  readonly requiresApprovingReviews: boolean;
  readonly requiresCodeOwnerReviews: boolean;
  readonly requiresCommitSignatures: boolean;
  readonly requiresLinearHistory: boolean;
  readonly requiresStatusChecks: boolean;
  readonly requiresStrictStatusChecks: boolean;
  readonly restrictsPushes: boolean;
  readonly restrictsReviewDismissals: boolean;
  readonly reviewDismissalAllowances: IReviewDismissalAllowanceConnection;
}

interface BranchProtectionRuleSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Can this branch be deleted.
   */

  readonly allowsDeletions: () => Field<"allowsDeletions">;

  /**
   * @description Are force pushes allowed on this branch.
   */

  readonly allowsForcePushes: () => Field<"allowsForcePushes">;

  /**
   * @description A list of conflicts matching branches protection rule and other branch protection rules
   */

  readonly branchProtectionRuleConflicts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: BranchProtectionRuleConflictConnectionSelector) => T
  ) => Field<
    "branchProtectionRuleConflicts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The actor who created this branch protection rule.
   */

  readonly creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description Will new commits pushed to matching branches dismiss pull request review approvals.
   */

  readonly dismissesStaleReviews: () => Field<"dismissesStaleReviews">;

  readonly id: () => Field<"id">;

  /**
   * @description Can admins overwrite branch protection.
   */

  readonly isAdminEnforced: () => Field<"isAdminEnforced">;

  /**
   * @description Repository refs that are protected by this rule
   */

  readonly matchingRefs: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: RefConnectionSelector) => T
  ) => Field<
    "matchingRefs",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the protection rule pattern.
   */

  readonly pattern: () => Field<"pattern">;

  /**
   * @description A list push allowances for this branch protection rule.
   */

  readonly pushAllowances: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PushAllowanceConnectionSelector) => T
  ) => Field<
    "pushAllowances",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this branch protection rule.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description Number of approving reviews required to update matching branches.
   */

  readonly requiredApprovingReviewCount: () => Field<"requiredApprovingReviewCount">;

  /**
   * @description List of required status check contexts that must pass for commits to be accepted to matching branches.
   */

  readonly requiredStatusCheckContexts: () => Field<"requiredStatusCheckContexts">;

  /**
   * @description Are approving reviews required to update matching branches.
   */

  readonly requiresApprovingReviews: () => Field<"requiresApprovingReviews">;

  /**
   * @description Are reviews from code owners required to update matching branches.
   */

  readonly requiresCodeOwnerReviews: () => Field<"requiresCodeOwnerReviews">;

  /**
   * @description Are commits required to be signed.
   */

  readonly requiresCommitSignatures: () => Field<"requiresCommitSignatures">;

  /**
   * @description Are merge commits prohibited from being pushed to this branch.
   */

  readonly requiresLinearHistory: () => Field<"requiresLinearHistory">;

  /**
   * @description Are status checks required to update matching branches.
   */

  readonly requiresStatusChecks: () => Field<"requiresStatusChecks">;

  /**
   * @description Are branches required to be up to date before merging.
   */

  readonly requiresStrictStatusChecks: () => Field<"requiresStrictStatusChecks">;

  /**
   * @description Is pushing to matching branches restricted.
   */

  readonly restrictsPushes: () => Field<"restrictsPushes">;

  /**
   * @description Is dismissal of pull request reviews restricted.
   */

  readonly restrictsReviewDismissals: () => Field<"restrictsReviewDismissals">;

  /**
   * @description A list review dismissal allowances for this branch protection rule.
   */

  readonly reviewDismissalAllowances: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ReviewDismissalAllowanceConnectionSelector) => T
  ) => Field<
    "reviewDismissalAllowances",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;
}

export const isBranchProtectionRule = (
  object: Record<string, any>
): object is Partial<IBranchProtectionRule> => {
  return object.__typename === "BranchProtectionRule";
};

export const BranchProtectionRule: BranchProtectionRuleSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Can this branch be deleted.
   */
  allowsDeletions: () => new Field("allowsDeletions"),

  /**
   * @description Are force pushes allowed on this branch.
   */
  allowsForcePushes: () => new Field("allowsForcePushes"),

  /**
   * @description A list of conflicts matching branches protection rule and other branch protection rules
   */

  branchProtectionRuleConflicts: (variables, select) =>
    new Field(
      "branchProtectionRuleConflicts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(BranchProtectionRuleConflictConnection))
    ),

  /**
   * @description The actor who created this branch protection rule.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description Will new commits pushed to matching branches dismiss pull request review approvals.
   */
  dismissesStaleReviews: () => new Field("dismissesStaleReviews"),
  id: () => new Field("id"),

  /**
   * @description Can admins overwrite branch protection.
   */
  isAdminEnforced: () => new Field("isAdminEnforced"),

  /**
   * @description Repository refs that are protected by this rule
   */

  matchingRefs: (variables, select) =>
    new Field(
      "matchingRefs",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(RefConnection))
    ),

  /**
   * @description Identifies the protection rule pattern.
   */
  pattern: () => new Field("pattern"),

  /**
   * @description A list push allowances for this branch protection rule.
   */

  pushAllowances: (variables, select) =>
    new Field(
      "pushAllowances",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PushAllowanceConnection))
    ),

  /**
   * @description The repository associated with this branch protection rule.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Number of approving reviews required to update matching branches.
   */
  requiredApprovingReviewCount: () => new Field("requiredApprovingReviewCount"),

  /**
   * @description List of required status check contexts that must pass for commits to be accepted to matching branches.
   */
  requiredStatusCheckContexts: () => new Field("requiredStatusCheckContexts"),

  /**
   * @description Are approving reviews required to update matching branches.
   */
  requiresApprovingReviews: () => new Field("requiresApprovingReviews"),

  /**
   * @description Are reviews from code owners required to update matching branches.
   */
  requiresCodeOwnerReviews: () => new Field("requiresCodeOwnerReviews"),

  /**
   * @description Are commits required to be signed.
   */
  requiresCommitSignatures: () => new Field("requiresCommitSignatures"),

  /**
   * @description Are merge commits prohibited from being pushed to this branch.
   */
  requiresLinearHistory: () => new Field("requiresLinearHistory"),

  /**
   * @description Are status checks required to update matching branches.
   */
  requiresStatusChecks: () => new Field("requiresStatusChecks"),

  /**
   * @description Are branches required to be up to date before merging.
   */
  requiresStrictStatusChecks: () => new Field("requiresStrictStatusChecks"),

  /**
   * @description Is pushing to matching branches restricted.
   */
  restrictsPushes: () => new Field("restrictsPushes"),

  /**
   * @description Is dismissal of pull request reviews restricted.
   */
  restrictsReviewDismissals: () => new Field("restrictsReviewDismissals"),

  /**
   * @description A list review dismissal allowances for this branch protection rule.
   */

  reviewDismissalAllowances: (variables, select) =>
    new Field(
      "reviewDismissalAllowances",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ReviewDismissalAllowanceConnection))
    ),
};

export interface IBranchProtectionRuleConflict {
  readonly __typename: "BranchProtectionRuleConflict";
  readonly branchProtectionRule: IBranchProtectionRule | null;
  readonly conflictingBranchProtectionRule: IBranchProtectionRule | null;
  readonly ref: IRef | null;
}

interface BranchProtectionRuleConflictSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the branch protection rule.
   */

  readonly branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  /**
   * @description Identifies the conflicting branch protection rule.
   */

  readonly conflictingBranchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"conflictingBranchProtectionRule", never, SelectionSet<T>>;

  /**
   * @description Identifies the branch ref that has conflicting rules
   */

  readonly ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const BranchProtectionRuleConflict: BranchProtectionRuleConflictSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the branch protection rule.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description Identifies the conflicting branch protection rule.
   */

  conflictingBranchProtectionRule: (select) =>
    new Field(
      "conflictingBranchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description Identifies the branch ref that has conflicting rules
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IBranchProtectionRuleConflictConnection {
  readonly __typename: "BranchProtectionRuleConflictConnection";
  readonly edges: ReadonlyArray<IBranchProtectionRuleConflictEdge> | null;
  readonly nodes: ReadonlyArray<IBranchProtectionRuleConflict> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface BranchProtectionRuleConflictConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleConflictEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleConflictSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const BranchProtectionRuleConflictConnection: BranchProtectionRuleConflictConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(BranchProtectionRuleConflictEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(BranchProtectionRuleConflict))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IBranchProtectionRuleConflictEdge {
  readonly __typename: "BranchProtectionRuleConflictEdge";
  readonly cursor: string;
  readonly node: IBranchProtectionRuleConflict | null;
}

interface BranchProtectionRuleConflictEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleConflictSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const BranchProtectionRuleConflictEdge: BranchProtectionRuleConflictEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(BranchProtectionRuleConflict))
    ),
};

export interface IBranchProtectionRuleConnection {
  readonly __typename: "BranchProtectionRuleConnection";
  readonly edges: ReadonlyArray<IBranchProtectionRuleEdge> | null;
  readonly nodes: ReadonlyArray<IBranchProtectionRule> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface BranchProtectionRuleConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const BranchProtectionRuleConnection: BranchProtectionRuleConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(BranchProtectionRuleEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IBranchProtectionRuleEdge {
  readonly __typename: "BranchProtectionRuleEdge";
  readonly cursor: string;
  readonly node: IBranchProtectionRule | null;
}

interface BranchProtectionRuleEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const BranchProtectionRuleEdge: BranchProtectionRuleEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),
};

export interface ICancelEnterpriseAdminInvitationPayload {
  readonly __typename: "CancelEnterpriseAdminInvitationPayload";
  readonly clientMutationId: string | null;
  readonly invitation: IEnterpriseAdministratorInvitation | null;
  readonly message: string | null;
}

interface CancelEnterpriseAdminInvitationPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The invitation that was canceled.
   */

  readonly invitation: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"invitation", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of canceling an administrator invitation.
   */

  readonly message: () => Field<"message">;
}

export const CancelEnterpriseAdminInvitationPayload: CancelEnterpriseAdminInvitationPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The invitation that was canceled.
   */

  invitation: (select) =>
    new Field(
      "invitation",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description A message confirming the result of canceling an administrator invitation.
   */
  message: () => new Field("message"),
};

export interface IChangeUserStatusPayload {
  readonly __typename: "ChangeUserStatusPayload";
  readonly clientMutationId: string | null;
  readonly status: IUserStatus | null;
}

interface ChangeUserStatusPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description Your updated status.
   */

  readonly status: <T extends Array<Selection>>(
    select: (t: UserStatusSelector) => T
  ) => Field<"status", never, SelectionSet<T>>;
}

export const ChangeUserStatusPayload: ChangeUserStatusPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description Your updated status.
   */

  status: (select) =>
    new Field(
      "status",
      undefined as never,
      new SelectionSet(select(UserStatus))
    ),
};

export interface ICheckAnnotation {
  readonly __typename: "CheckAnnotation";
  readonly annotationLevel: CheckAnnotationLevel | null;
  readonly blobUrl: unknown;
  readonly databaseId: number | null;
  readonly location: ICheckAnnotationSpan;
  readonly message: string;
  readonly path: string;
  readonly rawDetails: string | null;
  readonly title: string | null;
}

interface CheckAnnotationSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The annotation's severity level.
   */

  readonly annotationLevel: () => Field<"annotationLevel">;

  /**
   * @description The path to the file that this annotation was made on.
   */

  readonly blobUrl: () => Field<"blobUrl">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The position of this annotation.
   */

  readonly location: <T extends Array<Selection>>(
    select: (t: CheckAnnotationSpanSelector) => T
  ) => Field<"location", never, SelectionSet<T>>;

  /**
   * @description The annotation's message.
   */

  readonly message: () => Field<"message">;

  /**
   * @description The path that this annotation was made on.
   */

  readonly path: () => Field<"path">;

  /**
   * @description Additional information about the annotation.
   */

  readonly rawDetails: () => Field<"rawDetails">;

  /**
   * @description The annotation's title
   */

  readonly title: () => Field<"title">;
}

export const CheckAnnotation: CheckAnnotationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The annotation's severity level.
   */
  annotationLevel: () => new Field("annotationLevel"),

  /**
   * @description The path to the file that this annotation was made on.
   */
  blobUrl: () => new Field("blobUrl"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The position of this annotation.
   */

  location: (select) =>
    new Field(
      "location",
      undefined as never,
      new SelectionSet(select(CheckAnnotationSpan))
    ),

  /**
   * @description The annotation's message.
   */
  message: () => new Field("message"),

  /**
   * @description The path that this annotation was made on.
   */
  path: () => new Field("path"),

  /**
   * @description Additional information about the annotation.
   */
  rawDetails: () => new Field("rawDetails"),

  /**
   * @description The annotation's title
   */
  title: () => new Field("title"),
};

export interface ICheckAnnotationConnection {
  readonly __typename: "CheckAnnotationConnection";
  readonly edges: ReadonlyArray<ICheckAnnotationEdge> | null;
  readonly nodes: ReadonlyArray<ICheckAnnotation> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CheckAnnotationConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CheckAnnotationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CheckAnnotationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CheckAnnotationConnection: CheckAnnotationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CheckAnnotationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CheckAnnotation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICheckAnnotationEdge {
  readonly __typename: "CheckAnnotationEdge";
  readonly cursor: string;
  readonly node: ICheckAnnotation | null;
}

interface CheckAnnotationEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CheckAnnotationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CheckAnnotationEdge: CheckAnnotationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CheckAnnotation))
    ),
};

export interface ICheckAnnotationPosition {
  readonly __typename: "CheckAnnotationPosition";
  readonly column: number | null;
  readonly line: number;
}

interface CheckAnnotationPositionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Column number (1 indexed).
   */

  readonly column: () => Field<"column">;

  /**
   * @description Line number (1 indexed).
   */

  readonly line: () => Field<"line">;
}

export const CheckAnnotationPosition: CheckAnnotationPositionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Column number (1 indexed).
   */
  column: () => new Field("column"),

  /**
   * @description Line number (1 indexed).
   */
  line: () => new Field("line"),
};

export interface ICheckAnnotationSpan {
  readonly __typename: "CheckAnnotationSpan";
  readonly end: ICheckAnnotationPosition;
  readonly start: ICheckAnnotationPosition;
}

interface CheckAnnotationSpanSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description End position (inclusive).
   */

  readonly end: <T extends Array<Selection>>(
    select: (t: CheckAnnotationPositionSelector) => T
  ) => Field<"end", never, SelectionSet<T>>;

  /**
   * @description Start position (inclusive).
   */

  readonly start: <T extends Array<Selection>>(
    select: (t: CheckAnnotationPositionSelector) => T
  ) => Field<"start", never, SelectionSet<T>>;
}

export const CheckAnnotationSpan: CheckAnnotationSpanSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description End position (inclusive).
   */

  end: (select) =>
    new Field(
      "end",
      undefined as never,
      new SelectionSet(select(CheckAnnotationPosition))
    ),

  /**
   * @description Start position (inclusive).
   */

  start: (select) =>
    new Field(
      "start",
      undefined as never,
      new SelectionSet(select(CheckAnnotationPosition))
    ),
};

export interface ICheckRun extends INode, IUniformResourceLocatable {
  readonly __typename: "CheckRun";
  readonly annotations: ICheckAnnotationConnection | null;
  readonly checkSuite: ICheckSuite;
  readonly completedAt: unknown | null;
  readonly conclusion: CheckConclusionState | null;
  readonly databaseId: number | null;
  readonly detailsUrl: unknown | null;
  readonly externalId: string | null;
  readonly name: string;
  readonly permalink: unknown;
  readonly repository: IRepository;
  readonly startedAt: unknown | null;
  readonly status: CheckStatusState;
  readonly summary: string | null;
  readonly text: string | null;
  readonly title: string | null;
}

interface CheckRunSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The check run's annotations
   */

  readonly annotations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CheckAnnotationConnectionSelector) => T
  ) => Field<
    "annotations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The check suite that this run is a part of.
   */

  readonly checkSuite: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"checkSuite", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the check run was completed.
   */

  readonly completedAt: () => Field<"completedAt">;

  /**
   * @description The conclusion of the check run.
   */

  readonly conclusion: () => Field<"conclusion">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The URL from which to find full details of the check run on the integrator's site.
   */

  readonly detailsUrl: () => Field<"detailsUrl">;

  /**
   * @description A reference for the check run on the integrator's system.
   */

  readonly externalId: () => Field<"externalId">;

  readonly id: () => Field<"id">;

  /**
   * @description The name of the check for this check run.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The permalink to the check run summary.
   */

  readonly permalink: () => Field<"permalink">;

  /**
   * @description The repository associated with this check run.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this check run.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the check run was started.
   */

  readonly startedAt: () => Field<"startedAt">;

  /**
   * @description The current status of the check run.
   */

  readonly status: () => Field<"status">;

  /**
   * @description A string representing the check run's summary
   */

  readonly summary: () => Field<"summary">;

  /**
   * @description A string representing the check run's text
   */

  readonly text: () => Field<"text">;

  /**
   * @description A string representing the check run
   */

  readonly title: () => Field<"title">;

  /**
   * @description The HTTP URL for this check run.
   */

  readonly url: () => Field<"url">;
}

export const isCheckRun = (
  object: Record<string, any>
): object is Partial<ICheckRun> => {
  return object.__typename === "CheckRun";
};

export const CheckRun: CheckRunSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The check run's annotations
   */

  annotations: (variables, select) =>
    new Field(
      "annotations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CheckAnnotationConnection))
    ),

  /**
   * @description The check suite that this run is a part of.
   */

  checkSuite: (select) =>
    new Field(
      "checkSuite",
      undefined as never,
      new SelectionSet(select(CheckSuite))
    ),

  /**
   * @description Identifies the date and time when the check run was completed.
   */
  completedAt: () => new Field("completedAt"),

  /**
   * @description The conclusion of the check run.
   */
  conclusion: () => new Field("conclusion"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The URL from which to find full details of the check run on the integrator's site.
   */
  detailsUrl: () => new Field("detailsUrl"),

  /**
   * @description A reference for the check run on the integrator's system.
   */
  externalId: () => new Field("externalId"),
  id: () => new Field("id"),

  /**
   * @description The name of the check for this check run.
   */
  name: () => new Field("name"),

  /**
   * @description The permalink to the check run summary.
   */
  permalink: () => new Field("permalink"),

  /**
   * @description The repository associated with this check run.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this check run.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the check run was started.
   */
  startedAt: () => new Field("startedAt"),

  /**
   * @description The current status of the check run.
   */
  status: () => new Field("status"),

  /**
   * @description A string representing the check run's summary
   */
  summary: () => new Field("summary"),

  /**
   * @description A string representing the check run's text
   */
  text: () => new Field("text"),

  /**
   * @description A string representing the check run
   */
  title: () => new Field("title"),

  /**
   * @description The HTTP URL for this check run.
   */
  url: () => new Field("url"),
};

export interface ICheckRunConnection {
  readonly __typename: "CheckRunConnection";
  readonly edges: ReadonlyArray<ICheckRunEdge> | null;
  readonly nodes: ReadonlyArray<ICheckRun> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CheckRunConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CheckRunEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CheckRunSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CheckRunConnection: CheckRunConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CheckRunEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(CheckRun))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICheckRunEdge {
  readonly __typename: "CheckRunEdge";
  readonly cursor: string;
  readonly node: ICheckRun | null;
}

interface CheckRunEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CheckRunSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CheckRunEdge: CheckRunEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(CheckRun))),
};

export interface ICheckSuite extends INode {
  readonly __typename: "CheckSuite";
  readonly app: IApp | null;
  readonly branch: IRef | null;
  readonly checkRuns: ICheckRunConnection | null;
  readonly commit: ICommit;
  readonly conclusion: CheckConclusionState | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly matchingPullRequests: IPullRequestConnection | null;
  readonly push: IPush | null;
  readonly repository: IRepository;
  readonly resourcePath: unknown;
  readonly status: CheckStatusState;
  readonly updatedAt: unknown;
  readonly url: unknown;
}

interface CheckSuiteSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The GitHub App which created this check suite.
   */

  readonly app: <T extends Array<Selection>>(
    select: (t: AppSelector) => T
  ) => Field<"app", never, SelectionSet<T>>;

  /**
   * @description The name of the branch for this check suite.
   */

  readonly branch: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"branch", never, SelectionSet<T>>;

  /**
   * @description The check runs associated with a check suite.
   */

  readonly checkRuns: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | CheckRunFilter;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CheckRunConnectionSelector) => T
  ) => Field<
    "checkRuns",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | CheckRunFilter>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The commit for this check suite
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description The conclusion of this check suite.
   */

  readonly conclusion: () => Field<"conclusion">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description A list of open pull requests matching the check suite.
   */

  readonly matchingPullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "matchingPullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The push that triggered this check suite.
   */

  readonly push: <T extends Array<Selection>>(
    select: (t: PushSelector) => T
  ) => Field<"push", never, SelectionSet<T>>;

  /**
   * @description The repository associated with this check suite.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this check suite
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The status of this check suite.
   */

  readonly status: () => Field<"status">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this check suite
   */

  readonly url: () => Field<"url">;
}

export const isCheckSuite = (
  object: Record<string, any>
): object is Partial<ICheckSuite> => {
  return object.__typename === "CheckSuite";
};

export const CheckSuite: CheckSuiteSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The GitHub App which created this check suite.
   */

  app: (select) =>
    new Field("app", undefined as never, new SelectionSet(select(App))),

  /**
   * @description The name of the branch for this check suite.
   */

  branch: (select) =>
    new Field("branch", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description The check runs associated with a check suite.
   */

  checkRuns: (variables, select) =>
    new Field(
      "checkRuns",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CheckRunConnection))
    ),

  /**
   * @description The commit for this check suite
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description The conclusion of this check suite.
   */
  conclusion: () => new Field("conclusion"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description A list of open pull requests matching the check suite.
   */

  matchingPullRequests: (variables, select) =>
    new Field(
      "matchingPullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description The push that triggered this check suite.
   */

  push: (select) =>
    new Field("push", undefined as never, new SelectionSet(select(Push))),

  /**
   * @description The repository associated with this check suite.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this check suite
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The status of this check suite.
   */
  status: () => new Field("status"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this check suite
   */
  url: () => new Field("url"),
};

export interface ICheckSuiteConnection {
  readonly __typename: "CheckSuiteConnection";
  readonly edges: ReadonlyArray<ICheckSuiteEdge> | null;
  readonly nodes: ReadonlyArray<ICheckSuite> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CheckSuiteConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CheckSuiteEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CheckSuiteConnection: CheckSuiteConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CheckSuiteEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CheckSuite))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICheckSuiteEdge {
  readonly __typename: "CheckSuiteEdge";
  readonly cursor: string;
  readonly node: ICheckSuite | null;
}

interface CheckSuiteEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CheckSuiteEdge: CheckSuiteEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(CheckSuite))),
};

export interface IClearLabelsFromLabelablePayload {
  readonly __typename: "ClearLabelsFromLabelablePayload";
  readonly clientMutationId: string | null;
  readonly labelable: ILabelable | null;
}

interface ClearLabelsFromLabelablePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The item that was unlabeled.
   */

  readonly labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const ClearLabelsFromLabelablePayload: ClearLabelsFromLabelablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The item that was unlabeled.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface ICloneProjectPayload {
  readonly __typename: "CloneProjectPayload";
  readonly clientMutationId: string | null;
  readonly jobStatusId: string | null;
  readonly project: IProject | null;
}

interface CloneProjectPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The id of the JobStatus for populating cloned fields.
   */

  readonly jobStatusId: () => Field<"jobStatusId">;

  /**
   * @description The new cloned project.
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const CloneProjectPayload: CloneProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The id of the JobStatus for populating cloned fields.
   */
  jobStatusId: () => new Field("jobStatusId"),

  /**
   * @description The new cloned project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface ICloneTemplateRepositoryPayload {
  readonly __typename: "CloneTemplateRepositoryPayload";
  readonly clientMutationId: string | null;
  readonly repository: IRepository | null;
}

interface CloneTemplateRepositoryPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new repository.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const CloneTemplateRepositoryPayload: CloneTemplateRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IClosable {
  readonly __typename: string;
  readonly closed: boolean;
  readonly closedAt: unknown | null;
}

interface ClosableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */

  readonly closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  readonly closedAt: () => Field<"closedAt">;

  readonly on: <
    T extends Array<Selection>,
    F extends "Issue" | "Milestone" | "Project" | "PullRequest"
  >(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "Milestone"
        ? MilestoneSelector
        : F extends "Project"
        ? ProjectSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Closable: ClosableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "Milestone": {
        return new InlineFragment(
          new NamedType("Milestone") as any,
          new SelectionSet(select(Milestone as any))
        );
      }

      case "Project": {
        return new InlineFragment(
          new NamedType("Project") as any,
          new SelectionSet(select(Project as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Closable",
        });
    }
  },
};

export interface ICloseIssuePayload {
  readonly __typename: "CloseIssuePayload";
  readonly clientMutationId: string | null;
  readonly issue: IIssue | null;
}

interface CloseIssuePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue that was closed.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const CloseIssuePayload: CloseIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue that was closed.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IClosePullRequestPayload {
  readonly __typename: "ClosePullRequestPayload";
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
}

interface ClosePullRequestPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that was closed.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const ClosePullRequestPayload: ClosePullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that was closed.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IClosedEvent extends INode, IUniformResourceLocatable {
  readonly __typename: "ClosedEvent";
  readonly actor: IActor | null;
  readonly closable: IClosable;
  readonly closer: ICloser | null;
  readonly createdAt: unknown;
}

interface ClosedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Object that was closed.
   */

  readonly closable: <T extends Array<Selection>>(
    select: (t: ClosableSelector) => T
  ) => Field<"closable", never, SelectionSet<T>>;

  /**
   * @description Object which triggered the creation of this event.
   */

  readonly closer: <T extends Array<Selection>>(
    select: (t: CloserSelector) => T
  ) => Field<"closer", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The HTTP path for this closed event.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this closed event.
   */

  readonly url: () => Field<"url">;
}

export const isClosedEvent = (
  object: Record<string, any>
): object is Partial<IClosedEvent> => {
  return object.__typename === "ClosedEvent";
};

export const ClosedEvent: ClosedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Object that was closed.
   */

  closable: (select) =>
    new Field(
      "closable",
      undefined as never,
      new SelectionSet(select(Closable))
    ),

  /**
   * @description Object which triggered the creation of this event.
   */

  closer: (select) =>
    new Field("closer", undefined as never, new SelectionSet(select(Closer))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The HTTP path for this closed event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this closed event.
   */
  url: () => new Field("url"),
};

export interface ICodeOfConduct extends INode {
  readonly __typename: "CodeOfConduct";
  readonly body: string | null;
  readonly key: string;
  readonly name: string;
  readonly resourcePath: unknown | null;
  readonly url: unknown | null;
}

interface CodeOfConductSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The body of the Code of Conduct
   */

  readonly body: () => Field<"body">;

  readonly id: () => Field<"id">;

  /**
   * @description The key for the Code of Conduct
   */

  readonly key: () => Field<"key">;

  /**
   * @description The formal name of the Code of Conduct
   */

  readonly name: () => Field<"name">;

  /**
   * @description The HTTP path for this Code of Conduct
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this Code of Conduct
   */

  readonly url: () => Field<"url">;
}

export const isCodeOfConduct = (
  object: Record<string, any>
): object is Partial<ICodeOfConduct> => {
  return object.__typename === "CodeOfConduct";
};

export const CodeOfConduct: CodeOfConductSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The body of the Code of Conduct
   */
  body: () => new Field("body"),
  id: () => new Field("id"),

  /**
   * @description The key for the Code of Conduct
   */
  key: () => new Field("key"),

  /**
   * @description The formal name of the Code of Conduct
   */
  name: () => new Field("name"),

  /**
   * @description The HTTP path for this Code of Conduct
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this Code of Conduct
   */
  url: () => new Field("url"),
};

export interface IComment {
  readonly __typename: string;
  readonly author: IActor | null;
  readonly authorAssociation: CommentAuthorAssociation;
  readonly body: string;
  readonly bodyHTML: unknown;
  readonly bodyText: string;
  readonly createdAt: unknown;
  readonly createdViaEmail: boolean;
  readonly editor: IActor | null;
  readonly id: string;
  readonly includesCreatedEdit: boolean;
  readonly lastEditedAt: unknown | null;
  readonly publishedAt: unknown | null;
  readonly updatedAt: unknown;
  readonly userContentEdits: IUserContentEditConnection | null;
  readonly viewerDidAuthor: boolean;
}

interface CommentSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The body as Markdown.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "Issue"
      | "IssueComment"
      | "PullRequest"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Comment: CommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Comment",
        });
    }
  },
};

export interface ICommentDeletedEvent extends INode {
  readonly __typename: "CommentDeletedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly deletedCommentAuthor: IActor | null;
}

interface CommentDeletedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The user who authored the deleted comment.
   */

  readonly deletedCommentAuthor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"deletedCommentAuthor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;
}

export const isCommentDeletedEvent = (
  object: Record<string, any>
): object is Partial<ICommentDeletedEvent> => {
  return object.__typename === "CommentDeletedEvent";
};

export const CommentDeletedEvent: CommentDeletedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The user who authored the deleted comment.
   */

  deletedCommentAuthor: (select) =>
    new Field(
      "deletedCommentAuthor",
      undefined as never,
      new SelectionSet(select(Actor))
    ),

  id: () => new Field("id"),
};

export interface ICommit
  extends IGitObject,
    INode,
    ISubscribable,
    IUniformResourceLocatable {
  readonly __typename: "Commit";
  readonly additions: number;
  readonly associatedPullRequests: IPullRequestConnection | null;
  readonly author: IGitActor | null;
  readonly authoredByCommitter: boolean;
  readonly authoredDate: unknown;
  readonly authors: IGitActorConnection;
  readonly blame: IBlame;
  readonly changedFiles: number;
  readonly checkSuites: ICheckSuiteConnection | null;
  readonly comments: ICommitCommentConnection;
  readonly committedDate: unknown;
  readonly committedViaWeb: boolean;
  readonly committer: IGitActor | null;
  readonly deletions: number;
  readonly deployments: IDeploymentConnection | null;
  readonly file: ITreeEntry | null;
  readonly history: ICommitHistoryConnection;
  readonly message: string;
  readonly messageBody: string;
  readonly messageBodyHTML: unknown;
  readonly messageHeadline: string;
  readonly messageHeadlineHTML: unknown;
  readonly onBehalfOf: IOrganization | null;
  readonly parents: ICommitConnection;
  readonly pushedDate: unknown | null;
  readonly signature: IGitSignature | null;
  readonly status: IStatus | null;
  readonly statusCheckRollup: IStatusCheckRollup | null;
  readonly submodules: ISubmoduleConnection;
  readonly tarballUrl: unknown;
  readonly tree: ITree;
  readonly treeResourcePath: unknown;
  readonly treeUrl: unknown;
  readonly zipballUrl: unknown;
}

interface CommitSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  readonly abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description The number of additions in this commit.
   */

  readonly additions: () => Field<"additions">;

  /**
   * @description The pull requests associated with a commit
   */

  readonly associatedPullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | PullRequestOrder;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "associatedPullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | PullRequestOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Authorship details of the commit.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Check if the committer and the author match.
   */

  readonly authoredByCommitter: () => Field<"authoredByCommitter">;

  /**
   * @description The datetime when this commit was authored.
   */

  readonly authoredDate: () => Field<"authoredDate">;

  /**
     * @description The list of authors for this commit based on the git author and the Co-authored-by
message trailer. The git author will always be first.
     */

  readonly authors: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: GitActorConnectionSelector) => T
  ) => Field<
    "authors",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Fetches `git blame` information.
   */

  readonly blame: <T extends Array<Selection>>(
    variables: { path?: Variable<"path"> | string },
    select: (t: BlameSelector) => T
  ) => Field<
    "blame",
    [Argument<"path", Variable<"path"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The number of changed files in this commit.
   */

  readonly changedFiles: () => Field<"changedFiles">;

  /**
   * @description The check suites associated with a commit.
   */

  readonly checkSuites: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | CheckSuiteFilter;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CheckSuiteConnectionSelector) => T
  ) => Field<
    "checkSuites",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | CheckSuiteFilter>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Comments made on the commit.
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this Git object
   */

  readonly commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  readonly commitUrl: () => Field<"commitUrl">;

  /**
   * @description The datetime when this commit was committed.
   */

  readonly committedDate: () => Field<"committedDate">;

  /**
   * @description Check if commited via GitHub web UI.
   */

  readonly committedViaWeb: () => Field<"committedViaWeb">;

  /**
   * @description Committership details of the commit.
   */

  readonly committer: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"committer", never, SelectionSet<T>>;

  /**
   * @description The number of deletions in this commit.
   */

  readonly deletions: () => Field<"deletions">;

  /**
   * @description The deployments associated with a commit.
   */

  readonly deployments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      environments?: Variable<"environments"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | DeploymentOrder;
    },
    select: (t: DeploymentConnectionSelector) => T
  ) => Field<
    "deployments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"environments", Variable<"environments"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | DeploymentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The tree entry representing the file located at the given path.
   */

  readonly file: <T extends Array<Selection>>(
    variables: { path?: Variable<"path"> | string },
    select: (t: TreeEntrySelector) => T
  ) => Field<
    "file",
    [Argument<"path", Variable<"path"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The linear commit history starting from (and including) this commit, in the same order as `git log`.
   */

  readonly history: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      author?: Variable<"author"> | CommitAuthor;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      path?: Variable<"path"> | string;
      since?: Variable<"since"> | unknown;
      until?: Variable<"until"> | unknown;
    },
    select: (t: CommitHistoryConnectionSelector) => T
  ) => Field<
    "history",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"author", Variable<"author"> | CommitAuthor>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"path", Variable<"path"> | string>,
      Argument<"since", Variable<"since"> | unknown>,
      Argument<"until", Variable<"until"> | unknown>
    ],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description The Git commit message
   */

  readonly message: () => Field<"message">;

  /**
   * @description The Git commit message body
   */

  readonly messageBody: () => Field<"messageBody">;

  /**
   * @description The commit message body rendered to HTML.
   */

  readonly messageBodyHTML: () => Field<"messageBodyHTML">;

  /**
   * @description The Git commit message headline
   */

  readonly messageHeadline: () => Field<"messageHeadline">;

  /**
   * @description The commit message headline rendered to HTML.
   */

  readonly messageHeadlineHTML: () => Field<"messageHeadlineHTML">;

  /**
   * @description The Git object ID
   */

  readonly oid: () => Field<"oid">;

  /**
   * @description The organization this commit was made on behalf of.
   */

  readonly onBehalfOf: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"onBehalfOf", never, SelectionSet<T>>;

  /**
   * @description The parents of a commit.
   */

  readonly parents: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitConnectionSelector) => T
  ) => Field<
    "parents",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The datetime when this commit was pushed.
   */

  readonly pushedDate: () => Field<"pushedDate">;

  /**
   * @description The Repository this commit belongs to
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this commit
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Commit signing information, if present.
   */

  readonly signature: <T extends Array<Selection>>(
    select: (t: GitSignatureSelector) => T
  ) => Field<"signature", never, SelectionSet<T>>;

  /**
   * @description Status information for this commit
   */

  readonly status: <T extends Array<Selection>>(
    select: (t: StatusSelector) => T
  ) => Field<"status", never, SelectionSet<T>>;

  /**
   * @description Check and Status rollup information for this commit.
   */

  readonly statusCheckRollup: <T extends Array<Selection>>(
    select: (t: StatusCheckRollupSelector) => T
  ) => Field<"statusCheckRollup", never, SelectionSet<T>>;

  /**
   * @description Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file.
   */

  readonly submodules: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: SubmoduleConnectionSelector) => T
  ) => Field<
    "submodules",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
     * @description Returns a URL to download a tarball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes.
     */

  readonly tarballUrl: () => Field<"tarballUrl">;

  /**
   * @description Commit's root Tree
   */

  readonly tree: <T extends Array<Selection>>(
    select: (t: TreeSelector) => T
  ) => Field<"tree", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for the tree of this commit
   */

  readonly treeResourcePath: () => Field<"treeResourcePath">;

  /**
   * @description The HTTP URL for the tree of this commit
   */

  readonly treeUrl: () => Field<"treeUrl">;

  /**
   * @description The HTTP URL for this commit
   */

  readonly url: () => Field<"url">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  readonly viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  readonly viewerSubscription: () => Field<"viewerSubscription">;

  /**
     * @description Returns a URL to download a zipball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes.
     */

  readonly zipballUrl: () => Field<"zipballUrl">;
}

export const isCommit = (
  object: Record<string, any>
): object is Partial<ICommit> => {
  return object.__typename === "Commit";
};

export const Commit: CommitSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description The number of additions in this commit.
   */
  additions: () => new Field("additions"),

  /**
   * @description The pull requests associated with a commit
   */

  associatedPullRequests: (variables, select) =>
    new Field(
      "associatedPullRequests",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description Authorship details of the commit.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(GitActor))),

  /**
   * @description Check if the committer and the author match.
   */
  authoredByCommitter: () => new Field("authoredByCommitter"),

  /**
   * @description The datetime when this commit was authored.
   */
  authoredDate: () => new Field("authoredDate"),

  /**
     * @description The list of authors for this commit based on the git author and the Co-authored-by
message trailer. The git author will always be first.
     */

  authors: (variables, select) =>
    new Field(
      "authors",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(GitActorConnection))
    ),

  /**
   * @description Fetches `git blame` information.
   */

  blame: (variables, select) =>
    new Field(
      "blame",
      [new Argument("path", variables.path)],
      new SelectionSet(select(Blame))
    ),

  /**
   * @description The number of changed files in this commit.
   */
  changedFiles: () => new Field("changedFiles"),

  /**
   * @description The check suites associated with a commit.
   */

  checkSuites: (variables, select) =>
    new Field(
      "checkSuites",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CheckSuiteConnection))
    ),

  /**
   * @description Comments made on the commit.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),

  /**
   * @description The datetime when this commit was committed.
   */
  committedDate: () => new Field("committedDate"),

  /**
   * @description Check if commited via GitHub web UI.
   */
  committedViaWeb: () => new Field("committedViaWeb"),

  /**
   * @description Committership details of the commit.
   */

  committer: (select) =>
    new Field(
      "committer",
      undefined as never,
      new SelectionSet(select(GitActor))
    ),

  /**
   * @description The number of deletions in this commit.
   */
  deletions: () => new Field("deletions"),

  /**
   * @description The deployments associated with a commit.
   */

  deployments: (variables, select) =>
    new Field(
      "deployments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("environments", variables.environments),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(DeploymentConnection))
    ),

  /**
   * @description The tree entry representing the file located at the given path.
   */

  file: (variables, select) =>
    new Field(
      "file",
      [new Argument("path", variables.path)],
      new SelectionSet(select(TreeEntry))
    ),

  /**
   * @description The linear commit history starting from (and including) this commit, in the same order as `git log`.
   */

  history: (variables, select) =>
    new Field(
      "history",
      [
        new Argument("after", variables.after),
        new Argument("author", variables.author),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("path", variables.path),
        new Argument("since", variables.since),
        new Argument("until", variables.until),
      ],
      new SelectionSet(select(CommitHistoryConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The Git commit message
   */
  message: () => new Field("message"),

  /**
   * @description The Git commit message body
   */
  messageBody: () => new Field("messageBody"),

  /**
   * @description The commit message body rendered to HTML.
   */
  messageBodyHTML: () => new Field("messageBodyHTML"),

  /**
   * @description The Git commit message headline
   */
  messageHeadline: () => new Field("messageHeadline"),

  /**
   * @description The commit message headline rendered to HTML.
   */
  messageHeadlineHTML: () => new Field("messageHeadlineHTML"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The organization this commit was made on behalf of.
   */

  onBehalfOf: (select) =>
    new Field(
      "onBehalfOf",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The parents of a commit.
   */

  parents: (variables, select) =>
    new Field(
      "parents",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitConnection))
    ),

  /**
   * @description The datetime when this commit was pushed.
   */
  pushedDate: () => new Field("pushedDate"),

  /**
   * @description The Repository this commit belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this commit
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Commit signing information, if present.
   */

  signature: (select) =>
    new Field(
      "signature",
      undefined as never,
      new SelectionSet(select(GitSignature))
    ),

  /**
   * @description Status information for this commit
   */

  status: (select) =>
    new Field("status", undefined as never, new SelectionSet(select(Status))),

  /**
   * @description Check and Status rollup information for this commit.
   */

  statusCheckRollup: (select) =>
    new Field(
      "statusCheckRollup",
      undefined as never,
      new SelectionSet(select(StatusCheckRollup))
    ),

  /**
   * @description Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file.
   */

  submodules: (variables, select) =>
    new Field(
      "submodules",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(SubmoduleConnection))
    ),

  /**
     * @description Returns a URL to download a tarball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes.
     */
  tarballUrl: () => new Field("tarballUrl"),

  /**
   * @description Commit's root Tree
   */

  tree: (select) =>
    new Field("tree", undefined as never, new SelectionSet(select(Tree))),

  /**
   * @description The HTTP path for the tree of this commit
   */
  treeResourcePath: () => new Field("treeResourcePath"),

  /**
   * @description The HTTP URL for the tree of this commit
   */
  treeUrl: () => new Field("treeUrl"),

  /**
   * @description The HTTP URL for this commit
   */
  url: () => new Field("url"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),

  /**
     * @description Returns a URL to download a zipball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes.
     */
  zipballUrl: () => new Field("zipballUrl"),
};

export interface ICommitComment
  extends IComment,
    IDeletable,
    IMinimizable,
    INode,
    IReactable,
    IRepositoryNode,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "CommitComment";
  readonly commit: ICommit | null;
  readonly path: string | null;
  readonly position: number | null;
  readonly resourcePath: unknown;
  readonly url: unknown;
}

interface CommitCommentSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Identifies the comment body.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the commit associated with the comment, if the commit exists.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  readonly isMinimized: () => Field<"isMinimized">;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Returns why the comment was minimized.
   */

  readonly minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Identifies the file path associated with the comment.
   */

  readonly path: () => Field<"path">;

  /**
   * @description Identifies the line position associated with the comment.
   */

  readonly position: () => Field<"position">;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path permalink for this commit comment.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL permalink for this commit comment.
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  readonly viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  readonly viewerCanMinimize: () => Field<"viewerCanMinimize">;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isCommitComment = (
  object: Record<string, any>
): object is Partial<ICommitComment> => {
  return object.__typename === "CommitComment";
};

export const CommitComment: CommitCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Identifies the comment body.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the commit associated with the comment, if the commit exists.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Identifies the file path associated with the comment.
   */
  path: () => new Field("path"),

  /**
   * @description Identifies the line position associated with the comment.
   */
  position: () => new Field("position"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path permalink for this commit comment.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL permalink for this commit comment.
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface ICommitCommentConnection {
  readonly __typename: "CommitCommentConnection";
  readonly edges: ReadonlyArray<ICommitCommentEdge> | null;
  readonly nodes: ReadonlyArray<ICommitComment> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CommitCommentConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CommitCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CommitCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CommitCommentConnection: CommitCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CommitCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CommitComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICommitCommentEdge {
  readonly __typename: "CommitCommentEdge";
  readonly cursor: string;
  readonly node: ICommitComment | null;
}

interface CommitCommentEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CommitCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CommitCommentEdge: CommitCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CommitComment))
    ),
};

export interface ICommitCommentThread extends INode, IRepositoryNode {
  readonly __typename: "CommitCommentThread";
  readonly comments: ICommitCommentConnection;
  readonly commit: ICommit | null;
  readonly path: string | null;
  readonly position: number | null;
}

interface CommitCommentThreadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The comments that exist in this thread.
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The commit the comments were made on.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The file the comments were made on.
   */

  readonly path: () => Field<"path">;

  /**
   * @description The position in the diff for the commit that the comment was made on.
   */

  readonly position: () => Field<"position">;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isCommitCommentThread = (
  object: Record<string, any>
): object is Partial<ICommitCommentThread> => {
  return object.__typename === "CommitCommentThread";
};

export const CommitCommentThread: CommitCommentThreadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The comments that exist in this thread.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description The commit the comments were made on.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  id: () => new Field("id"),

  /**
   * @description The file the comments were made on.
   */
  path: () => new Field("path"),

  /**
   * @description The position in the diff for the commit that the comment was made on.
   */
  position: () => new Field("position"),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ICommitConnection {
  readonly __typename: "CommitConnection";
  readonly edges: ReadonlyArray<ICommitEdge> | null;
  readonly nodes: ReadonlyArray<ICommit> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CommitConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CommitEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CommitConnection: CommitConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CommitEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICommitContributionsByRepository {
  readonly __typename: "CommitContributionsByRepository";
  readonly contributions: ICreatedCommitContributionConnection;
  readonly repository: IRepository;
  readonly resourcePath: unknown;
  readonly url: unknown;
}

interface CommitContributionsByRepositorySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The commit contributions, each representing a day.
   */

  readonly contributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | CommitContributionOrder;
    },
    select: (t: CreatedCommitContributionConnectionSelector) => T
  ) => Field<
    "contributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | CommitContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository in which the commits were made.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for the user's commits to the repository in this time range.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for the user's commits to the repository in this time range.
   */

  readonly url: () => Field<"url">;
}

export const CommitContributionsByRepository: CommitContributionsByRepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The commit contributions, each representing a day.
   */

  contributions: (variables, select) =>
    new Field(
      "contributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedCommitContributionConnection))
    ),

  /**
   * @description The repository in which the commits were made.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for the user's commits to the repository in this time range.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for the user's commits to the repository in this time range.
   */
  url: () => new Field("url"),
};

export interface ICommitEdge {
  readonly __typename: "CommitEdge";
  readonly cursor: string;
  readonly node: ICommit | null;
}

interface CommitEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CommitEdge: CommitEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Commit))),
};

export interface ICommitHistoryConnection {
  readonly __typename: "CommitHistoryConnection";
  readonly edges: ReadonlyArray<ICommitEdge> | null;
  readonly nodes: ReadonlyArray<ICommit> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CommitHistoryConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CommitEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CommitHistoryConnection: CommitHistoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CommitEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IConnectedEvent extends INode {
  readonly __typename: "ConnectedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly isCrossRepository: boolean;
  readonly source: IReferencedSubject;
  readonly subject: IReferencedSubject;
}

interface ConnectedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Reference originated in a different repository.
   */

  readonly isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Issue or pull request that made the reference.
   */

  readonly source: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"source", never, SelectionSet<T>>;

  /**
   * @description Issue or pull request which was connected.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isConnectedEvent = (
  object: Record<string, any>
): object is Partial<IConnectedEvent> => {
  return object.__typename === "ConnectedEvent";
};

export const ConnectedEvent: ConnectedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reference originated in a different repository.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Issue or pull request that made the reference.
   */

  source: (select) =>
    new Field(
      "source",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),

  /**
   * @description Issue or pull request which was connected.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),
};

export interface IContribution {
  readonly __typename: string;
  readonly isRestricted: boolean;
  readonly occurredAt: unknown;
  readonly resourcePath: unknown;
  readonly url: unknown;
  readonly user: IUser;
}

interface ContributionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  readonly isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  readonly occurredAt: () => Field<"occurredAt">;

  /**
   * @description The HTTP path for this contribution.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "CreatedCommitContribution"
      | "CreatedIssueContribution"
      | "CreatedPullRequestContribution"
      | "CreatedPullRequestReviewContribution"
      | "CreatedRepositoryContribution"
      | "JoinedGitHubContribution"
      | "RestrictedContribution"
  >(
    type: F,
    select: (
      t: F extends "CreatedCommitContribution"
        ? CreatedCommitContributionSelector
        : F extends "CreatedIssueContribution"
        ? CreatedIssueContributionSelector
        : F extends "CreatedPullRequestContribution"
        ? CreatedPullRequestContributionSelector
        : F extends "CreatedPullRequestReviewContribution"
        ? CreatedPullRequestReviewContributionSelector
        : F extends "CreatedRepositoryContribution"
        ? CreatedRepositoryContributionSelector
        : F extends "JoinedGitHubContribution"
        ? JoinedGitHubContributionSelector
        : F extends "RestrictedContribution"
        ? RestrictedContributionSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Contribution: ContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  on: (type, select) => {
    switch (type) {
      case "CreatedCommitContribution": {
        return new InlineFragment(
          new NamedType("CreatedCommitContribution") as any,
          new SelectionSet(select(CreatedCommitContribution as any))
        );
      }

      case "CreatedIssueContribution": {
        return new InlineFragment(
          new NamedType("CreatedIssueContribution") as any,
          new SelectionSet(select(CreatedIssueContribution as any))
        );
      }

      case "CreatedPullRequestContribution": {
        return new InlineFragment(
          new NamedType("CreatedPullRequestContribution") as any,
          new SelectionSet(select(CreatedPullRequestContribution as any))
        );
      }

      case "CreatedPullRequestReviewContribution": {
        return new InlineFragment(
          new NamedType("CreatedPullRequestReviewContribution") as any,
          new SelectionSet(select(CreatedPullRequestReviewContribution as any))
        );
      }

      case "CreatedRepositoryContribution": {
        return new InlineFragment(
          new NamedType("CreatedRepositoryContribution") as any,
          new SelectionSet(select(CreatedRepositoryContribution as any))
        );
      }

      case "JoinedGitHubContribution": {
        return new InlineFragment(
          new NamedType("JoinedGitHubContribution") as any,
          new SelectionSet(select(JoinedGitHubContribution as any))
        );
      }

      case "RestrictedContribution": {
        return new InlineFragment(
          new NamedType("RestrictedContribution") as any,
          new SelectionSet(select(RestrictedContribution as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Contribution",
        });
    }
  },
};

export interface IContributionCalendar {
  readonly __typename: "ContributionCalendar";
  readonly colors: ReadonlyArray<string>;
  readonly isHalloween: boolean;
  readonly months: ReadonlyArray<IContributionCalendarMonth>;
  readonly totalContributions: number;
  readonly weeks: ReadonlyArray<IContributionCalendarWeek>;
}

interface ContributionCalendarSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of hex color codes used in this calendar. The darker the color, the more contributions it represents.
   */

  readonly colors: () => Field<"colors">;

  /**
   * @description Determine if the color set was chosen because it's currently Halloween.
   */

  readonly isHalloween: () => Field<"isHalloween">;

  /**
   * @description A list of the months of contributions in this calendar.
   */

  readonly months: <T extends Array<Selection>>(
    select: (t: ContributionCalendarMonthSelector) => T
  ) => Field<"months", never, SelectionSet<T>>;

  /**
   * @description The count of total contributions in the calendar.
   */

  readonly totalContributions: () => Field<"totalContributions">;

  /**
   * @description A list of the weeks of contributions in this calendar.
   */

  readonly weeks: <T extends Array<Selection>>(
    select: (t: ContributionCalendarWeekSelector) => T
  ) => Field<"weeks", never, SelectionSet<T>>;
}

export const ContributionCalendar: ContributionCalendarSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of hex color codes used in this calendar. The darker the color, the more contributions it represents.
   */
  colors: () => new Field("colors"),

  /**
   * @description Determine if the color set was chosen because it's currently Halloween.
   */
  isHalloween: () => new Field("isHalloween"),

  /**
   * @description A list of the months of contributions in this calendar.
   */

  months: (select) =>
    new Field(
      "months",
      undefined as never,
      new SelectionSet(select(ContributionCalendarMonth))
    ),

  /**
   * @description The count of total contributions in the calendar.
   */
  totalContributions: () => new Field("totalContributions"),

  /**
   * @description A list of the weeks of contributions in this calendar.
   */

  weeks: (select) =>
    new Field(
      "weeks",
      undefined as never,
      new SelectionSet(select(ContributionCalendarWeek))
    ),
};

export interface IContributionCalendarDay {
  readonly __typename: "ContributionCalendarDay";
  readonly color: string;
  readonly contributionCount: number;
  readonly date: unknown;
  readonly weekday: number;
}

interface ContributionCalendarDaySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The hex color code that represents how many contributions were made on this day compared to others in the calendar.
   */

  readonly color: () => Field<"color">;

  /**
   * @description How many contributions were made by the user on this day.
   */

  readonly contributionCount: () => Field<"contributionCount">;

  /**
   * @description The day this square represents.
   */

  readonly date: () => Field<"date">;

  /**
   * @description A number representing which day of the week this square represents, e.g., 1 is Monday.
   */

  readonly weekday: () => Field<"weekday">;
}

export const ContributionCalendarDay: ContributionCalendarDaySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The hex color code that represents how many contributions were made on this day compared to others in the calendar.
   */
  color: () => new Field("color"),

  /**
   * @description How many contributions were made by the user on this day.
   */
  contributionCount: () => new Field("contributionCount"),

  /**
   * @description The day this square represents.
   */
  date: () => new Field("date"),

  /**
   * @description A number representing which day of the week this square represents, e.g., 1 is Monday.
   */
  weekday: () => new Field("weekday"),
};

export interface IContributionCalendarMonth {
  readonly __typename: "ContributionCalendarMonth";
  readonly firstDay: unknown;
  readonly name: string;
  readonly totalWeeks: number;
  readonly year: number;
}

interface ContributionCalendarMonthSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The date of the first day of this month.
   */

  readonly firstDay: () => Field<"firstDay">;

  /**
   * @description The name of the month.
   */

  readonly name: () => Field<"name">;

  /**
   * @description How many weeks started in this month.
   */

  readonly totalWeeks: () => Field<"totalWeeks">;

  /**
   * @description The year the month occurred in.
   */

  readonly year: () => Field<"year">;
}

export const ContributionCalendarMonth: ContributionCalendarMonthSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The date of the first day of this month.
   */
  firstDay: () => new Field("firstDay"),

  /**
   * @description The name of the month.
   */
  name: () => new Field("name"),

  /**
   * @description How many weeks started in this month.
   */
  totalWeeks: () => new Field("totalWeeks"),

  /**
   * @description The year the month occurred in.
   */
  year: () => new Field("year"),
};

export interface IContributionCalendarWeek {
  readonly __typename: "ContributionCalendarWeek";
  readonly contributionDays: ReadonlyArray<IContributionCalendarDay>;
  readonly firstDay: unknown;
}

interface ContributionCalendarWeekSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The days of contributions in this week.
   */

  readonly contributionDays: <T extends Array<Selection>>(
    select: (t: ContributionCalendarDaySelector) => T
  ) => Field<"contributionDays", never, SelectionSet<T>>;

  /**
   * @description The date of the earliest square in this week.
   */

  readonly firstDay: () => Field<"firstDay">;
}

export const ContributionCalendarWeek: ContributionCalendarWeekSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The days of contributions in this week.
   */

  contributionDays: (select) =>
    new Field(
      "contributionDays",
      undefined as never,
      new SelectionSet(select(ContributionCalendarDay))
    ),

  /**
   * @description The date of the earliest square in this week.
   */
  firstDay: () => new Field("firstDay"),
};

export interface IContributionsCollection {
  readonly __typename: "ContributionsCollection";
  readonly commitContributionsByRepository: ReadonlyArray<ICommitContributionsByRepository>;
  readonly contributionCalendar: IContributionCalendar;
  readonly contributionYears: ReadonlyArray<number>;
  readonly doesEndInCurrentMonth: boolean;
  readonly earliestRestrictedContributionDate: unknown | null;
  readonly endedAt: unknown;
  readonly firstIssueContribution: ICreatedIssueOrRestrictedContribution | null;
  readonly firstPullRequestContribution: ICreatedPullRequestOrRestrictedContribution | null;
  readonly firstRepositoryContribution: ICreatedRepositoryOrRestrictedContribution | null;
  readonly hasActivityInThePast: boolean;
  readonly hasAnyContributions: boolean;
  readonly hasAnyRestrictedContributions: boolean;
  readonly isSingleDay: boolean;
  readonly issueContributions: ICreatedIssueContributionConnection;
  readonly issueContributionsByRepository: ReadonlyArray<IIssueContributionsByRepository>;
  readonly joinedGitHubContribution: IJoinedGitHubContribution | null;
  readonly latestRestrictedContributionDate: unknown | null;
  readonly mostRecentCollectionWithActivity: IContributionsCollection | null;
  readonly mostRecentCollectionWithoutActivity: IContributionsCollection | null;
  readonly popularIssueContribution: ICreatedIssueContribution | null;
  readonly popularPullRequestContribution: ICreatedPullRequestContribution | null;
  readonly pullRequestContributions: ICreatedPullRequestContributionConnection;
  readonly pullRequestContributionsByRepository: ReadonlyArray<IPullRequestContributionsByRepository>;
  readonly pullRequestReviewContributions: ICreatedPullRequestReviewContributionConnection;
  readonly pullRequestReviewContributionsByRepository: ReadonlyArray<IPullRequestReviewContributionsByRepository>;
  readonly repositoryContributions: ICreatedRepositoryContributionConnection;
  readonly restrictedContributionsCount: number;
  readonly startedAt: unknown;
  readonly totalCommitContributions: number;
  readonly totalIssueContributions: number;
  readonly totalPullRequestContributions: number;
  readonly totalPullRequestReviewContributions: number;
  readonly totalRepositoriesWithContributedCommits: number;
  readonly totalRepositoriesWithContributedIssues: number;
  readonly totalRepositoriesWithContributedPullRequestReviews: number;
  readonly totalRepositoriesWithContributedPullRequests: number;
  readonly totalRepositoryContributions: number;
  readonly user: IUser;
}

interface ContributionsCollectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Commit contributions made by the user, grouped by repository.
   */

  readonly commitContributionsByRepository: <T extends Array<Selection>>(
    variables: { maxRepositories?: Variable<"maxRepositories"> | number },
    select: (t: CommitContributionsByRepositorySelector) => T
  ) => Field<
    "commitContributionsByRepository",
    [Argument<"maxRepositories", Variable<"maxRepositories"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A calendar of this user's contributions on GitHub.
   */

  readonly contributionCalendar: <T extends Array<Selection>>(
    select: (t: ContributionCalendarSelector) => T
  ) => Field<"contributionCalendar", never, SelectionSet<T>>;

  /**
   * @description The years the user has been making contributions with the most recent year first.
   */

  readonly contributionYears: () => Field<"contributionYears">;

  /**
   * @description Determine if this collection's time span ends in the current month.
   */

  readonly doesEndInCurrentMonth: () => Field<"doesEndInCurrentMonth">;

  /**
     * @description The date of the first restricted contribution the user made in this time
period. Can only be non-null when the user has enabled private contribution counts.
     */

  readonly earliestRestrictedContributionDate: () => Field<"earliestRestrictedContributionDate">;

  /**
   * @description The ending date and time of this collection.
   */

  readonly endedAt: () => Field<"endedAt">;

  /**
     * @description The first issue the user opened on GitHub. This will be null if that issue was
opened outside the collection's time range and ignoreTimeRange is false. If
the issue is not visible but the user has opted to show private contributions,
a RestrictedContribution will be returned.
     */

  readonly firstIssueContribution: <T extends Array<Selection>>(
    select: (t: CreatedIssueOrRestrictedContributionSelector) => T
  ) => Field<"firstIssueContribution", never, SelectionSet<T>>;

  /**
     * @description The first pull request the user opened on GitHub. This will be null if that
pull request was opened outside the collection's time range and
ignoreTimeRange is not true. If the pull request is not visible but the user
has opted to show private contributions, a RestrictedContribution will be returned.
     */

  readonly firstPullRequestContribution: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestOrRestrictedContributionSelector) => T
  ) => Field<"firstPullRequestContribution", never, SelectionSet<T>>;

  /**
     * @description The first repository the user created on GitHub. This will be null if that
first repository was created outside the collection's time range and
ignoreTimeRange is false. If the repository is not visible, then a
RestrictedContribution is returned.
     */

  readonly firstRepositoryContribution: <T extends Array<Selection>>(
    select: (t: CreatedRepositoryOrRestrictedContributionSelector) => T
  ) => Field<"firstRepositoryContribution", never, SelectionSet<T>>;

  /**
   * @description Does the user have any more activity in the timeline that occurred prior to the collection's time range?
   */

  readonly hasActivityInThePast: () => Field<"hasActivityInThePast">;

  /**
   * @description Determine if there are any contributions in this collection.
   */

  readonly hasAnyContributions: () => Field<"hasAnyContributions">;

  /**
     * @description Determine if the user made any contributions in this time frame whose details
are not visible because they were made in a private repository. Can only be
true if the user enabled private contribution counts.
     */

  readonly hasAnyRestrictedContributions: () => Field<"hasAnyRestrictedContributions">;

  /**
   * @description Whether or not the collector's time span is all within the same day.
   */

  readonly isSingleDay: () => Field<"isSingleDay">;

  /**
   * @description A list of issues the user opened.
   */

  readonly issueContributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      excludePopular?: Variable<"excludePopular"> | boolean;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedIssueContributionConnectionSelector) => T
  ) => Field<
    "issueContributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Issue contributions made by the user, grouped by repository.
   */

  readonly issueContributionsByRepository: <T extends Array<Selection>>(
    variables: {
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      excludePopular?: Variable<"excludePopular"> | boolean;
      maxRepositories?: Variable<"maxRepositories"> | number;
    },
    select: (t: IssueContributionsByRepositorySelector) => T
  ) => Field<
    "issueContributionsByRepository",
    [
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>,
      Argument<"maxRepositories", Variable<"maxRepositories"> | number>
    ],
    SelectionSet<T>
  >;

  /**
     * @description When the user signed up for GitHub. This will be null if that sign up date
falls outside the collection's time range and ignoreTimeRange is false.
     */

  readonly joinedGitHubContribution: <T extends Array<Selection>>(
    select: (t: JoinedGitHubContributionSelector) => T
  ) => Field<"joinedGitHubContribution", never, SelectionSet<T>>;

  /**
     * @description The date of the most recent restricted contribution the user made in this time
period. Can only be non-null when the user has enabled private contribution counts.
     */

  readonly latestRestrictedContributionDate: () => Field<"latestRestrictedContributionDate">;

  /**
     * @description When this collection's time range does not include any activity from the user, use this
to get a different collection from an earlier time range that does have activity.
     */

  readonly mostRecentCollectionWithActivity: <T extends Array<Selection>>(
    select: (t: ContributionsCollectionSelector) => T
  ) => Field<"mostRecentCollectionWithActivity", never, SelectionSet<T>>;

  /**
     * @description Returns a different contributions collection from an earlier time range than this one
that does not have any contributions.
     */

  readonly mostRecentCollectionWithoutActivity: <T extends Array<Selection>>(
    select: (t: ContributionsCollectionSelector) => T
  ) => Field<"mostRecentCollectionWithoutActivity", never, SelectionSet<T>>;

  /**
     * @description The issue the user opened on GitHub that received the most comments in the specified
time frame.
     */

  readonly popularIssueContribution: <T extends Array<Selection>>(
    select: (t: CreatedIssueContributionSelector) => T
  ) => Field<"popularIssueContribution", never, SelectionSet<T>>;

  /**
     * @description The pull request the user opened on GitHub that received the most comments in the
specified time frame.
     */

  readonly popularPullRequestContribution: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestContributionSelector) => T
  ) => Field<"popularPullRequestContribution", never, SelectionSet<T>>;

  /**
   * @description Pull request contributions made by the user.
   */

  readonly pullRequestContributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      excludePopular?: Variable<"excludePopular"> | boolean;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedPullRequestContributionConnectionSelector) => T
  ) => Field<
    "pullRequestContributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Pull request contributions made by the user, grouped by repository.
   */

  readonly pullRequestContributionsByRepository: <T extends Array<Selection>>(
    variables: {
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      excludePopular?: Variable<"excludePopular"> | boolean;
      maxRepositories?: Variable<"maxRepositories"> | number;
    },
    select: (t: PullRequestContributionsByRepositorySelector) => T
  ) => Field<
    "pullRequestContributionsByRepository",
    [
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>,
      Argument<"maxRepositories", Variable<"maxRepositories"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Pull request review contributions made by the user.
   */

  readonly pullRequestReviewContributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedPullRequestReviewContributionConnectionSelector) => T
  ) => Field<
    "pullRequestReviewContributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Pull request review contributions made by the user, grouped by repository.
   */

  readonly pullRequestReviewContributionsByRepository: <
    T extends Array<Selection>
  >(
    variables: { maxRepositories?: Variable<"maxRepositories"> | number },
    select: (t: PullRequestReviewContributionsByRepositorySelector) => T
  ) => Field<
    "pullRequestReviewContributionsByRepository",
    [Argument<"maxRepositories", Variable<"maxRepositories"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories owned by the user that the user created in this time range.
   */

  readonly repositoryContributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedRepositoryContributionConnectionSelector) => T
  ) => Field<
    "repositoryContributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
     * @description A count of contributions made by the user that the viewer cannot access. Only
non-zero when the user has chosen to share their private contribution counts.
     */

  readonly restrictedContributionsCount: () => Field<"restrictedContributionsCount">;

  /**
   * @description The beginning date and time of this collection.
   */

  readonly startedAt: () => Field<"startedAt">;

  /**
   * @description How many commits were made by the user in this time span.
   */

  readonly totalCommitContributions: () => Field<"totalCommitContributions">;

  /**
   * @description How many issues the user opened.
   */

  readonly totalIssueContributions: (variables: {
    excludeFirst?: Variable<"excludeFirst"> | boolean;
    excludePopular?: Variable<"excludePopular"> | boolean;
  }) => Field<
    "totalIssueContributions",
    [
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>
    ]
  >;

  /**
   * @description How many pull requests the user opened.
   */

  readonly totalPullRequestContributions: (variables: {
    excludeFirst?: Variable<"excludeFirst"> | boolean;
    excludePopular?: Variable<"excludePopular"> | boolean;
  }) => Field<
    "totalPullRequestContributions",
    [
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>
    ]
  >;

  /**
   * @description How many pull request reviews the user left.
   */

  readonly totalPullRequestReviewContributions: () => Field<"totalPullRequestReviewContributions">;

  /**
   * @description How many different repositories the user committed to.
   */

  readonly totalRepositoriesWithContributedCommits: () => Field<"totalRepositoriesWithContributedCommits">;

  /**
   * @description How many different repositories the user opened issues in.
   */

  readonly totalRepositoriesWithContributedIssues: (variables: {
    excludeFirst?: Variable<"excludeFirst"> | boolean;
    excludePopular?: Variable<"excludePopular"> | boolean;
  }) => Field<
    "totalRepositoriesWithContributedIssues",
    [
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>
    ]
  >;

  /**
   * @description How many different repositories the user left pull request reviews in.
   */

  readonly totalRepositoriesWithContributedPullRequestReviews: () => Field<"totalRepositoriesWithContributedPullRequestReviews">;

  /**
   * @description How many different repositories the user opened pull requests in.
   */

  readonly totalRepositoriesWithContributedPullRequests: (variables: {
    excludeFirst?: Variable<"excludeFirst"> | boolean;
    excludePopular?: Variable<"excludePopular"> | boolean;
  }) => Field<
    "totalRepositoriesWithContributedPullRequests",
    [
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>
    ]
  >;

  /**
   * @description How many repositories the user created.
   */

  readonly totalRepositoryContributions: (variables: {
    excludeFirst?: Variable<"excludeFirst"> | boolean;
  }) => Field<
    "totalRepositoryContributions",
    [Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>]
  >;

  /**
   * @description The user who made the contributions in this collection.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const ContributionsCollection: ContributionsCollectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Commit contributions made by the user, grouped by repository.
   */

  commitContributionsByRepository: (variables, select) =>
    new Field(
      "commitContributionsByRepository",
      [new Argument("maxRepositories", variables.maxRepositories)],
      new SelectionSet(select(CommitContributionsByRepository))
    ),

  /**
   * @description A calendar of this user's contributions on GitHub.
   */

  contributionCalendar: (select) =>
    new Field(
      "contributionCalendar",
      undefined as never,
      new SelectionSet(select(ContributionCalendar))
    ),

  /**
   * @description The years the user has been making contributions with the most recent year first.
   */
  contributionYears: () => new Field("contributionYears"),

  /**
   * @description Determine if this collection's time span ends in the current month.
   */
  doesEndInCurrentMonth: () => new Field("doesEndInCurrentMonth"),

  /**
     * @description The date of the first restricted contribution the user made in this time
period. Can only be non-null when the user has enabled private contribution counts.
     */
  earliestRestrictedContributionDate: () =>
    new Field("earliestRestrictedContributionDate"),

  /**
   * @description The ending date and time of this collection.
   */
  endedAt: () => new Field("endedAt"),

  /**
     * @description The first issue the user opened on GitHub. This will be null if that issue was
opened outside the collection's time range and ignoreTimeRange is false. If
the issue is not visible but the user has opted to show private contributions,
a RestrictedContribution will be returned.
     */

  firstIssueContribution: (select) =>
    new Field(
      "firstIssueContribution",
      undefined as never,
      new SelectionSet(select(CreatedIssueOrRestrictedContribution))
    ),

  /**
     * @description The first pull request the user opened on GitHub. This will be null if that
pull request was opened outside the collection's time range and
ignoreTimeRange is not true. If the pull request is not visible but the user
has opted to show private contributions, a RestrictedContribution will be returned.
     */

  firstPullRequestContribution: (select) =>
    new Field(
      "firstPullRequestContribution",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestOrRestrictedContribution))
    ),

  /**
     * @description The first repository the user created on GitHub. This will be null if that
first repository was created outside the collection's time range and
ignoreTimeRange is false. If the repository is not visible, then a
RestrictedContribution is returned.
     */

  firstRepositoryContribution: (select) =>
    new Field(
      "firstRepositoryContribution",
      undefined as never,
      new SelectionSet(select(CreatedRepositoryOrRestrictedContribution))
    ),

  /**
   * @description Does the user have any more activity in the timeline that occurred prior to the collection's time range?
   */
  hasActivityInThePast: () => new Field("hasActivityInThePast"),

  /**
   * @description Determine if there are any contributions in this collection.
   */
  hasAnyContributions: () => new Field("hasAnyContributions"),

  /**
     * @description Determine if the user made any contributions in this time frame whose details
are not visible because they were made in a private repository. Can only be
true if the user enabled private contribution counts.
     */
  hasAnyRestrictedContributions: () =>
    new Field("hasAnyRestrictedContributions"),

  /**
   * @description Whether or not the collector's time span is all within the same day.
   */
  isSingleDay: () => new Field("isSingleDay"),

  /**
   * @description A list of issues the user opened.
   */

  issueContributions: (variables, select) =>
    new Field(
      "issueContributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("excludePopular", variables.excludePopular),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedIssueContributionConnection))
    ),

  /**
   * @description Issue contributions made by the user, grouped by repository.
   */

  issueContributionsByRepository: (variables, select) =>
    new Field(
      "issueContributionsByRepository",
      [
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("excludePopular", variables.excludePopular),
        new Argument("maxRepositories", variables.maxRepositories),
      ],
      new SelectionSet(select(IssueContributionsByRepository))
    ),

  /**
     * @description When the user signed up for GitHub. This will be null if that sign up date
falls outside the collection's time range and ignoreTimeRange is false.
     */

  joinedGitHubContribution: (select) =>
    new Field(
      "joinedGitHubContribution",
      undefined as never,
      new SelectionSet(select(JoinedGitHubContribution))
    ),

  /**
     * @description The date of the most recent restricted contribution the user made in this time
period. Can only be non-null when the user has enabled private contribution counts.
     */
  latestRestrictedContributionDate: () =>
    new Field("latestRestrictedContributionDate"),

  /**
     * @description When this collection's time range does not include any activity from the user, use this
to get a different collection from an earlier time range that does have activity.
     */

  mostRecentCollectionWithActivity: (select) =>
    new Field(
      "mostRecentCollectionWithActivity",
      undefined as never,
      new SelectionSet(select(ContributionsCollection))
    ),

  /**
     * @description Returns a different contributions collection from an earlier time range than this one
that does not have any contributions.
     */

  mostRecentCollectionWithoutActivity: (select) =>
    new Field(
      "mostRecentCollectionWithoutActivity",
      undefined as never,
      new SelectionSet(select(ContributionsCollection))
    ),

  /**
     * @description The issue the user opened on GitHub that received the most comments in the specified
time frame.
     */

  popularIssueContribution: (select) =>
    new Field(
      "popularIssueContribution",
      undefined as never,
      new SelectionSet(select(CreatedIssueContribution))
    ),

  /**
     * @description The pull request the user opened on GitHub that received the most comments in the
specified time frame.
     */

  popularPullRequestContribution: (select) =>
    new Field(
      "popularPullRequestContribution",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestContribution))
    ),

  /**
   * @description Pull request contributions made by the user.
   */

  pullRequestContributions: (variables, select) =>
    new Field(
      "pullRequestContributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("excludePopular", variables.excludePopular),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedPullRequestContributionConnection))
    ),

  /**
   * @description Pull request contributions made by the user, grouped by repository.
   */

  pullRequestContributionsByRepository: (variables, select) =>
    new Field(
      "pullRequestContributionsByRepository",
      [
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("excludePopular", variables.excludePopular),
        new Argument("maxRepositories", variables.maxRepositories),
      ],
      new SelectionSet(select(PullRequestContributionsByRepository))
    ),

  /**
   * @description Pull request review contributions made by the user.
   */

  pullRequestReviewContributions: (variables, select) =>
    new Field(
      "pullRequestReviewContributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedPullRequestReviewContributionConnection))
    ),

  /**
   * @description Pull request review contributions made by the user, grouped by repository.
   */

  pullRequestReviewContributionsByRepository: (variables, select) =>
    new Field(
      "pullRequestReviewContributionsByRepository",
      [new Argument("maxRepositories", variables.maxRepositories)],
      new SelectionSet(select(PullRequestReviewContributionsByRepository))
    ),

  /**
   * @description A list of repositories owned by the user that the user created in this time range.
   */

  repositoryContributions: (variables, select) =>
    new Field(
      "repositoryContributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedRepositoryContributionConnection))
    ),

  /**
     * @description A count of contributions made by the user that the viewer cannot access. Only
non-zero when the user has chosen to share their private contribution counts.
     */
  restrictedContributionsCount: () => new Field("restrictedContributionsCount"),

  /**
   * @description The beginning date and time of this collection.
   */
  startedAt: () => new Field("startedAt"),

  /**
   * @description How many commits were made by the user in this time span.
   */
  totalCommitContributions: () => new Field("totalCommitContributions"),

  /**
   * @description How many issues the user opened.
   */
  totalIssueContributions: (variables) => new Field("totalIssueContributions"),

  /**
   * @description How many pull requests the user opened.
   */
  totalPullRequestContributions: (variables) =>
    new Field("totalPullRequestContributions"),

  /**
   * @description How many pull request reviews the user left.
   */
  totalPullRequestReviewContributions: () =>
    new Field("totalPullRequestReviewContributions"),

  /**
   * @description How many different repositories the user committed to.
   */
  totalRepositoriesWithContributedCommits: () =>
    new Field("totalRepositoriesWithContributedCommits"),

  /**
   * @description How many different repositories the user opened issues in.
   */
  totalRepositoriesWithContributedIssues: (variables) =>
    new Field("totalRepositoriesWithContributedIssues"),

  /**
   * @description How many different repositories the user left pull request reviews in.
   */
  totalRepositoriesWithContributedPullRequestReviews: () =>
    new Field("totalRepositoriesWithContributedPullRequestReviews"),

  /**
   * @description How many different repositories the user opened pull requests in.
   */
  totalRepositoriesWithContributedPullRequests: (variables) =>
    new Field("totalRepositoriesWithContributedPullRequests"),

  /**
   * @description How many repositories the user created.
   */
  totalRepositoryContributions: (variables) =>
    new Field("totalRepositoryContributions"),

  /**
   * @description The user who made the contributions in this collection.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IConvertProjectCardNoteToIssuePayload {
  readonly __typename: "ConvertProjectCardNoteToIssuePayload";
  readonly clientMutationId: string | null;
  readonly projectCard: IProjectCard | null;
}

interface ConvertProjectCardNoteToIssuePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated ProjectCard.
   */

  readonly projectCard: <T extends Array<Selection>>(
    select: (t: ProjectCardSelector) => T
  ) => Field<"projectCard", never, SelectionSet<T>>;
}

export const ConvertProjectCardNoteToIssuePayload: ConvertProjectCardNoteToIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated ProjectCard.
   */

  projectCard: (select) =>
    new Field(
      "projectCard",
      undefined as never,
      new SelectionSet(select(ProjectCard))
    ),
};

export interface IConvertToDraftEvent extends INode, IUniformResourceLocatable {
  readonly __typename: "ConvertToDraftEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly pullRequest: IPullRequest;
}

interface ConvertToDraftEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this convert to draft event.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this convert to draft event.
   */

  readonly url: () => Field<"url">;
}

export const isConvertToDraftEvent = (
  object: Record<string, any>
): object is Partial<IConvertToDraftEvent> => {
  return object.__typename === "ConvertToDraftEvent";
};

export const ConvertToDraftEvent: ConvertToDraftEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this convert to draft event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this convert to draft event.
   */
  url: () => new Field("url"),
};

export interface IConvertedNoteToIssueEvent extends INode {
  readonly __typename: "ConvertedNoteToIssueEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
}

interface ConvertedNoteToIssueEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;
}

export const isConvertedNoteToIssueEvent = (
  object: Record<string, any>
): object is Partial<IConvertedNoteToIssueEvent> => {
  return object.__typename === "ConvertedNoteToIssueEvent";
};

export const ConvertedNoteToIssueEvent: ConvertedNoteToIssueEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface ICreateBranchProtectionRulePayload {
  readonly __typename: "CreateBranchProtectionRulePayload";
  readonly branchProtectionRule: IBranchProtectionRule | null;
  readonly clientMutationId: string | null;
}

interface CreateBranchProtectionRulePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The newly created BranchProtectionRule.
   */

  readonly branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const CreateBranchProtectionRulePayload: CreateBranchProtectionRulePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The newly created BranchProtectionRule.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface ICreateCheckRunPayload {
  readonly __typename: "CreateCheckRunPayload";
  readonly checkRun: ICheckRun | null;
  readonly clientMutationId: string | null;
}

interface CreateCheckRunPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The newly created check run.
   */

  readonly checkRun: <T extends Array<Selection>>(
    select: (t: CheckRunSelector) => T
  ) => Field<"checkRun", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const CreateCheckRunPayload: CreateCheckRunPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The newly created check run.
   */

  checkRun: (select) =>
    new Field(
      "checkRun",
      undefined as never,
      new SelectionSet(select(CheckRun))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface ICreateCheckSuitePayload {
  readonly __typename: "CreateCheckSuitePayload";
  readonly checkSuite: ICheckSuite | null;
  readonly clientMutationId: string | null;
}

interface CreateCheckSuitePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The newly created check suite.
   */

  readonly checkSuite: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"checkSuite", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const CreateCheckSuitePayload: CreateCheckSuitePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The newly created check suite.
   */

  checkSuite: (select) =>
    new Field(
      "checkSuite",
      undefined as never,
      new SelectionSet(select(CheckSuite))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface ICreateEnterpriseOrganizationPayload {
  readonly __typename: "CreateEnterpriseOrganizationPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly organization: IOrganization | null;
}

interface CreateEnterpriseOrganizationPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise that owns the created organization.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description The organization that was created.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;
}

export const CreateEnterpriseOrganizationPayload: CreateEnterpriseOrganizationPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise that owns the created organization.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description The organization that was created.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),
};

export interface ICreateIpAllowListEntryPayload {
  readonly __typename: "CreateIpAllowListEntryPayload";
  readonly clientMutationId: string | null;
  readonly ipAllowListEntry: IIpAllowListEntry | null;
}

interface CreateIpAllowListEntryPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The IP allow list entry that was created.
   */

  readonly ipAllowListEntry: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"ipAllowListEntry", never, SelectionSet<T>>;
}

export const CreateIpAllowListEntryPayload: CreateIpAllowListEntryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The IP allow list entry that was created.
   */

  ipAllowListEntry: (select) =>
    new Field(
      "ipAllowListEntry",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),
};

export interface ICreateIssuePayload {
  readonly __typename: "CreateIssuePayload";
  readonly clientMutationId: string | null;
  readonly issue: IIssue | null;
}

interface CreateIssuePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new issue.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const CreateIssuePayload: CreateIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new issue.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface ICreateProjectPayload {
  readonly __typename: "CreateProjectPayload";
  readonly clientMutationId: string | null;
  readonly project: IProject | null;
}

interface CreateProjectPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new project.
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const CreateProjectPayload: CreateProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface ICreatePullRequestPayload {
  readonly __typename: "CreatePullRequestPayload";
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
}

interface CreatePullRequestPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new pull request.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const CreatePullRequestPayload: CreatePullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new pull request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface ICreateRefPayload {
  readonly __typename: "CreateRefPayload";
  readonly clientMutationId: string | null;
  readonly ref: IRef | null;
}

interface CreateRefPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The newly created ref.
   */

  readonly ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const CreateRefPayload: CreateRefPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The newly created ref.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface ICreateRepositoryPayload {
  readonly __typename: "CreateRepositoryPayload";
  readonly clientMutationId: string | null;
  readonly repository: IRepository | null;
}

interface CreateRepositoryPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new repository.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const CreateRepositoryPayload: CreateRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ICreateTeamDiscussionCommentPayload {
  readonly __typename: "CreateTeamDiscussionCommentPayload";
  readonly clientMutationId: string | null;
  readonly teamDiscussionComment: ITeamDiscussionComment | null;
}

interface CreateTeamDiscussionCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new comment.
   */

  readonly teamDiscussionComment: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentSelector) => T
  ) => Field<"teamDiscussionComment", never, SelectionSet<T>>;
}

export const CreateTeamDiscussionCommentPayload: CreateTeamDiscussionCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new comment.
   */

  teamDiscussionComment: (select) =>
    new Field(
      "teamDiscussionComment",
      undefined as never,
      new SelectionSet(select(TeamDiscussionComment))
    ),
};

export interface ICreateTeamDiscussionPayload {
  readonly __typename: "CreateTeamDiscussionPayload";
  readonly clientMutationId: string | null;
  readonly teamDiscussion: ITeamDiscussion | null;
}

interface CreateTeamDiscussionPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new discussion.
   */

  readonly teamDiscussion: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"teamDiscussion", never, SelectionSet<T>>;
}

export const CreateTeamDiscussionPayload: CreateTeamDiscussionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new discussion.
   */

  teamDiscussion: (select) =>
    new Field(
      "teamDiscussion",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),
};

export interface ICreatedCommitContribution extends IContribution {
  readonly __typename: "CreatedCommitContribution";
  readonly commitCount: number;
  readonly repository: IRepository;
}

interface CreatedCommitContributionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description How many commits were made on this day to this repository by the user.
   */

  readonly commitCount: () => Field<"commitCount">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  readonly isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  readonly occurredAt: () => Field<"occurredAt">;

  /**
   * @description The repository the user made a commit in.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this contribution.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedCommitContribution = (
  object: Record<string, any>
): object is Partial<ICreatedCommitContribution> => {
  return object.__typename === "CreatedCommitContribution";
};

export const CreatedCommitContribution: CreatedCommitContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description How many commits were made on this day to this repository by the user.
   */
  commitCount: () => new Field("commitCount"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The repository the user made a commit in.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedCommitContributionConnection {
  readonly __typename: "CreatedCommitContributionConnection";
  readonly edges: ReadonlyArray<ICreatedCommitContributionEdge> | null;
  readonly nodes: ReadonlyArray<ICreatedCommitContribution> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CreatedCommitContributionConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CreatedCommitContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CreatedCommitContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of commits across days and repositories in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CreatedCommitContributionConnection: CreatedCommitContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedCommitContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedCommitContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of commits across days and repositories in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedCommitContributionEdge {
  readonly __typename: "CreatedCommitContributionEdge";
  readonly cursor: string;
  readonly node: ICreatedCommitContribution | null;
}

interface CreatedCommitContributionEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CreatedCommitContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedCommitContributionEdge: CreatedCommitContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedCommitContribution))
    ),
};

export interface ICreatedIssueContribution extends IContribution {
  readonly __typename: "CreatedIssueContribution";
  readonly issue: IIssue;
}

interface CreatedIssueContributionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  readonly isRestricted: () => Field<"isRestricted">;

  /**
   * @description The issue that was opened.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;

  /**
   * @description When this contribution was made.
   */

  readonly occurredAt: () => Field<"occurredAt">;

  /**
   * @description The HTTP path for this contribution.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedIssueContribution = (
  object: Record<string, any>
): object is Partial<ICreatedIssueContribution> => {
  return object.__typename === "CreatedIssueContribution";
};

export const CreatedIssueContribution: CreatedIssueContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description The issue that was opened.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedIssueContributionConnection {
  readonly __typename: "CreatedIssueContributionConnection";
  readonly edges: ReadonlyArray<ICreatedIssueContributionEdge> | null;
  readonly nodes: ReadonlyArray<ICreatedIssueContribution> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CreatedIssueContributionConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CreatedIssueContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CreatedIssueContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CreatedIssueContributionConnection: CreatedIssueContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedIssueContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedIssueContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedIssueContributionEdge {
  readonly __typename: "CreatedIssueContributionEdge";
  readonly cursor: string;
  readonly node: ICreatedIssueContribution | null;
}

interface CreatedIssueContributionEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CreatedIssueContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedIssueContributionEdge: CreatedIssueContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedIssueContribution))
    ),
};

export interface ICreatedPullRequestContribution extends IContribution {
  readonly __typename: "CreatedPullRequestContribution";
  readonly pullRequest: IPullRequest;
}

interface CreatedPullRequestContributionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  readonly isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  readonly occurredAt: () => Field<"occurredAt">;

  /**
   * @description The pull request that was opened.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this contribution.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedPullRequestContribution = (
  object: Record<string, any>
): object is Partial<ICreatedPullRequestContribution> => {
  return object.__typename === "CreatedPullRequestContribution";
};

export const CreatedPullRequestContribution: CreatedPullRequestContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The pull request that was opened.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedPullRequestContributionConnection {
  readonly __typename: "CreatedPullRequestContributionConnection";
  readonly edges: ReadonlyArray<ICreatedPullRequestContributionEdge> | null;
  readonly nodes: ReadonlyArray<ICreatedPullRequestContribution> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CreatedPullRequestContributionConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CreatedPullRequestContributionConnection: CreatedPullRequestContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedPullRequestContributionEdge {
  readonly __typename: "CreatedPullRequestContributionEdge";
  readonly cursor: string;
  readonly node: ICreatedPullRequestContribution | null;
}

interface CreatedPullRequestContributionEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedPullRequestContributionEdge: CreatedPullRequestContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestContribution))
    ),
};

export interface ICreatedPullRequestReviewContribution extends IContribution {
  readonly __typename: "CreatedPullRequestReviewContribution";
  readonly pullRequest: IPullRequest;
  readonly pullRequestReview: IPullRequestReview;
  readonly repository: IRepository;
}

interface CreatedPullRequestReviewContributionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  readonly isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  readonly occurredAt: () => Field<"occurredAt">;

  /**
   * @description The pull request the user reviewed.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The review the user left on the pull request.
   */

  readonly pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;

  /**
   * @description The repository containing the pull request that the user reviewed.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this contribution.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedPullRequestReviewContribution = (
  object: Record<string, any>
): object is Partial<ICreatedPullRequestReviewContribution> => {
  return object.__typename === "CreatedPullRequestReviewContribution";
};

export const CreatedPullRequestReviewContribution: CreatedPullRequestReviewContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The pull request the user reviewed.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The review the user left on the pull request.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description The repository containing the pull request that the user reviewed.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedPullRequestReviewContributionConnection {
  readonly __typename: "CreatedPullRequestReviewContributionConnection";
  readonly edges: ReadonlyArray<ICreatedPullRequestReviewContributionEdge> | null;
  readonly nodes: ReadonlyArray<ICreatedPullRequestReviewContribution> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CreatedPullRequestReviewContributionConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestReviewContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestReviewContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CreatedPullRequestReviewContributionConnection: CreatedPullRequestReviewContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestReviewContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestReviewContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedPullRequestReviewContributionEdge {
  readonly __typename: "CreatedPullRequestReviewContributionEdge";
  readonly cursor: string;
  readonly node: ICreatedPullRequestReviewContribution | null;
}

interface CreatedPullRequestReviewContributionEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestReviewContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedPullRequestReviewContributionEdge: CreatedPullRequestReviewContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestReviewContribution))
    ),
};

export interface ICreatedRepositoryContribution extends IContribution {
  readonly __typename: "CreatedRepositoryContribution";
  readonly repository: IRepository;
}

interface CreatedRepositoryContributionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  readonly isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  readonly occurredAt: () => Field<"occurredAt">;

  /**
   * @description The repository that was created.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this contribution.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedRepositoryContribution = (
  object: Record<string, any>
): object is Partial<ICreatedRepositoryContribution> => {
  return object.__typename === "CreatedRepositoryContribution";
};

export const CreatedRepositoryContribution: CreatedRepositoryContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The repository that was created.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedRepositoryContributionConnection {
  readonly __typename: "CreatedRepositoryContributionConnection";
  readonly edges: ReadonlyArray<ICreatedRepositoryContributionEdge> | null;
  readonly nodes: ReadonlyArray<ICreatedRepositoryContribution> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface CreatedRepositoryContributionConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: CreatedRepositoryContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: CreatedRepositoryContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const CreatedRepositoryContributionConnection: CreatedRepositoryContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedRepositoryContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedRepositoryContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedRepositoryContributionEdge {
  readonly __typename: "CreatedRepositoryContributionEdge";
  readonly cursor: string;
  readonly node: ICreatedRepositoryContribution | null;
}

interface CreatedRepositoryContributionEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: CreatedRepositoryContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedRepositoryContributionEdge: CreatedRepositoryContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedRepositoryContribution))
    ),
};

export interface ICrossReferencedEvent
  extends INode,
    IUniformResourceLocatable {
  readonly __typename: "CrossReferencedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly isCrossRepository: boolean;
  readonly referencedAt: unknown;
  readonly source: IReferencedSubject;
  readonly target: IReferencedSubject;
  readonly willCloseTarget: boolean;
}

interface CrossReferencedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Reference originated in a different repository.
   */

  readonly isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Identifies when the reference was made.
   */

  readonly referencedAt: () => Field<"referencedAt">;

  /**
   * @description The HTTP path for this pull request.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Issue or pull request that made the reference.
   */

  readonly source: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"source", never, SelectionSet<T>>;

  /**
   * @description Issue or pull request to which the reference was made.
   */

  readonly target: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"target", never, SelectionSet<T>>;

  /**
   * @description The HTTP URL for this pull request.
   */

  readonly url: () => Field<"url">;

  /**
   * @description Checks if the target will be closed when the source is merged.
   */

  readonly willCloseTarget: () => Field<"willCloseTarget">;
}

export const isCrossReferencedEvent = (
  object: Record<string, any>
): object is Partial<ICrossReferencedEvent> => {
  return object.__typename === "CrossReferencedEvent";
};

export const CrossReferencedEvent: CrossReferencedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reference originated in a different repository.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Identifies when the reference was made.
   */
  referencedAt: () => new Field("referencedAt"),

  /**
   * @description The HTTP path for this pull request.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Issue or pull request that made the reference.
   */

  source: (select) =>
    new Field(
      "source",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),

  /**
   * @description Issue or pull request to which the reference was made.
   */

  target: (select) =>
    new Field(
      "target",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),

  /**
   * @description The HTTP URL for this pull request.
   */
  url: () => new Field("url"),

  /**
   * @description Checks if the target will be closed when the source is merged.
   */
  willCloseTarget: () => new Field("willCloseTarget"),
};

export interface IDeclineTopicSuggestionPayload {
  readonly __typename: "DeclineTopicSuggestionPayload";
  readonly clientMutationId: string | null;
  readonly topic: ITopic | null;
}

interface DeclineTopicSuggestionPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The declined topic.
   */

  readonly topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;
}

export const DeclineTopicSuggestionPayload: DeclineTopicSuggestionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The declined topic.
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),
};

export interface IDeletable {
  readonly __typename: string;
  readonly viewerCanDelete: boolean;
}

interface DeletableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Check if the current viewer can delete this object.
   */

  readonly viewerCanDelete: () => Field<"viewerCanDelete">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "IssueComment"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Deletable: DeletableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Deletable",
        });
    }
  },
};

export interface IDeleteBranchProtectionRulePayload {
  readonly __typename: "DeleteBranchProtectionRulePayload";
  readonly clientMutationId: string | null;
}

interface DeleteBranchProtectionRulePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteBranchProtectionRulePayload: DeleteBranchProtectionRulePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteDeploymentPayload {
  readonly __typename: "DeleteDeploymentPayload";
  readonly clientMutationId: string | null;
}

interface DeleteDeploymentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteDeploymentPayload: DeleteDeploymentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteIpAllowListEntryPayload {
  readonly __typename: "DeleteIpAllowListEntryPayload";
  readonly clientMutationId: string | null;
  readonly ipAllowListEntry: IIpAllowListEntry | null;
}

interface DeleteIpAllowListEntryPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The IP allow list entry that was deleted.
   */

  readonly ipAllowListEntry: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"ipAllowListEntry", never, SelectionSet<T>>;
}

export const DeleteIpAllowListEntryPayload: DeleteIpAllowListEntryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The IP allow list entry that was deleted.
   */

  ipAllowListEntry: (select) =>
    new Field(
      "ipAllowListEntry",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),
};

export interface IDeleteIssueCommentPayload {
  readonly __typename: "DeleteIssueCommentPayload";
  readonly clientMutationId: string | null;
}

interface DeleteIssueCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteIssueCommentPayload: DeleteIssueCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteIssuePayload {
  readonly __typename: "DeleteIssuePayload";
  readonly clientMutationId: string | null;
  readonly repository: IRepository | null;
}

interface DeleteIssuePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository the issue belonged to
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const DeleteIssuePayload: DeleteIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository the issue belonged to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IDeleteProjectCardPayload {
  readonly __typename: "DeleteProjectCardPayload";
  readonly clientMutationId: string | null;
  readonly column: IProjectColumn | null;
  readonly deletedCardId: string | null;
}

interface DeleteProjectCardPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The column the deleted card was in.
   */

  readonly column: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"column", never, SelectionSet<T>>;

  /**
   * @description The deleted card ID.
   */

  readonly deletedCardId: () => Field<"deletedCardId">;
}

export const DeleteProjectCardPayload: DeleteProjectCardPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The column the deleted card was in.
   */

  column: (select) =>
    new Field(
      "column",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),

  /**
   * @description The deleted card ID.
   */
  deletedCardId: () => new Field("deletedCardId"),
};

export interface IDeleteProjectColumnPayload {
  readonly __typename: "DeleteProjectColumnPayload";
  readonly clientMutationId: string | null;
  readonly deletedColumnId: string | null;
  readonly project: IProject | null;
}

interface DeleteProjectColumnPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The deleted column ID.
   */

  readonly deletedColumnId: () => Field<"deletedColumnId">;

  /**
   * @description The project the deleted column was in.
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const DeleteProjectColumnPayload: DeleteProjectColumnPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The deleted column ID.
   */
  deletedColumnId: () => new Field("deletedColumnId"),

  /**
   * @description The project the deleted column was in.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface IDeleteProjectPayload {
  readonly __typename: "DeleteProjectPayload";
  readonly clientMutationId: string | null;
  readonly owner: IProjectOwner | null;
}

interface DeleteProjectPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository or organization the project was removed from.
   */

  readonly owner: <T extends Array<Selection>>(
    select: (t: ProjectOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;
}

export const DeleteProjectPayload: DeleteProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository or organization the project was removed from.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(ProjectOwner))
    ),
};

export interface IDeletePullRequestReviewCommentPayload {
  readonly __typename: "DeletePullRequestReviewCommentPayload";
  readonly clientMutationId: string | null;
  readonly pullRequestReview: IPullRequestReview | null;
}

interface DeletePullRequestReviewCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request review the deleted comment belonged to.
   */

  readonly pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const DeletePullRequestReviewCommentPayload: DeletePullRequestReviewCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request review the deleted comment belonged to.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IDeletePullRequestReviewPayload {
  readonly __typename: "DeletePullRequestReviewPayload";
  readonly clientMutationId: string | null;
  readonly pullRequestReview: IPullRequestReview | null;
}

interface DeletePullRequestReviewPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The deleted pull request review.
   */

  readonly pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const DeletePullRequestReviewPayload: DeletePullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The deleted pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IDeleteRefPayload {
  readonly __typename: "DeleteRefPayload";
  readonly clientMutationId: string | null;
}

interface DeleteRefPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteRefPayload: DeleteRefPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteTeamDiscussionCommentPayload {
  readonly __typename: "DeleteTeamDiscussionCommentPayload";
  readonly clientMutationId: string | null;
}

interface DeleteTeamDiscussionCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteTeamDiscussionCommentPayload: DeleteTeamDiscussionCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteTeamDiscussionPayload {
  readonly __typename: "DeleteTeamDiscussionPayload";
  readonly clientMutationId: string | null;
}

interface DeleteTeamDiscussionPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteTeamDiscussionPayload: DeleteTeamDiscussionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDemilestonedEvent extends INode {
  readonly __typename: "DemilestonedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly milestoneTitle: string;
  readonly subject: IMilestoneItem;
}

interface DemilestonedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the milestone title associated with the 'demilestoned' event.
   */

  readonly milestoneTitle: () => Field<"milestoneTitle">;

  /**
   * @description Object referenced by event.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: MilestoneItemSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isDemilestonedEvent = (
  object: Record<string, any>
): object is Partial<IDemilestonedEvent> => {
  return object.__typename === "DemilestonedEvent";
};

export const DemilestonedEvent: DemilestonedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the milestone title associated with the 'demilestoned' event.
   */
  milestoneTitle: () => new Field("milestoneTitle"),

  /**
   * @description Object referenced by event.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(MilestoneItem))
    ),
};

export interface IDeployKey extends INode {
  readonly __typename: "DeployKey";
  readonly createdAt: unknown;
  readonly key: string;
  readonly readOnly: boolean;
  readonly title: string;
  readonly verified: boolean;
}

interface DeployKeySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The deploy key.
   */

  readonly key: () => Field<"key">;

  /**
   * @description Whether or not the deploy key is read only.
   */

  readonly readOnly: () => Field<"readOnly">;

  /**
   * @description The deploy key title.
   */

  readonly title: () => Field<"title">;

  /**
   * @description Whether or not the deploy key has been verified.
   */

  readonly verified: () => Field<"verified">;
}

export const isDeployKey = (
  object: Record<string, any>
): object is Partial<IDeployKey> => {
  return object.__typename === "DeployKey";
};

export const DeployKey: DeployKeySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The deploy key.
   */
  key: () => new Field("key"),

  /**
   * @description Whether or not the deploy key is read only.
   */
  readOnly: () => new Field("readOnly"),

  /**
   * @description The deploy key title.
   */
  title: () => new Field("title"),

  /**
   * @description Whether or not the deploy key has been verified.
   */
  verified: () => new Field("verified"),
};

export interface IDeployKeyConnection {
  readonly __typename: "DeployKeyConnection";
  readonly edges: ReadonlyArray<IDeployKeyEdge> | null;
  readonly nodes: ReadonlyArray<IDeployKey> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface DeployKeyConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: DeployKeyEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: DeployKeySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const DeployKeyConnection: DeployKeyConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(DeployKeyEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(DeployKey))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IDeployKeyEdge {
  readonly __typename: "DeployKeyEdge";
  readonly cursor: string;
  readonly node: IDeployKey | null;
}

interface DeployKeyEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: DeployKeySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const DeployKeyEdge: DeployKeyEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(DeployKey))),
};

export interface IDeployedEvent extends INode {
  readonly __typename: "DeployedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly deployment: IDeployment;
  readonly pullRequest: IPullRequest;
  readonly ref: IRef | null;
}

interface DeployedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The deployment associated with the 'deployed' event.
   */

  readonly deployment: <T extends Array<Selection>>(
    select: (t: DeploymentSelector) => T
  ) => Field<"deployment", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The ref associated with the 'deployed' event.
   */

  readonly ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const isDeployedEvent = (
  object: Record<string, any>
): object is Partial<IDeployedEvent> => {
  return object.__typename === "DeployedEvent";
};

export const DeployedEvent: DeployedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The deployment associated with the 'deployed' event.
   */

  deployment: (select) =>
    new Field(
      "deployment",
      undefined as never,
      new SelectionSet(select(Deployment))
    ),

  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The ref associated with the 'deployed' event.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IDeployment extends INode {
  readonly __typename: "Deployment";
  readonly commit: ICommit | null;
  readonly commitOid: string;
  readonly createdAt: unknown;
  readonly creator: IActor;
  readonly databaseId: number | null;
  readonly description: string | null;
  readonly environment: string | null;
  readonly latestEnvironment: string | null;
  readonly latestStatus: IDeploymentStatus | null;
  readonly originalEnvironment: string | null;
  readonly payload: string | null;
  readonly ref: IRef | null;
  readonly repository: IRepository;
  readonly state: DeploymentState | null;
  readonly statuses: IDeploymentStatusConnection | null;
  readonly task: string | null;
  readonly updatedAt: unknown;
}

interface DeploymentSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the commit sha of the deployment.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the oid of the deployment commit, even if the commit has been deleted.
   */

  readonly commitOid: () => Field<"commitOid">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the actor who triggered the deployment.
   */

  readonly creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The deployment description.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The latest environment to which this deployment was made.
   */

  readonly environment: () => Field<"environment">;

  readonly id: () => Field<"id">;

  /**
   * @description The latest environment to which this deployment was made.
   */

  readonly latestEnvironment: () => Field<"latestEnvironment">;

  /**
   * @description The latest status of this deployment.
   */

  readonly latestStatus: <T extends Array<Selection>>(
    select: (t: DeploymentStatusSelector) => T
  ) => Field<"latestStatus", never, SelectionSet<T>>;

  /**
   * @description The original environment to which this deployment was made.
   */

  readonly originalEnvironment: () => Field<"originalEnvironment">;

  /**
   * @description Extra information that a deployment system might need.
   */

  readonly payload: () => Field<"payload">;

  /**
   * @description Identifies the Ref of the deployment, if the deployment was created by ref.
   */

  readonly ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;

  /**
   * @description Identifies the repository associated with the deployment.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The current state of the deployment.
   */

  readonly state: () => Field<"state">;

  /**
   * @description A list of statuses associated with the deployment.
   */

  readonly statuses: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: DeploymentStatusConnectionSelector) => T
  ) => Field<
    "statuses",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The deployment task.
   */

  readonly task: () => Field<"task">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const isDeployment = (
  object: Record<string, any>
): object is Partial<IDeployment> => {
  return object.__typename === "Deployment";
};

export const Deployment: DeploymentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the commit sha of the deployment.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the oid of the deployment commit, even if the commit has been deleted.
   */
  commitOid: () => new Field("commitOid"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the actor who triggered the deployment.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The deployment description.
   */
  description: () => new Field("description"),

  /**
   * @description The latest environment to which this deployment was made.
   */
  environment: () => new Field("environment"),
  id: () => new Field("id"),

  /**
   * @description The latest environment to which this deployment was made.
   */
  latestEnvironment: () => new Field("latestEnvironment"),

  /**
   * @description The latest status of this deployment.
   */

  latestStatus: (select) =>
    new Field(
      "latestStatus",
      undefined as never,
      new SelectionSet(select(DeploymentStatus))
    ),

  /**
   * @description The original environment to which this deployment was made.
   */
  originalEnvironment: () => new Field("originalEnvironment"),

  /**
   * @description Extra information that a deployment system might need.
   */
  payload: () => new Field("payload"),

  /**
   * @description Identifies the Ref of the deployment, if the deployment was created by ref.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the repository associated with the deployment.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The current state of the deployment.
   */
  state: () => new Field("state"),

  /**
   * @description A list of statuses associated with the deployment.
   */

  statuses: (variables, select) =>
    new Field(
      "statuses",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(DeploymentStatusConnection))
    ),

  /**
   * @description The deployment task.
   */
  task: () => new Field("task"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IDeploymentConnection {
  readonly __typename: "DeploymentConnection";
  readonly edges: ReadonlyArray<IDeploymentEdge> | null;
  readonly nodes: ReadonlyArray<IDeployment> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface DeploymentConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: DeploymentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: DeploymentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const DeploymentConnection: DeploymentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(DeploymentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Deployment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IDeploymentEdge {
  readonly __typename: "DeploymentEdge";
  readonly cursor: string;
  readonly node: IDeployment | null;
}

interface DeploymentEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: DeploymentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const DeploymentEdge: DeploymentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Deployment))),
};

export interface IDeploymentEnvironmentChangedEvent extends INode {
  readonly __typename: "DeploymentEnvironmentChangedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly deploymentStatus: IDeploymentStatus;
  readonly pullRequest: IPullRequest;
}

interface DeploymentEnvironmentChangedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The deployment status that updated the deployment environment.
   */

  readonly deploymentStatus: <T extends Array<Selection>>(
    select: (t: DeploymentStatusSelector) => T
  ) => Field<"deploymentStatus", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isDeploymentEnvironmentChangedEvent = (
  object: Record<string, any>
): object is Partial<IDeploymentEnvironmentChangedEvent> => {
  return object.__typename === "DeploymentEnvironmentChangedEvent";
};

export const DeploymentEnvironmentChangedEvent: DeploymentEnvironmentChangedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The deployment status that updated the deployment environment.
   */

  deploymentStatus: (select) =>
    new Field(
      "deploymentStatus",
      undefined as never,
      new SelectionSet(select(DeploymentStatus))
    ),

  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IDeploymentStatus extends INode {
  readonly __typename: "DeploymentStatus";
  readonly createdAt: unknown;
  readonly creator: IActor;
  readonly deployment: IDeployment;
  readonly description: string | null;
  readonly environmentUrl: unknown | null;
  readonly logUrl: unknown | null;
  readonly state: DeploymentStatusState;
  readonly updatedAt: unknown;
}

interface DeploymentStatusSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the actor who triggered the deployment.
   */

  readonly creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the deployment associated with status.
   */

  readonly deployment: <T extends Array<Selection>>(
    select: (t: DeploymentSelector) => T
  ) => Field<"deployment", never, SelectionSet<T>>;

  /**
   * @description Identifies the description of the deployment.
   */

  readonly description: () => Field<"description">;

  /**
   * @description Identifies the environment URL of the deployment.
   */

  readonly environmentUrl: () => Field<"environmentUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the log URL of the deployment.
   */

  readonly logUrl: () => Field<"logUrl">;

  /**
   * @description Identifies the current state of the deployment.
   */

  readonly state: () => Field<"state">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const isDeploymentStatus = (
  object: Record<string, any>
): object is Partial<IDeploymentStatus> => {
  return object.__typename === "DeploymentStatus";
};

export const DeploymentStatus: DeploymentStatusSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the actor who triggered the deployment.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the deployment associated with status.
   */

  deployment: (select) =>
    new Field(
      "deployment",
      undefined as never,
      new SelectionSet(select(Deployment))
    ),

  /**
   * @description Identifies the description of the deployment.
   */
  description: () => new Field("description"),

  /**
   * @description Identifies the environment URL of the deployment.
   */
  environmentUrl: () => new Field("environmentUrl"),
  id: () => new Field("id"),

  /**
   * @description Identifies the log URL of the deployment.
   */
  logUrl: () => new Field("logUrl"),

  /**
   * @description Identifies the current state of the deployment.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IDeploymentStatusConnection {
  readonly __typename: "DeploymentStatusConnection";
  readonly edges: ReadonlyArray<IDeploymentStatusEdge> | null;
  readonly nodes: ReadonlyArray<IDeploymentStatus> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface DeploymentStatusConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: DeploymentStatusEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: DeploymentStatusSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const DeploymentStatusConnection: DeploymentStatusConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(DeploymentStatusEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(DeploymentStatus))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IDeploymentStatusEdge {
  readonly __typename: "DeploymentStatusEdge";
  readonly cursor: string;
  readonly node: IDeploymentStatus | null;
}

interface DeploymentStatusEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: DeploymentStatusSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const DeploymentStatusEdge: DeploymentStatusEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(DeploymentStatus))
    ),
};

export interface IDisconnectedEvent extends INode {
  readonly __typename: "DisconnectedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly isCrossRepository: boolean;
  readonly source: IReferencedSubject;
  readonly subject: IReferencedSubject;
}

interface DisconnectedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Reference originated in a different repository.
   */

  readonly isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Issue or pull request from which the issue was disconnected.
   */

  readonly source: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"source", never, SelectionSet<T>>;

  /**
   * @description Issue or pull request which was disconnected.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isDisconnectedEvent = (
  object: Record<string, any>
): object is Partial<IDisconnectedEvent> => {
  return object.__typename === "DisconnectedEvent";
};

export const DisconnectedEvent: DisconnectedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reference originated in a different repository.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Issue or pull request from which the issue was disconnected.
   */

  source: (select) =>
    new Field(
      "source",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),

  /**
   * @description Issue or pull request which was disconnected.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),
};

export interface IDismissPullRequestReviewPayload {
  readonly __typename: "DismissPullRequestReviewPayload";
  readonly clientMutationId: string | null;
  readonly pullRequestReview: IPullRequestReview | null;
}

interface DismissPullRequestReviewPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The dismissed pull request review.
   */

  readonly pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const DismissPullRequestReviewPayload: DismissPullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The dismissed pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IEnterprise extends INode {
  readonly __typename: "Enterprise";
  readonly avatarUrl: unknown;
  readonly billingInfo: IEnterpriseBillingInfo | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly description: string | null;
  readonly descriptionHTML: unknown;
  readonly location: string | null;
  readonly members: IEnterpriseMemberConnection;
  readonly name: string;
  readonly organizations: IOrganizationConnection;
  readonly ownerInfo: IEnterpriseOwnerInfo | null;
  readonly resourcePath: unknown;
  readonly slug: string;
  readonly url: unknown;
  readonly userAccounts: IEnterpriseUserAccountConnection;
  readonly viewerIsAdmin: boolean;
  readonly websiteUrl: unknown | null;
}

interface EnterpriseSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the enterprise's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description Enterprise billing information visible to enterprise billing managers.
   */

  readonly billingInfo: <T extends Array<Selection>>(
    select: (t: EnterpriseBillingInfoSelector) => T
  ) => Field<"billingInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The description of the enterprise.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The description of the enterprise as HTML.
   */

  readonly descriptionHTML: () => Field<"descriptionHTML">;

  readonly id: () => Field<"id">;

  /**
   * @description The location of the enterprise.
   */

  readonly location: () => Field<"location">;

  /**
   * @description A list of users who are members of this enterprise.
   */

  readonly members: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      deployment?: Variable<"deployment"> | EnterpriseUserDeployment;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseMemberOrder;
      organizationLogins?: Variable<"organizationLogins"> | string;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | EnterpriseUserAccountMembershipRole;
    },
    select: (t: EnterpriseMemberConnectionSelector) => T
  ) => Field<
    "members",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"deployment", Variable<"deployment"> | EnterpriseUserDeployment>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | EnterpriseMemberOrder>,
      Argument<"organizationLogins", Variable<"organizationLogins"> | string>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseUserAccountMembershipRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The name of the enterprise.
   */

  readonly name: () => Field<"name">;

  /**
   * @description A list of organizations that belong to this enterprise.
   */

  readonly organizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "organizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Enterprise information only visible to enterprise owners.
   */

  readonly ownerInfo: <T extends Array<Selection>>(
    select: (t: EnterpriseOwnerInfoSelector) => T
  ) => Field<"ownerInfo", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The URL-friendly identifier for the enterprise.
   */

  readonly slug: () => Field<"slug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of user accounts on this enterprise.
   */

  readonly userAccounts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: EnterpriseUserAccountConnectionSelector) => T
  ) => Field<
    "userAccounts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Is the current viewer an admin of this enterprise?
   */

  readonly viewerIsAdmin: () => Field<"viewerIsAdmin">;

  /**
   * @description The URL of the enterprise website.
   */

  readonly websiteUrl: () => Field<"websiteUrl">;
}

export const isEnterprise = (
  object: Record<string, any>
): object is Partial<IEnterprise> => {
  return object.__typename === "Enterprise";
};

export const Enterprise: EnterpriseSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the enterprise's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Enterprise billing information visible to enterprise billing managers.
   */

  billingInfo: (select) =>
    new Field(
      "billingInfo",
      undefined as never,
      new SelectionSet(select(EnterpriseBillingInfo))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The description of the enterprise.
   */
  description: () => new Field("description"),

  /**
   * @description The description of the enterprise as HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),
  id: () => new Field("id"),

  /**
   * @description The location of the enterprise.
   */
  location: () => new Field("location"),

  /**
   * @description A list of users who are members of this enterprise.
   */

  members: (variables, select) =>
    new Field(
      "members",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument(
          "deployment",
          variables.deployment,
          EnterpriseUserDeployment
        ),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("organizationLogins", variables.organizationLogins),
        new Argument("query", variables.query),
        new Argument(
          "role",
          variables.role,
          EnterpriseUserAccountMembershipRole
        ),
      ],
      new SelectionSet(select(EnterpriseMemberConnection))
    ),

  /**
   * @description The name of the enterprise.
   */
  name: () => new Field("name"),

  /**
   * @description A list of organizations that belong to this enterprise.
   */

  organizations: (variables, select) =>
    new Field(
      "organizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description Enterprise information only visible to enterprise owners.
   */

  ownerInfo: (select) =>
    new Field(
      "ownerInfo",
      undefined as never,
      new SelectionSet(select(EnterpriseOwnerInfo))
    ),

  /**
   * @description The HTTP path for this enterprise.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The URL-friendly identifier for the enterprise.
   */
  slug: () => new Field("slug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  url: () => new Field("url"),

  /**
   * @description A list of user accounts on this enterprise.
   */

  userAccounts: (variables, select) =>
    new Field(
      "userAccounts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(EnterpriseUserAccountConnection))
    ),

  /**
   * @description Is the current viewer an admin of this enterprise?
   */
  viewerIsAdmin: () => new Field("viewerIsAdmin"),

  /**
   * @description The URL of the enterprise website.
   */
  websiteUrl: () => new Field("websiteUrl"),
};

export interface IEnterpriseAdministratorConnection {
  readonly __typename: "EnterpriseAdministratorConnection";
  readonly edges: ReadonlyArray<IEnterpriseAdministratorEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseAdministratorConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseAdministratorConnection: EnterpriseAdministratorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseAdministratorEdge {
  readonly __typename: "EnterpriseAdministratorEdge";
  readonly cursor: string;
  readonly node: IUser | null;
  readonly role: EnterpriseAdministratorRole;
}

interface EnterpriseAdministratorEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The role of the administrator.
   */

  readonly role: () => Field<"role">;
}

export const EnterpriseAdministratorEdge: EnterpriseAdministratorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The role of the administrator.
   */
  role: () => new Field("role"),
};

export interface IEnterpriseAdministratorInvitation extends INode {
  readonly __typename: "EnterpriseAdministratorInvitation";
  readonly createdAt: unknown;
  readonly email: string | null;
  readonly enterprise: IEnterprise;
  readonly invitee: IUser | null;
  readonly inviter: IUser | null;
  readonly role: EnterpriseAdministratorRole;
}

interface EnterpriseAdministratorInvitationSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The email of the person who was invited to the enterprise.
   */

  readonly email: () => Field<"email">;

  /**
   * @description The enterprise the invitation is for.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The user who was invited to the enterprise.
   */

  readonly invitee: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"invitee", never, SelectionSet<T>>;

  /**
   * @description The user who created the invitation.
   */

  readonly inviter: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"inviter", never, SelectionSet<T>>;

  /**
   * @description The invitee's pending role in the enterprise (owner or billing_manager).
   */

  readonly role: () => Field<"role">;
}

export const isEnterpriseAdministratorInvitation = (
  object: Record<string, any>
): object is Partial<IEnterpriseAdministratorInvitation> => {
  return object.__typename === "EnterpriseAdministratorInvitation";
};

export const EnterpriseAdministratorInvitation: EnterpriseAdministratorInvitationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The email of the person who was invited to the enterprise.
   */
  email: () => new Field("email"),

  /**
   * @description The enterprise the invitation is for.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  id: () => new Field("id"),

  /**
   * @description The user who was invited to the enterprise.
   */

  invitee: (select) =>
    new Field("invitee", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The user who created the invitation.
   */

  inviter: (select) =>
    new Field("inviter", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The invitee's pending role in the enterprise (owner or billing_manager).
   */
  role: () => new Field("role"),
};

export interface IEnterpriseAdministratorInvitationConnection {
  readonly __typename: "EnterpriseAdministratorInvitationConnection";
  readonly edges: ReadonlyArray<IEnterpriseAdministratorInvitationEdge> | null;
  readonly nodes: ReadonlyArray<IEnterpriseAdministratorInvitation> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseAdministratorInvitationConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseAdministratorInvitationConnection: EnterpriseAdministratorInvitationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseAdministratorInvitationEdge {
  readonly __typename: "EnterpriseAdministratorInvitationEdge";
  readonly cursor: string;
  readonly node: IEnterpriseAdministratorInvitation | null;
}

interface EnterpriseAdministratorInvitationEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseAdministratorInvitationEdge: EnterpriseAdministratorInvitationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),
};

export interface IEnterpriseAuditEntryData {
  readonly __typename: string;
  readonly enterpriseResourcePath: unknown | null;
  readonly enterpriseSlug: string | null;
  readonly enterpriseUrl: unknown | null;
}

interface EnterpriseAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const EnterpriseAuditEntryData: EnterpriseAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),

  on: (type, select) => {
    switch (type) {
      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "EnterpriseAuditEntryData",
        });
    }
  },
};

export interface IEnterpriseBillingInfo {
  readonly __typename: "EnterpriseBillingInfo";
  readonly allLicensableUsersCount: number;
  readonly assetPacks: number;
  readonly availableSeats: number;
  readonly bandwidthQuota: number;
  readonly bandwidthUsage: number;
  readonly bandwidthUsagePercentage: number;
  readonly seats: number;
  readonly storageQuota: number;
  readonly storageUsage: number;
  readonly storageUsagePercentage: number;
  readonly totalAvailableLicenses: number;
  readonly totalLicenses: number;
}

interface EnterpriseBillingInfoSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The number of licenseable users/emails across the enterprise.
   */

  readonly allLicensableUsersCount: () => Field<"allLicensableUsersCount">;

  /**
   * @description The number of data packs used by all organizations owned by the enterprise.
   */

  readonly assetPacks: () => Field<"assetPacks">;

  /**
   * @description The number of available seats across all owned organizations based on the unique number of billable users.
   * @deprecated `availableSeats` will be replaced with `totalAvailableLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalAvailableLicenses instead. Removal on 2020-01-01 UTC.
   */

  readonly availableSeats: () => Field<"availableSeats">;

  /**
   * @description The bandwidth quota in GB for all organizations owned by the enterprise.
   */

  readonly bandwidthQuota: () => Field<"bandwidthQuota">;

  /**
   * @description The bandwidth usage in GB for all organizations owned by the enterprise.
   */

  readonly bandwidthUsage: () => Field<"bandwidthUsage">;

  /**
   * @description The bandwidth usage as a percentage of the bandwidth quota.
   */

  readonly bandwidthUsagePercentage: () => Field<"bandwidthUsagePercentage">;

  /**
   * @description The total seats across all organizations owned by the enterprise.
   * @deprecated `seats` will be replaced with `totalLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalLicenses instead. Removal on 2020-01-01 UTC.
   */

  readonly seats: () => Field<"seats">;

  /**
   * @description The storage quota in GB for all organizations owned by the enterprise.
   */

  readonly storageQuota: () => Field<"storageQuota">;

  /**
   * @description The storage usage in GB for all organizations owned by the enterprise.
   */

  readonly storageUsage: () => Field<"storageUsage">;

  /**
   * @description The storage usage as a percentage of the storage quota.
   */

  readonly storageUsagePercentage: () => Field<"storageUsagePercentage">;

  /**
   * @description The number of available licenses across all owned organizations based on the unique number of billable users.
   */

  readonly totalAvailableLicenses: () => Field<"totalAvailableLicenses">;

  /**
   * @description The total number of licenses allocated.
   */

  readonly totalLicenses: () => Field<"totalLicenses">;
}

export const EnterpriseBillingInfo: EnterpriseBillingInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The number of licenseable users/emails across the enterprise.
   */
  allLicensableUsersCount: () => new Field("allLicensableUsersCount"),

  /**
   * @description The number of data packs used by all organizations owned by the enterprise.
   */
  assetPacks: () => new Field("assetPacks"),

  /**
   * @description The number of available seats across all owned organizations based on the unique number of billable users.
   * @deprecated `availableSeats` will be replaced with `totalAvailableLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalAvailableLicenses instead. Removal on 2020-01-01 UTC.
   */
  availableSeats: () => new Field("availableSeats"),

  /**
   * @description The bandwidth quota in GB for all organizations owned by the enterprise.
   */
  bandwidthQuota: () => new Field("bandwidthQuota"),

  /**
   * @description The bandwidth usage in GB for all organizations owned by the enterprise.
   */
  bandwidthUsage: () => new Field("bandwidthUsage"),

  /**
   * @description The bandwidth usage as a percentage of the bandwidth quota.
   */
  bandwidthUsagePercentage: () => new Field("bandwidthUsagePercentage"),

  /**
   * @description The total seats across all organizations owned by the enterprise.
   * @deprecated `seats` will be replaced with `totalLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalLicenses instead. Removal on 2020-01-01 UTC.
   */
  seats: () => new Field("seats"),

  /**
   * @description The storage quota in GB for all organizations owned by the enterprise.
   */
  storageQuota: () => new Field("storageQuota"),

  /**
   * @description The storage usage in GB for all organizations owned by the enterprise.
   */
  storageUsage: () => new Field("storageUsage"),

  /**
   * @description The storage usage as a percentage of the storage quota.
   */
  storageUsagePercentage: () => new Field("storageUsagePercentage"),

  /**
   * @description The number of available licenses across all owned organizations based on the unique number of billable users.
   */
  totalAvailableLicenses: () => new Field("totalAvailableLicenses"),

  /**
   * @description The total number of licenses allocated.
   */
  totalLicenses: () => new Field("totalLicenses"),
};

export interface IEnterpriseIdentityProvider extends INode {
  readonly __typename: "EnterpriseIdentityProvider";
  readonly digestMethod: SamlDigestAlgorithm | null;
  readonly enterprise: IEnterprise | null;
  readonly externalIdentities: IExternalIdentityConnection;
  readonly idpCertificate: unknown | null;
  readonly issuer: string | null;
  readonly recoveryCodes: ReadonlyArray<string> | null;
  readonly signatureMethod: SamlSignatureAlgorithm | null;
  readonly ssoUrl: unknown | null;
}

interface EnterpriseIdentityProviderSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The digest algorithm used to sign SAML requests for the identity provider.
   */

  readonly digestMethod: () => Field<"digestMethod">;

  /**
   * @description The enterprise this identity provider belongs to.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description ExternalIdentities provisioned by this identity provider.
   */

  readonly externalIdentities: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ExternalIdentityConnectionSelector) => T
  ) => Field<
    "externalIdentities",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description The x509 certificate used by the identity provider to sign assertions and responses.
   */

  readonly idpCertificate: () => Field<"idpCertificate">;

  /**
   * @description The Issuer Entity ID for the SAML identity provider.
   */

  readonly issuer: () => Field<"issuer">;

  /**
   * @description Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable.
   */

  readonly recoveryCodes: () => Field<"recoveryCodes">;

  /**
   * @description The signature algorithm used to sign SAML requests for the identity provider.
   */

  readonly signatureMethod: () => Field<"signatureMethod">;

  /**
   * @description The URL endpoint for the identity provider's SAML SSO.
   */

  readonly ssoUrl: () => Field<"ssoUrl">;
}

export const isEnterpriseIdentityProvider = (
  object: Record<string, any>
): object is Partial<IEnterpriseIdentityProvider> => {
  return object.__typename === "EnterpriseIdentityProvider";
};

export const EnterpriseIdentityProvider: EnterpriseIdentityProviderSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The digest algorithm used to sign SAML requests for the identity provider.
   */
  digestMethod: () => new Field("digestMethod"),

  /**
   * @description The enterprise this identity provider belongs to.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description ExternalIdentities provisioned by this identity provider.
   */

  externalIdentities: (variables, select) =>
    new Field(
      "externalIdentities",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ExternalIdentityConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The x509 certificate used by the identity provider to sign assertions and responses.
   */
  idpCertificate: () => new Field("idpCertificate"),

  /**
   * @description The Issuer Entity ID for the SAML identity provider.
   */
  issuer: () => new Field("issuer"),

  /**
   * @description Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable.
   */
  recoveryCodes: () => new Field("recoveryCodes"),

  /**
   * @description The signature algorithm used to sign SAML requests for the identity provider.
   */
  signatureMethod: () => new Field("signatureMethod"),

  /**
   * @description The URL endpoint for the identity provider's SAML SSO.
   */
  ssoUrl: () => new Field("ssoUrl"),
};

export interface IEnterpriseMemberConnection {
  readonly __typename: "EnterpriseMemberConnection";
  readonly edges: ReadonlyArray<IEnterpriseMemberEdge> | null;
  readonly nodes: ReadonlyArray<IEnterpriseMember> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseMemberConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseMemberEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseMemberSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseMemberConnection: EnterpriseMemberConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseMemberEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseMember))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseMemberEdge {
  readonly __typename: "EnterpriseMemberEdge";
  readonly cursor: string;
  readonly isUnlicensed: boolean;
  readonly node: IEnterpriseMember | null;
}

interface EnterpriseMemberEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description Whether the user does not have a license for the enterprise.
   * @deprecated All members consume a license Removal on 2021-01-01 UTC.
   */

  readonly isUnlicensed: () => Field<"isUnlicensed">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: EnterpriseMemberSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseMemberEdge: EnterpriseMemberEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the user does not have a license for the enterprise.
   * @deprecated All members consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: () => new Field("isUnlicensed"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseMember))
    ),
};

export interface IEnterpriseOrganizationMembershipConnection {
  readonly __typename: "EnterpriseOrganizationMembershipConnection";
  readonly edges: ReadonlyArray<IEnterpriseOrganizationMembershipEdge> | null;
  readonly nodes: ReadonlyArray<IOrganization> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseOrganizationMembershipConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseOrganizationMembershipEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseOrganizationMembershipConnection: EnterpriseOrganizationMembershipConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseOrganizationMembershipEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseOrganizationMembershipEdge {
  readonly __typename: "EnterpriseOrganizationMembershipEdge";
  readonly cursor: string;
  readonly node: IOrganization | null;
  readonly role: EnterpriseUserAccountMembershipRole;
}

interface EnterpriseOrganizationMembershipEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The role of the user in the enterprise membership.
   */

  readonly role: () => Field<"role">;
}

export const EnterpriseOrganizationMembershipEdge: EnterpriseOrganizationMembershipEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The role of the user in the enterprise membership.
   */
  role: () => new Field("role"),
};

export interface IEnterpriseOutsideCollaboratorConnection {
  readonly __typename: "EnterpriseOutsideCollaboratorConnection";
  readonly edges: ReadonlyArray<IEnterpriseOutsideCollaboratorEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseOutsideCollaboratorConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseOutsideCollaboratorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseOutsideCollaboratorConnection: EnterpriseOutsideCollaboratorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseOutsideCollaboratorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseOutsideCollaboratorEdge {
  readonly __typename: "EnterpriseOutsideCollaboratorEdge";
  readonly cursor: string;
  readonly isUnlicensed: boolean;
  readonly node: IUser | null;
  readonly repositories: IEnterpriseRepositoryInfoConnection;
}

interface EnterpriseOutsideCollaboratorEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description Whether the outside collaborator does not have a license for the enterprise.
   * @deprecated All outside collaborators consume a license Removal on 2021-01-01 UTC.
   */

  readonly isUnlicensed: () => Field<"isUnlicensed">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The enterprise organization repositories this user is a member of.
   */

  readonly repositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
    },
    select: (t: EnterpriseRepositoryInfoConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>
    ],
    SelectionSet<T>
  >;
}

export const EnterpriseOutsideCollaboratorEdge: EnterpriseOutsideCollaboratorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the outside collaborator does not have a license for the enterprise.
   * @deprecated All outside collaborators consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: () => new Field("isUnlicensed"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The enterprise organization repositories this user is a member of.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseRepositoryInfoConnection))
    ),
};

export interface IEnterpriseOwnerInfo {
  readonly __typename: "EnterpriseOwnerInfo";
  readonly admins: IEnterpriseAdministratorConnection;
  readonly affiliatedUsersWithTwoFactorDisabled: IUserConnection;
  readonly affiliatedUsersWithTwoFactorDisabledExist: boolean;
  readonly allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue;
  readonly allowPrivateRepositoryForkingSettingOrganizations: IOrganizationConnection;
  readonly defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue;
  readonly defaultRepositoryPermissionSettingOrganizations: IOrganizationConnection;
  readonly enterpriseServerInstallations: IEnterpriseServerInstallationConnection;
  readonly ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  readonly ipAllowListEntries: IIpAllowListEntryConnection;
  readonly isUpdatingDefaultRepositoryPermission: boolean;
  readonly isUpdatingTwoFactorRequirement: boolean;
  readonly membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue;
  readonly membersCanChangeRepositoryVisibilitySettingOrganizations: IOrganizationConnection;
  readonly membersCanCreateInternalRepositoriesSetting: boolean | null;
  readonly membersCanCreatePrivateRepositoriesSetting: boolean | null;
  readonly membersCanCreatePublicRepositoriesSetting: boolean | null;
  readonly membersCanCreateRepositoriesSetting: EnterpriseMembersCanCreateRepositoriesSettingValue | null;
  readonly membersCanCreateRepositoriesSettingOrganizations: IOrganizationConnection;
  readonly membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue;
  readonly membersCanDeleteIssuesSettingOrganizations: IOrganizationConnection;
  readonly membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue;
  readonly membersCanDeleteRepositoriesSettingOrganizations: IOrganizationConnection;
  readonly membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue;
  readonly membersCanInviteCollaboratorsSettingOrganizations: IOrganizationConnection;
  readonly membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue;
  readonly membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue;
  readonly membersCanUpdateProtectedBranchesSettingOrganizations: IOrganizationConnection;
  readonly membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue;
  readonly membersCanViewDependencyInsightsSettingOrganizations: IOrganizationConnection;
  readonly organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  readonly organizationProjectsSettingOrganizations: IOrganizationConnection;
  readonly outsideCollaborators: IEnterpriseOutsideCollaboratorConnection;
  readonly pendingAdminInvitations: IEnterpriseAdministratorInvitationConnection;
  readonly pendingCollaboratorInvitations: IRepositoryInvitationConnection;
  readonly pendingCollaborators: IEnterprisePendingCollaboratorConnection;
  readonly pendingMemberInvitations: IEnterprisePendingMemberInvitationConnection;
  readonly repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  readonly repositoryProjectsSettingOrganizations: IOrganizationConnection;
  readonly samlIdentityProvider: IEnterpriseIdentityProvider | null;
  readonly samlIdentityProviderSettingOrganizations: IOrganizationConnection;
  readonly teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue;
  readonly teamDiscussionsSettingOrganizations: IOrganizationConnection;
  readonly twoFactorRequiredSetting: EnterpriseEnabledSettingValue;
  readonly twoFactorRequiredSettingOrganizations: IOrganizationConnection;
}

interface EnterpriseOwnerInfoSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of all of the administrators for this enterprise.
   */

  readonly admins: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseMemberOrder;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | EnterpriseAdministratorRole;
    },
    select: (t: EnterpriseAdministratorConnectionSelector) => T
  ) => Field<
    "admins",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | EnterpriseMemberOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseAdministratorRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users in the enterprise who currently have two-factor authentication disabled.
   */

  readonly affiliatedUsersWithTwoFactorDisabled: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "affiliatedUsersWithTwoFactorDisabled",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not affiliated users with two-factor authentication disabled exist in the enterprise.
   */

  readonly affiliatedUsersWithTwoFactorDisabledExist: () => Field<"affiliatedUsersWithTwoFactorDisabledExist">;

  /**
   * @description The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise.
   */

  readonly allowPrivateRepositoryForkingSetting: () => Field<"allowPrivateRepositoryForkingSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided private repository forking setting value.
   */

  readonly allowPrivateRepositoryForkingSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "allowPrivateRepositoryForkingSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for base repository permissions for organizations in this enterprise.
   */

  readonly defaultRepositoryPermissionSetting: () => Field<"defaultRepositoryPermissionSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided default repository permission.
   */

  readonly defaultRepositoryPermissionSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | DefaultRepositoryPermissionField;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "defaultRepositoryPermissionSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | DefaultRepositoryPermissionField>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Enterprise Server installations owned by the enterprise.
   */

  readonly enterpriseServerInstallations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      connectedOnly?: Variable<"connectedOnly"> | boolean;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseServerInstallationOrder;
    },
    select: (t: EnterpriseServerInstallationConnectionSelector) => T
  ) => Field<
    "enterpriseServerInstallations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"connectedOnly", Variable<"connectedOnly"> | boolean>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseServerInstallationOrder
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether the enterprise has an IP allow list enabled.
   */

  readonly ipAllowListEnabledSetting: () => Field<"ipAllowListEnabledSetting">;

  /**
   * @description The IP addresses that are allowed to access resources owned by the enterprise.
   */

  readonly ipAllowListEntries: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IpAllowListEntryOrder;
    },
    select: (t: IpAllowListEntryConnectionSelector) => T
  ) => Field<
    "ipAllowListEntries",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IpAllowListEntryOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not the default repository permission is currently being updated.
   */

  readonly isUpdatingDefaultRepositoryPermission: () => Field<"isUpdatingDefaultRepositoryPermission">;

  /**
   * @description Whether the two-factor authentication requirement is currently being enforced.
   */

  readonly isUpdatingTwoFactorRequirement: () => Field<"isUpdatingTwoFactorRequirement">;

  /**
     * @description The setting value for whether organization members with admin permissions on a
repository can change repository visibility.
     */

  readonly membersCanChangeRepositoryVisibilitySetting: () => Field<"membersCanChangeRepositoryVisibilitySetting">;

  /**
   * @description A list of enterprise organizations configured with the provided can change repository visibility setting value.
   */

  readonly membersCanChangeRepositoryVisibilitySettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanChangeRepositoryVisibilitySettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members of organizations in the enterprise can create internal repositories.
   */

  readonly membersCanCreateInternalRepositoriesSetting: () => Field<"membersCanCreateInternalRepositoriesSetting">;

  /**
   * @description The setting value for whether members of organizations in the enterprise can create private repositories.
   */

  readonly membersCanCreatePrivateRepositoriesSetting: () => Field<"membersCanCreatePrivateRepositoriesSetting">;

  /**
   * @description The setting value for whether members of organizations in the enterprise can create public repositories.
   */

  readonly membersCanCreatePublicRepositoriesSetting: () => Field<"membersCanCreatePublicRepositoriesSetting">;

  /**
   * @description The setting value for whether members of organizations in the enterprise can create repositories.
   */

  readonly membersCanCreateRepositoriesSetting: () => Field<"membersCanCreateRepositoriesSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided repository creation setting value.
   */

  readonly membersCanCreateRepositoriesSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?:
        | Variable<"value">
        | OrganizationMembersCanCreateRepositoriesSettingValue;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanCreateRepositoriesSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<
        "value",
        Variable<"value"> | OrganizationMembersCanCreateRepositoriesSettingValue
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members with admin permissions for repositories can delete issues.
   */

  readonly membersCanDeleteIssuesSetting: () => Field<"membersCanDeleteIssuesSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can delete issues setting value.
   */

  readonly membersCanDeleteIssuesSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanDeleteIssuesSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members with admin permissions for repositories can delete or transfer repositories.
   */

  readonly membersCanDeleteRepositoriesSetting: () => Field<"membersCanDeleteRepositoriesSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can delete repositories setting value.
   */

  readonly membersCanDeleteRepositoriesSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanDeleteRepositoriesSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members of organizations in the enterprise can invite outside collaborators.
   */

  readonly membersCanInviteCollaboratorsSetting: () => Field<"membersCanInviteCollaboratorsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can invite collaborators setting value.
   */

  readonly membersCanInviteCollaboratorsSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanInviteCollaboratorsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Indicates whether members of this enterprise's organizations can purchase additional services for those organizations.
   */

  readonly membersCanMakePurchasesSetting: () => Field<"membersCanMakePurchasesSetting">;

  /**
   * @description The setting value for whether members with admin permissions for repositories can update protected branches.
   */

  readonly membersCanUpdateProtectedBranchesSetting: () => Field<"membersCanUpdateProtectedBranchesSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can update protected branches setting value.
   */

  readonly membersCanUpdateProtectedBranchesSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanUpdateProtectedBranchesSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members can view dependency insights.
   */

  readonly membersCanViewDependencyInsightsSetting: () => Field<"membersCanViewDependencyInsightsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can view dependency insights setting value.
   */

  readonly membersCanViewDependencyInsightsSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanViewDependencyInsightsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether organization projects are enabled for organizations in this enterprise.
   */

  readonly organizationProjectsSetting: () => Field<"organizationProjectsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided organization projects setting value.
   */

  readonly organizationProjectsSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "organizationProjectsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of outside collaborators across the repositories in the enterprise.
   */

  readonly outsideCollaborators: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      login?: Variable<"login"> | string;
      orderBy?: Variable<"orderBy"> | EnterpriseMemberOrder;
      query?: Variable<"query"> | string;
      visibility?: Variable<"visibility"> | RepositoryVisibility;
    },
    select: (t: EnterpriseOutsideCollaboratorConnectionSelector) => T
  ) => Field<
    "outsideCollaborators",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"login", Variable<"login"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | EnterpriseMemberOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"visibility", Variable<"visibility"> | RepositoryVisibility>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pending administrator invitations for the enterprise.
   */

  readonly pendingAdminInvitations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseAdministratorInvitationOrder;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | EnterpriseAdministratorRole;
    },
    select: (t: EnterpriseAdministratorInvitationConnectionSelector) => T
  ) => Field<
    "pendingAdminInvitations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseAdministratorInvitationOrder
      >,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseAdministratorRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pending collaborator invitations across the repositories in the enterprise.
   */

  readonly pendingCollaboratorInvitations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryInvitationOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: RepositoryInvitationConnectionSelector) => T
  ) => Field<
    "pendingCollaboratorInvitations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryInvitationOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pending collaborators across the repositories in the enterprise.
   * @deprecated Repository invitations can now be associated with an email, not only an invitee. Use the `pendingCollaboratorInvitations` field instead. Removal on 2020-10-01 UTC.
   */

  readonly pendingCollaborators: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryInvitationOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: EnterprisePendingCollaboratorConnectionSelector) => T
  ) => Field<
    "pendingCollaborators",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryInvitationOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pending member invitations for organizations in the enterprise.
   */

  readonly pendingMemberInvitations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: EnterprisePendingMemberInvitationConnectionSelector) => T
  ) => Field<
    "pendingMemberInvitations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether repository projects are enabled in this enterprise.
   */

  readonly repositoryProjectsSetting: () => Field<"repositoryProjectsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided repository projects setting value.
   */

  readonly repositoryProjectsSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "repositoryProjectsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The SAML Identity Provider for the enterprise.
   */

  readonly samlIdentityProvider: <T extends Array<Selection>>(
    select: (t: EnterpriseIdentityProviderSelector) => T
  ) => Field<"samlIdentityProvider", never, SelectionSet<T>>;

  /**
   * @description A list of enterprise organizations configured with the SAML single sign-on setting value.
   */

  readonly samlIdentityProviderSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | IdentityProviderConfigurationState;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "samlIdentityProviderSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | IdentityProviderConfigurationState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether team discussions are enabled for organizations in this enterprise.
   */

  readonly teamDiscussionsSetting: () => Field<"teamDiscussionsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided team discussions setting value.
   */

  readonly teamDiscussionsSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "teamDiscussionsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether the enterprise requires two-factor authentication for its organizations and users.
   */

  readonly twoFactorRequiredSetting: () => Field<"twoFactorRequiredSetting">;

  /**
   * @description A list of enterprise organizations configured with the two-factor authentication setting value.
   */

  readonly twoFactorRequiredSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "twoFactorRequiredSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;
}

export const EnterpriseOwnerInfo: EnterpriseOwnerInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of all of the administrators for this enterprise.
   */

  admins: (variables, select) =>
    new Field(
      "admins",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("role", variables.role, EnterpriseAdministratorRole),
      ],
      new SelectionSet(select(EnterpriseAdministratorConnection))
    ),

  /**
   * @description A list of users in the enterprise who currently have two-factor authentication disabled.
   */

  affiliatedUsersWithTwoFactorDisabled: (variables, select) =>
    new Field(
      "affiliatedUsersWithTwoFactorDisabled",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description Whether or not affiliated users with two-factor authentication disabled exist in the enterprise.
   */
  affiliatedUsersWithTwoFactorDisabledExist: () =>
    new Field("affiliatedUsersWithTwoFactorDisabledExist"),

  /**
   * @description The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise.
   */
  allowPrivateRepositoryForkingSetting: () =>
    new Field("allowPrivateRepositoryForkingSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided private repository forking setting value.
   */

  allowPrivateRepositoryForkingSettingOrganizations: (variables, select) =>
    new Field(
      "allowPrivateRepositoryForkingSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for base repository permissions for organizations in this enterprise.
   */
  defaultRepositoryPermissionSetting: () =>
    new Field("defaultRepositoryPermissionSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided default repository permission.
   */

  defaultRepositoryPermissionSettingOrganizations: (variables, select) =>
    new Field(
      "defaultRepositoryPermissionSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "value",
          variables.value,
          DefaultRepositoryPermissionField
        ),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description Enterprise Server installations owned by the enterprise.
   */

  enterpriseServerInstallations: (variables, select) =>
    new Field(
      "enterpriseServerInstallations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("connectedOnly", variables.connectedOnly),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseServerInstallationConnection))
    ),

  /**
   * @description The setting value for whether the enterprise has an IP allow list enabled.
   */
  ipAllowListEnabledSetting: () => new Field("ipAllowListEnabledSetting"),

  /**
   * @description The IP addresses that are allowed to access resources owned by the enterprise.
   */

  ipAllowListEntries: (variables, select) =>
    new Field(
      "ipAllowListEntries",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IpAllowListEntryConnection))
    ),

  /**
   * @description Whether or not the default repository permission is currently being updated.
   */
  isUpdatingDefaultRepositoryPermission: () =>
    new Field("isUpdatingDefaultRepositoryPermission"),

  /**
   * @description Whether the two-factor authentication requirement is currently being enforced.
   */
  isUpdatingTwoFactorRequirement: () =>
    new Field("isUpdatingTwoFactorRequirement"),

  /**
     * @description The setting value for whether organization members with admin permissions on a
repository can change repository visibility.
     */
  membersCanChangeRepositoryVisibilitySetting: () =>
    new Field("membersCanChangeRepositoryVisibilitySetting"),

  /**
   * @description A list of enterprise organizations configured with the provided can change repository visibility setting value.
   */

  membersCanChangeRepositoryVisibilitySettingOrganizations: (
    variables,
    select
  ) =>
    new Field(
      "membersCanChangeRepositoryVisibilitySettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members of organizations in the enterprise can create internal repositories.
   */
  membersCanCreateInternalRepositoriesSetting: () =>
    new Field("membersCanCreateInternalRepositoriesSetting"),

  /**
   * @description The setting value for whether members of organizations in the enterprise can create private repositories.
   */
  membersCanCreatePrivateRepositoriesSetting: () =>
    new Field("membersCanCreatePrivateRepositoriesSetting"),

  /**
   * @description The setting value for whether members of organizations in the enterprise can create public repositories.
   */
  membersCanCreatePublicRepositoriesSetting: () =>
    new Field("membersCanCreatePublicRepositoriesSetting"),

  /**
   * @description The setting value for whether members of organizations in the enterprise can create repositories.
   */
  membersCanCreateRepositoriesSetting: () =>
    new Field("membersCanCreateRepositoriesSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided repository creation setting value.
   */

  membersCanCreateRepositoriesSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanCreateRepositoriesSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "value",
          variables.value,
          OrganizationMembersCanCreateRepositoriesSettingValue
        ),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members with admin permissions for repositories can delete issues.
   */
  membersCanDeleteIssuesSetting: () =>
    new Field("membersCanDeleteIssuesSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can delete issues setting value.
   */

  membersCanDeleteIssuesSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanDeleteIssuesSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members with admin permissions for repositories can delete or transfer repositories.
   */
  membersCanDeleteRepositoriesSetting: () =>
    new Field("membersCanDeleteRepositoriesSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can delete repositories setting value.
   */

  membersCanDeleteRepositoriesSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanDeleteRepositoriesSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members of organizations in the enterprise can invite outside collaborators.
   */
  membersCanInviteCollaboratorsSetting: () =>
    new Field("membersCanInviteCollaboratorsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can invite collaborators setting value.
   */

  membersCanInviteCollaboratorsSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanInviteCollaboratorsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description Indicates whether members of this enterprise's organizations can purchase additional services for those organizations.
   */
  membersCanMakePurchasesSetting: () =>
    new Field("membersCanMakePurchasesSetting"),

  /**
   * @description The setting value for whether members with admin permissions for repositories can update protected branches.
   */
  membersCanUpdateProtectedBranchesSetting: () =>
    new Field("membersCanUpdateProtectedBranchesSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can update protected branches setting value.
   */

  membersCanUpdateProtectedBranchesSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanUpdateProtectedBranchesSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members can view dependency insights.
   */
  membersCanViewDependencyInsightsSetting: () =>
    new Field("membersCanViewDependencyInsightsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can view dependency insights setting value.
   */

  membersCanViewDependencyInsightsSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanViewDependencyInsightsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether organization projects are enabled for organizations in this enterprise.
   */
  organizationProjectsSetting: () => new Field("organizationProjectsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided organization projects setting value.
   */

  organizationProjectsSettingOrganizations: (variables, select) =>
    new Field(
      "organizationProjectsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description A list of outside collaborators across the repositories in the enterprise.
   */

  outsideCollaborators: (variables, select) =>
    new Field(
      "outsideCollaborators",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("login", variables.login),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("visibility", variables.visibility, RepositoryVisibility),
      ],
      new SelectionSet(select(EnterpriseOutsideCollaboratorConnection))
    ),

  /**
   * @description A list of pending administrator invitations for the enterprise.
   */

  pendingAdminInvitations: (variables, select) =>
    new Field(
      "pendingAdminInvitations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("role", variables.role, EnterpriseAdministratorRole),
      ],
      new SelectionSet(select(EnterpriseAdministratorInvitationConnection))
    ),

  /**
   * @description A list of pending collaborator invitations across the repositories in the enterprise.
   */

  pendingCollaboratorInvitations: (variables, select) =>
    new Field(
      "pendingCollaboratorInvitations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(RepositoryInvitationConnection))
    ),

  /**
   * @description A list of pending collaborators across the repositories in the enterprise.
   * @deprecated Repository invitations can now be associated with an email, not only an invitee. Use the `pendingCollaboratorInvitations` field instead. Removal on 2020-10-01 UTC.
   */

  pendingCollaborators: (variables, select) =>
    new Field(
      "pendingCollaborators",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(EnterprisePendingCollaboratorConnection))
    ),

  /**
   * @description A list of pending member invitations for organizations in the enterprise.
   */

  pendingMemberInvitations: (variables, select) =>
    new Field(
      "pendingMemberInvitations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(EnterprisePendingMemberInvitationConnection))
    ),

  /**
   * @description The setting value for whether repository projects are enabled in this enterprise.
   */
  repositoryProjectsSetting: () => new Field("repositoryProjectsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided repository projects setting value.
   */

  repositoryProjectsSettingOrganizations: (variables, select) =>
    new Field(
      "repositoryProjectsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The SAML Identity Provider for the enterprise.
   */

  samlIdentityProvider: (select) =>
    new Field(
      "samlIdentityProvider",
      undefined as never,
      new SelectionSet(select(EnterpriseIdentityProvider))
    ),

  /**
   * @description A list of enterprise organizations configured with the SAML single sign-on setting value.
   */

  samlIdentityProviderSettingOrganizations: (variables, select) =>
    new Field(
      "samlIdentityProviderSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "value",
          variables.value,
          IdentityProviderConfigurationState
        ),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether team discussions are enabled for organizations in this enterprise.
   */
  teamDiscussionsSetting: () => new Field("teamDiscussionsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided team discussions setting value.
   */

  teamDiscussionsSettingOrganizations: (variables, select) =>
    new Field(
      "teamDiscussionsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether the enterprise requires two-factor authentication for its organizations and users.
   */
  twoFactorRequiredSetting: () => new Field("twoFactorRequiredSetting"),

  /**
   * @description A list of enterprise organizations configured with the two-factor authentication setting value.
   */

  twoFactorRequiredSettingOrganizations: (variables, select) =>
    new Field(
      "twoFactorRequiredSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),
};

export interface IEnterprisePendingCollaboratorConnection {
  readonly __typename: "EnterprisePendingCollaboratorConnection";
  readonly edges: ReadonlyArray<IEnterprisePendingCollaboratorEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterprisePendingCollaboratorConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterprisePendingCollaboratorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterprisePendingCollaboratorConnection: EnterprisePendingCollaboratorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterprisePendingCollaboratorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterprisePendingCollaboratorEdge {
  readonly __typename: "EnterprisePendingCollaboratorEdge";
  readonly cursor: string;
  readonly isUnlicensed: boolean;
  readonly node: IUser | null;
  readonly repositories: IEnterpriseRepositoryInfoConnection;
}

interface EnterprisePendingCollaboratorEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description Whether the invited collaborator does not have a license for the enterprise.
   * @deprecated All pending collaborators consume a license Removal on 2021-01-01 UTC.
   */

  readonly isUnlicensed: () => Field<"isUnlicensed">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The enterprise organization repositories this user is a member of.
   */

  readonly repositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
    },
    select: (t: EnterpriseRepositoryInfoConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>
    ],
    SelectionSet<T>
  >;
}

export const EnterprisePendingCollaboratorEdge: EnterprisePendingCollaboratorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the invited collaborator does not have a license for the enterprise.
   * @deprecated All pending collaborators consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: () => new Field("isUnlicensed"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The enterprise organization repositories this user is a member of.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseRepositoryInfoConnection))
    ),
};

export interface IEnterprisePendingMemberInvitationConnection {
  readonly __typename: "EnterprisePendingMemberInvitationConnection";
  readonly edges: ReadonlyArray<IEnterprisePendingMemberInvitationEdge> | null;
  readonly nodes: ReadonlyArray<IOrganizationInvitation> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
  readonly totalUniqueUserCount: number;
}

interface EnterprisePendingMemberInvitationConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterprisePendingMemberInvitationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;

  /**
   * @description Identifies the total count of unique users in the connection.
   */

  readonly totalUniqueUserCount: () => Field<"totalUniqueUserCount">;
}

export const EnterprisePendingMemberInvitationConnection: EnterprisePendingMemberInvitationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterprisePendingMemberInvitationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description Identifies the total count of unique users in the connection.
   */
  totalUniqueUserCount: () => new Field("totalUniqueUserCount"),
};

export interface IEnterprisePendingMemberInvitationEdge {
  readonly __typename: "EnterprisePendingMemberInvitationEdge";
  readonly cursor: string;
  readonly isUnlicensed: boolean;
  readonly node: IOrganizationInvitation | null;
}

interface EnterprisePendingMemberInvitationEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description Whether the invitation has a license for the enterprise.
   * @deprecated All pending members consume a license Removal on 2020-07-01 UTC.
   */

  readonly isUnlicensed: () => Field<"isUnlicensed">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterprisePendingMemberInvitationEdge: EnterprisePendingMemberInvitationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the invitation has a license for the enterprise.
   * @deprecated All pending members consume a license Removal on 2020-07-01 UTC.
   */
  isUnlicensed: () => new Field("isUnlicensed"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),
};

export interface IEnterpriseRepositoryInfo extends INode {
  readonly __typename: "EnterpriseRepositoryInfo";
  readonly isPrivate: boolean;
  readonly name: string;
  readonly nameWithOwner: string;
}

interface EnterpriseRepositoryInfoSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies if the repository is private.
   */

  readonly isPrivate: () => Field<"isPrivate">;

  /**
   * @description The repository's name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The repository's name with owner.
   */

  readonly nameWithOwner: () => Field<"nameWithOwner">;
}

export const isEnterpriseRepositoryInfo = (
  object: Record<string, any>
): object is Partial<IEnterpriseRepositoryInfo> => {
  return object.__typename === "EnterpriseRepositoryInfo";
};

export const EnterpriseRepositoryInfo: EnterpriseRepositoryInfoSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Identifies if the repository is private.
   */
  isPrivate: () => new Field("isPrivate"),

  /**
   * @description The repository's name.
   */
  name: () => new Field("name"),

  /**
   * @description The repository's name with owner.
   */
  nameWithOwner: () => new Field("nameWithOwner"),
};

export interface IEnterpriseRepositoryInfoConnection {
  readonly __typename: "EnterpriseRepositoryInfoConnection";
  readonly edges: ReadonlyArray<IEnterpriseRepositoryInfoEdge> | null;
  readonly nodes: ReadonlyArray<IEnterpriseRepositoryInfo> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseRepositoryInfoConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseRepositoryInfoEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseRepositoryInfoSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseRepositoryInfoConnection: EnterpriseRepositoryInfoConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseRepositoryInfoEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseRepositoryInfo))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseRepositoryInfoEdge {
  readonly __typename: "EnterpriseRepositoryInfoEdge";
  readonly cursor: string;
  readonly node: IEnterpriseRepositoryInfo | null;
}

interface EnterpriseRepositoryInfoEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: EnterpriseRepositoryInfoSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseRepositoryInfoEdge: EnterpriseRepositoryInfoEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseRepositoryInfo))
    ),
};

export interface IEnterpriseServerInstallation extends INode {
  readonly __typename: "EnterpriseServerInstallation";
  readonly createdAt: unknown;
  readonly customerName: string;
  readonly hostName: string;
  readonly isConnected: boolean;
  readonly updatedAt: unknown;
  readonly userAccounts: IEnterpriseServerUserAccountConnection;
  readonly userAccountsUploads: IEnterpriseServerUserAccountsUploadConnection;
}

interface EnterpriseServerInstallationSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The customer name to which the Enterprise Server installation belongs.
   */

  readonly customerName: () => Field<"customerName">;

  /**
   * @description The host name of the Enterprise Server installation.
   */

  readonly hostName: () => Field<"hostName">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect.
   */

  readonly isConnected: () => Field<"isConnected">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description User accounts on this Enterprise Server installation.
   */

  readonly userAccounts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseServerUserAccountOrder;
    },
    select: (t: EnterpriseServerUserAccountConnectionSelector) => T
  ) => Field<
    "userAccounts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseServerUserAccountOrder
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description User accounts uploads for the Enterprise Server installation.
   */

  readonly userAccountsUploads: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseServerUserAccountsUploadOrder;
    },
    select: (t: EnterpriseServerUserAccountsUploadConnectionSelector) => T
  ) => Field<
    "userAccountsUploads",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseServerUserAccountsUploadOrder
      >
    ],
    SelectionSet<T>
  >;
}

export const isEnterpriseServerInstallation = (
  object: Record<string, any>
): object is Partial<IEnterpriseServerInstallation> => {
  return object.__typename === "EnterpriseServerInstallation";
};

export const EnterpriseServerInstallation: EnterpriseServerInstallationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The customer name to which the Enterprise Server installation belongs.
   */
  customerName: () => new Field("customerName"),

  /**
   * @description The host name of the Enterprise Server installation.
   */
  hostName: () => new Field("hostName"),
  id: () => new Field("id"),

  /**
   * @description Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect.
   */
  isConnected: () => new Field("isConnected"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description User accounts on this Enterprise Server installation.
   */

  userAccounts: (variables, select) =>
    new Field(
      "userAccounts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseServerUserAccountConnection))
    ),

  /**
   * @description User accounts uploads for the Enterprise Server installation.
   */

  userAccountsUploads: (variables, select) =>
    new Field(
      "userAccountsUploads",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseServerUserAccountsUploadConnection))
    ),
};

export interface IEnterpriseServerInstallationConnection {
  readonly __typename: "EnterpriseServerInstallationConnection";
  readonly edges: ReadonlyArray<IEnterpriseServerInstallationEdge> | null;
  readonly nodes: ReadonlyArray<IEnterpriseServerInstallation> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseServerInstallationConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseServerInstallationConnection: EnterpriseServerInstallationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseServerInstallationEdge {
  readonly __typename: "EnterpriseServerInstallationEdge";
  readonly cursor: string;
  readonly node: IEnterpriseServerInstallation | null;
}

interface EnterpriseServerInstallationEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseServerInstallationEdge: EnterpriseServerInstallationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallation))
    ),
};

export interface IEnterpriseServerUserAccount extends INode {
  readonly __typename: "EnterpriseServerUserAccount";
  readonly createdAt: unknown;
  readonly emails: IEnterpriseServerUserAccountEmailConnection;
  readonly enterpriseServerInstallation: IEnterpriseServerInstallation;
  readonly isSiteAdmin: boolean;
  readonly login: string;
  readonly profileName: string | null;
  readonly remoteCreatedAt: unknown;
  readonly remoteUserId: number;
  readonly updatedAt: unknown;
}

interface EnterpriseServerUserAccountSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description User emails belonging to this user account.
   */

  readonly emails: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseServerUserAccountEmailOrder;
    },
    select: (t: EnterpriseServerUserAccountEmailConnectionSelector) => T
  ) => Field<
    "emails",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseServerUserAccountEmailOrder
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description The Enterprise Server installation on which this user account exists.
   */

  readonly enterpriseServerInstallation: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationSelector) => T
  ) => Field<"enterpriseServerInstallation", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the user account is a site administrator on the Enterprise Server installation.
   */

  readonly isSiteAdmin: () => Field<"isSiteAdmin">;

  /**
   * @description The login of the user account on the Enterprise Server installation.
   */

  readonly login: () => Field<"login">;

  /**
   * @description The profile name of the user account on the Enterprise Server installation.
   */

  readonly profileName: () => Field<"profileName">;

  /**
   * @description The date and time when the user account was created on the Enterprise Server installation.
   */

  readonly remoteCreatedAt: () => Field<"remoteCreatedAt">;

  /**
   * @description The ID of the user account on the Enterprise Server installation.
   */

  readonly remoteUserId: () => Field<"remoteUserId">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const isEnterpriseServerUserAccount = (
  object: Record<string, any>
): object is Partial<IEnterpriseServerUserAccount> => {
  return object.__typename === "EnterpriseServerUserAccount";
};

export const EnterpriseServerUserAccount: EnterpriseServerUserAccountSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description User emails belonging to this user account.
   */

  emails: (variables, select) =>
    new Field(
      "emails",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseServerUserAccountEmailConnection))
    ),

  /**
   * @description The Enterprise Server installation on which this user account exists.
   */

  enterpriseServerInstallation: (select) =>
    new Field(
      "enterpriseServerInstallation",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallation))
    ),

  id: () => new Field("id"),

  /**
   * @description Whether the user account is a site administrator on the Enterprise Server installation.
   */
  isSiteAdmin: () => new Field("isSiteAdmin"),

  /**
   * @description The login of the user account on the Enterprise Server installation.
   */
  login: () => new Field("login"),

  /**
   * @description The profile name of the user account on the Enterprise Server installation.
   */
  profileName: () => new Field("profileName"),

  /**
   * @description The date and time when the user account was created on the Enterprise Server installation.
   */
  remoteCreatedAt: () => new Field("remoteCreatedAt"),

  /**
   * @description The ID of the user account on the Enterprise Server installation.
   */
  remoteUserId: () => new Field("remoteUserId"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IEnterpriseServerUserAccountConnection {
  readonly __typename: "EnterpriseServerUserAccountConnection";
  readonly edges: ReadonlyArray<IEnterpriseServerUserAccountEdge> | null;
  readonly nodes: ReadonlyArray<IEnterpriseServerUserAccount> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseServerUserAccountConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseServerUserAccountConnection: EnterpriseServerUserAccountConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccount))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseServerUserAccountEdge {
  readonly __typename: "EnterpriseServerUserAccountEdge";
  readonly cursor: string;
  readonly node: IEnterpriseServerUserAccount | null;
}

interface EnterpriseServerUserAccountEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseServerUserAccountEdge: EnterpriseServerUserAccountEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccount))
    ),
};

export interface IEnterpriseServerUserAccountEmail extends INode {
  readonly __typename: "EnterpriseServerUserAccountEmail";
  readonly createdAt: unknown;
  readonly email: string;
  readonly isPrimary: boolean;
  readonly updatedAt: unknown;
  readonly userAccount: IEnterpriseServerUserAccount;
}

interface EnterpriseServerUserAccountEmailSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The email address.
   */

  readonly email: () => Field<"email">;

  readonly id: () => Field<"id">;

  /**
   * @description Indicates whether this is the primary email of the associated user account.
   */

  readonly isPrimary: () => Field<"isPrimary">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The user account to which the email belongs.
   */

  readonly userAccount: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountSelector) => T
  ) => Field<"userAccount", never, SelectionSet<T>>;
}

export const isEnterpriseServerUserAccountEmail = (
  object: Record<string, any>
): object is Partial<IEnterpriseServerUserAccountEmail> => {
  return object.__typename === "EnterpriseServerUserAccountEmail";
};

export const EnterpriseServerUserAccountEmail: EnterpriseServerUserAccountEmailSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The email address.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description Indicates whether this is the primary email of the associated user account.
   */
  isPrimary: () => new Field("isPrimary"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The user account to which the email belongs.
   */

  userAccount: (select) =>
    new Field(
      "userAccount",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccount))
    ),
};

export interface IEnterpriseServerUserAccountEmailConnection {
  readonly __typename: "EnterpriseServerUserAccountEmailConnection";
  readonly edges: ReadonlyArray<IEnterpriseServerUserAccountEmailEdge> | null;
  readonly nodes: ReadonlyArray<IEnterpriseServerUserAccountEmail> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseServerUserAccountEmailConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountEmailEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountEmailSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseServerUserAccountEmailConnection: EnterpriseServerUserAccountEmailConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountEmailEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountEmail))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseServerUserAccountEmailEdge {
  readonly __typename: "EnterpriseServerUserAccountEmailEdge";
  readonly cursor: string;
  readonly node: IEnterpriseServerUserAccountEmail | null;
}

interface EnterpriseServerUserAccountEmailEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountEmailSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseServerUserAccountEmailEdge: EnterpriseServerUserAccountEmailEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountEmail))
    ),
};

export interface IEnterpriseServerUserAccountsUpload extends INode {
  readonly __typename: "EnterpriseServerUserAccountsUpload";
  readonly createdAt: unknown;
  readonly enterprise: IEnterprise;
  readonly enterpriseServerInstallation: IEnterpriseServerInstallation;
  readonly name: string;
  readonly syncState: EnterpriseServerUserAccountsUploadSyncState;
  readonly updatedAt: unknown;
}

interface EnterpriseServerUserAccountsUploadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The enterprise to which this upload belongs.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description The Enterprise Server installation for which this upload was generated.
   */

  readonly enterpriseServerInstallation: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationSelector) => T
  ) => Field<"enterpriseServerInstallation", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The name of the file uploaded.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The synchronization state of the upload
   */

  readonly syncState: () => Field<"syncState">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const isEnterpriseServerUserAccountsUpload = (
  object: Record<string, any>
): object is Partial<IEnterpriseServerUserAccountsUpload> => {
  return object.__typename === "EnterpriseServerUserAccountsUpload";
};

export const EnterpriseServerUserAccountsUpload: EnterpriseServerUserAccountsUploadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The enterprise to which this upload belongs.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description The Enterprise Server installation for which this upload was generated.
   */

  enterpriseServerInstallation: (select) =>
    new Field(
      "enterpriseServerInstallation",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallation))
    ),

  id: () => new Field("id"),

  /**
   * @description The name of the file uploaded.
   */
  name: () => new Field("name"),

  /**
   * @description The synchronization state of the upload
   */
  syncState: () => new Field("syncState"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IEnterpriseServerUserAccountsUploadConnection {
  readonly __typename: "EnterpriseServerUserAccountsUploadConnection";
  readonly edges: ReadonlyArray<IEnterpriseServerUserAccountsUploadEdge> | null;
  readonly nodes: ReadonlyArray<IEnterpriseServerUserAccountsUpload> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseServerUserAccountsUploadConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountsUploadEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountsUploadSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseServerUserAccountsUploadConnection: EnterpriseServerUserAccountsUploadConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountsUploadEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountsUpload))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseServerUserAccountsUploadEdge {
  readonly __typename: "EnterpriseServerUserAccountsUploadEdge";
  readonly cursor: string;
  readonly node: IEnterpriseServerUserAccountsUpload | null;
}

interface EnterpriseServerUserAccountsUploadEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountsUploadSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseServerUserAccountsUploadEdge: EnterpriseServerUserAccountsUploadEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountsUpload))
    ),
};

export interface IEnterpriseUserAccount extends IActor, INode {
  readonly __typename: "EnterpriseUserAccount";
  readonly createdAt: unknown;
  readonly enterprise: IEnterprise;
  readonly name: string | null;
  readonly organizations: IEnterpriseOrganizationMembershipConnection;
  readonly updatedAt: unknown;
  readonly user: IUser | null;
}

interface EnterpriseUserAccountSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the enterprise user account's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The enterprise in which this user account exists.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description An identifier for the enterprise user account, a login or email address
   */

  readonly login: () => Field<"login">;

  /**
   * @description The name of the enterprise user account
   */

  readonly name: () => Field<"name">;

  /**
   * @description A list of enterprise organizations this user is a member of.
   */

  readonly organizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | EnterpriseUserAccountMembershipRole;
    },
    select: (t: EnterpriseOrganizationMembershipConnectionSelector) => T
  ) => Field<
    "organizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseUserAccountMembershipRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this user.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this user.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user within the enterprise.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isEnterpriseUserAccount = (
  object: Record<string, any>
): object is Partial<IEnterpriseUserAccount> => {
  return object.__typename === "EnterpriseUserAccount";
};

export const EnterpriseUserAccount: EnterpriseUserAccountSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the enterprise user account's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The enterprise in which this user account exists.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  id: () => new Field("id"),

  /**
   * @description An identifier for the enterprise user account, a login or email address
   */
  login: () => new Field("login"),

  /**
   * @description The name of the enterprise user account
   */
  name: () => new Field("name"),

  /**
   * @description A list of enterprise organizations this user is a member of.
   */

  organizations: (variables, select) =>
    new Field(
      "organizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument(
          "role",
          variables.role,
          EnterpriseUserAccountMembershipRole
        ),
      ],
      new SelectionSet(select(EnterpriseOrganizationMembershipConnection))
    ),

  /**
   * @description The HTTP path for this user.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this user.
   */
  url: () => new Field("url"),

  /**
   * @description The user within the enterprise.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IEnterpriseUserAccountConnection {
  readonly __typename: "EnterpriseUserAccountConnection";
  readonly edges: ReadonlyArray<IEnterpriseUserAccountEdge> | null;
  readonly nodes: ReadonlyArray<IEnterpriseUserAccount> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface EnterpriseUserAccountConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: EnterpriseUserAccountEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseUserAccountSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const EnterpriseUserAccountConnection: EnterpriseUserAccountConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseUserAccountEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseUserAccount))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseUserAccountEdge {
  readonly __typename: "EnterpriseUserAccountEdge";
  readonly cursor: string;
  readonly node: IEnterpriseUserAccount | null;
}

interface EnterpriseUserAccountEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: EnterpriseUserAccountSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseUserAccountEdge: EnterpriseUserAccountEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseUserAccount))
    ),
};

export interface IExternalIdentity extends INode {
  readonly __typename: "ExternalIdentity";
  readonly guid: string;
  readonly organizationInvitation: IOrganizationInvitation | null;
  readonly samlIdentity: IExternalIdentitySamlAttributes | null;
  readonly scimIdentity: IExternalIdentityScimAttributes | null;
  readonly user: IUser | null;
}

interface ExternalIdentitySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The GUID for this identity
   */

  readonly guid: () => Field<"guid">;

  readonly id: () => Field<"id">;

  /**
   * @description Organization invitation for this SCIM-provisioned external identity
   */

  readonly organizationInvitation: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"organizationInvitation", never, SelectionSet<T>>;

  /**
   * @description SAML Identity attributes
   */

  readonly samlIdentity: <T extends Array<Selection>>(
    select: (t: ExternalIdentitySamlAttributesSelector) => T
  ) => Field<"samlIdentity", never, SelectionSet<T>>;

  /**
   * @description SCIM Identity attributes
   */

  readonly scimIdentity: <T extends Array<Selection>>(
    select: (t: ExternalIdentityScimAttributesSelector) => T
  ) => Field<"scimIdentity", never, SelectionSet<T>>;

  /**
   * @description User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isExternalIdentity = (
  object: Record<string, any>
): object is Partial<IExternalIdentity> => {
  return object.__typename === "ExternalIdentity";
};

export const ExternalIdentity: ExternalIdentitySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The GUID for this identity
   */
  guid: () => new Field("guid"),
  id: () => new Field("id"),

  /**
   * @description Organization invitation for this SCIM-provisioned external identity
   */

  organizationInvitation: (select) =>
    new Field(
      "organizationInvitation",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),

  /**
   * @description SAML Identity attributes
   */

  samlIdentity: (select) =>
    new Field(
      "samlIdentity",
      undefined as never,
      new SelectionSet(select(ExternalIdentitySamlAttributes))
    ),

  /**
   * @description SCIM Identity attributes
   */

  scimIdentity: (select) =>
    new Field(
      "scimIdentity",
      undefined as never,
      new SelectionSet(select(ExternalIdentityScimAttributes))
    ),

  /**
   * @description User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IExternalIdentityConnection {
  readonly __typename: "ExternalIdentityConnection";
  readonly edges: ReadonlyArray<IExternalIdentityEdge> | null;
  readonly nodes: ReadonlyArray<IExternalIdentity> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ExternalIdentityConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ExternalIdentityEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ExternalIdentitySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ExternalIdentityConnection: ExternalIdentityConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ExternalIdentityEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ExternalIdentity))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IExternalIdentityEdge {
  readonly __typename: "ExternalIdentityEdge";
  readonly cursor: string;
  readonly node: IExternalIdentity | null;
}

interface ExternalIdentityEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ExternalIdentitySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ExternalIdentityEdge: ExternalIdentityEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ExternalIdentity))
    ),
};

export interface IExternalIdentitySamlAttributes {
  readonly __typename: "ExternalIdentitySamlAttributes";
  readonly emails: ReadonlyArray<IUserEmailMetadata> | null;
  readonly familyName: string | null;
  readonly givenName: string | null;
  readonly groups: ReadonlyArray<string> | null;
  readonly nameId: string | null;
  readonly username: string | null;
}

interface ExternalIdentitySamlAttributesSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The emails associated with the SAML identity
   */

  readonly emails: <T extends Array<Selection>>(
    select: (t: UserEmailMetadataSelector) => T
  ) => Field<"emails", never, SelectionSet<T>>;

  /**
   * @description Family name of the SAML identity
   */

  readonly familyName: () => Field<"familyName">;

  /**
   * @description Given name of the SAML identity
   */

  readonly givenName: () => Field<"givenName">;

  /**
   * @description The groups linked to this identity in IDP
   */

  readonly groups: () => Field<"groups">;

  /**
   * @description The NameID of the SAML identity
   */

  readonly nameId: () => Field<"nameId">;

  /**
   * @description The userName of the SAML identity
   */

  readonly username: () => Field<"username">;
}

export const ExternalIdentitySamlAttributes: ExternalIdentitySamlAttributesSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The emails associated with the SAML identity
   */

  emails: (select) =>
    new Field(
      "emails",
      undefined as never,
      new SelectionSet(select(UserEmailMetadata))
    ),

  /**
   * @description Family name of the SAML identity
   */
  familyName: () => new Field("familyName"),

  /**
   * @description Given name of the SAML identity
   */
  givenName: () => new Field("givenName"),

  /**
   * @description The groups linked to this identity in IDP
   */
  groups: () => new Field("groups"),

  /**
   * @description The NameID of the SAML identity
   */
  nameId: () => new Field("nameId"),

  /**
   * @description The userName of the SAML identity
   */
  username: () => new Field("username"),
};

export interface IExternalIdentityScimAttributes {
  readonly __typename: "ExternalIdentityScimAttributes";
  readonly emails: ReadonlyArray<IUserEmailMetadata> | null;
  readonly familyName: string | null;
  readonly givenName: string | null;
  readonly groups: ReadonlyArray<string> | null;
  readonly username: string | null;
}

interface ExternalIdentityScimAttributesSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The emails associated with the SCIM identity
   */

  readonly emails: <T extends Array<Selection>>(
    select: (t: UserEmailMetadataSelector) => T
  ) => Field<"emails", never, SelectionSet<T>>;

  /**
   * @description Family name of the SCIM identity
   */

  readonly familyName: () => Field<"familyName">;

  /**
   * @description Given name of the SCIM identity
   */

  readonly givenName: () => Field<"givenName">;

  /**
   * @description The groups linked to this identity in IDP
   */

  readonly groups: () => Field<"groups">;

  /**
   * @description The userName of the SCIM identity
   */

  readonly username: () => Field<"username">;
}

export const ExternalIdentityScimAttributes: ExternalIdentityScimAttributesSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The emails associated with the SCIM identity
   */

  emails: (select) =>
    new Field(
      "emails",
      undefined as never,
      new SelectionSet(select(UserEmailMetadata))
    ),

  /**
   * @description Family name of the SCIM identity
   */
  familyName: () => new Field("familyName"),

  /**
   * @description Given name of the SCIM identity
   */
  givenName: () => new Field("givenName"),

  /**
   * @description The groups linked to this identity in IDP
   */
  groups: () => new Field("groups"),

  /**
   * @description The userName of the SCIM identity
   */
  username: () => new Field("username"),
};

export interface IFollowUserPayload {
  readonly __typename: "FollowUserPayload";
  readonly clientMutationId: string | null;
  readonly user: IUser | null;
}

interface FollowUserPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The user that was followed.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const FollowUserPayload: FollowUserPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The user that was followed.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IFollowerConnection {
  readonly __typename: "FollowerConnection";
  readonly edges: ReadonlyArray<IUserEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface FollowerConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: UserEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const FollowerConnection: FollowerConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(UserEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IFollowingConnection {
  readonly __typename: "FollowingConnection";
  readonly edges: ReadonlyArray<IUserEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface FollowingConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: UserEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const FollowingConnection: FollowingConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(UserEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IFundingLink {
  readonly __typename: "FundingLink";
  readonly platform: FundingPlatform;
  readonly url: unknown;
}

interface FundingLinkSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The funding platform this link is for.
   */

  readonly platform: () => Field<"platform">;

  /**
   * @description The configured URL for this funding link.
   */

  readonly url: () => Field<"url">;
}

export const FundingLink: FundingLinkSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The funding platform this link is for.
   */
  platform: () => new Field("platform"),

  /**
   * @description The configured URL for this funding link.
   */
  url: () => new Field("url"),
};

export interface IGenericHovercardContext extends IHovercardContext {
  readonly __typename: "GenericHovercardContext";
}

interface GenericHovercardContextSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  readonly message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  readonly octicon: () => Field<"octicon">;
}

export const isGenericHovercardContext = (
  object: Record<string, any>
): object is Partial<IGenericHovercardContext> => {
  return object.__typename === "GenericHovercardContext";
};

export const GenericHovercardContext: GenericHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),
};

export interface IGist extends INode, IStarrable, IUniformResourceLocatable {
  readonly __typename: "Gist";
  readonly comments: IGistCommentConnection;
  readonly createdAt: unknown;
  readonly description: string | null;
  readonly files: ReadonlyArray<IGistFile> | null;
  readonly forks: IGistConnection;
  readonly isFork: boolean;
  readonly isPublic: boolean;
  readonly name: string;
  readonly owner: IRepositoryOwner | null;
  readonly pushedAt: unknown | null;
  readonly updatedAt: unknown;
}

interface GistSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of comments associated with the gist
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: GistCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The gist description.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The files in this gist.
   */

  readonly files: <T extends Array<Selection>>(
    variables: {
      limit?: Variable<"limit"> | number;
      oid?: Variable<"oid"> | unknown;
    },
    select: (t: GistFileSelector) => T
  ) => Field<
    "files",
    [
      Argument<"limit", Variable<"limit"> | number>,
      Argument<"oid", Variable<"oid"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of forks associated with the gist
   */

  readonly forks: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | GistOrder;
    },
    select: (t: GistConnectionSelector) => T
  ) => Field<
    "forks",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | GistOrder>
    ],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies if the gist is a fork.
   */

  readonly isFork: () => Field<"isFork">;

  /**
   * @description Whether the gist is public or not.
   */

  readonly isPublic: () => Field<"isPublic">;

  /**
   * @description The gist name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The gist owner.
   */

  readonly owner: <T extends Array<Selection>>(
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description Identifies when the gist was last pushed to.
   */

  readonly pushedAt: () => Field<"pushedAt">;

  /**
   * @description The HTML path to this resource.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Returns a count of how many stargazers there are on this object
   */

  readonly stargazerCount: () => Field<"stargazerCount">;

  /**
   * @description A list of users who have starred this starrable.
   */

  readonly stargazers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
    },
    select: (t: StargazerConnectionSelector) => T
  ) => Field<
    "stargazers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this Gist.
   */

  readonly url: () => Field<"url">;

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */

  readonly viewerHasStarred: () => Field<"viewerHasStarred">;
}

export const isGist = (
  object: Record<string, any>
): object is Partial<IGist> => {
  return object.__typename === "Gist";
};

export const Gist: GistSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of comments associated with the gist
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(GistCommentConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The gist description.
   */
  description: () => new Field("description"),

  /**
   * @description The files in this gist.
   */

  files: (variables, select) =>
    new Field(
      "files",
      [
        new Argument("limit", variables.limit),
        new Argument("oid", variables.oid),
      ],
      new SelectionSet(select(GistFile))
    ),

  /**
   * @description A list of forks associated with the gist
   */

  forks: (variables, select) =>
    new Field(
      "forks",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(GistConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description Identifies if the gist is a fork.
   */
  isFork: () => new Field("isFork"),

  /**
   * @description Whether the gist is public or not.
   */
  isPublic: () => new Field("isPublic"),

  /**
   * @description The gist name.
   */
  name: () => new Field("name"),

  /**
   * @description The gist owner.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description Identifies when the gist was last pushed to.
   */
  pushedAt: () => new Field("pushedAt"),

  /**
   * @description The HTML path to this resource.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Returns a count of how many stargazers there are on this object
   */
  stargazerCount: () => new Field("stargazerCount"),

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: (variables, select) =>
    new Field(
      "stargazers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(StargazerConnection))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this Gist.
   */
  url: () => new Field("url"),

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */
  viewerHasStarred: () => new Field("viewerHasStarred"),
};

export interface IGistComment
  extends IComment,
    IDeletable,
    IMinimizable,
    INode,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "GistComment";
  readonly databaseId: number | null;
  readonly gist: IGist;
}

interface GistCommentSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the gist.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Identifies the comment body.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  /**
   * @description The associated gist.
   */

  readonly gist: <T extends Array<Selection>>(
    select: (t: GistSelector) => T
  ) => Field<"gist", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  readonly isMinimized: () => Field<"isMinimized">;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Returns why the comment was minimized.
   */

  readonly minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  readonly viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  readonly viewerCanMinimize: () => Field<"viewerCanMinimize">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isGistComment = (
  object: Record<string, any>
): object is Partial<IGistComment> => {
  return object.__typename === "GistComment";
};

export const GistComment: GistCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the gist.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Identifies the comment body.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The associated gist.
   */

  gist: (select) =>
    new Field("gist", undefined as never, new SelectionSet(select(Gist))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface IGistCommentConnection {
  readonly __typename: "GistCommentConnection";
  readonly edges: ReadonlyArray<IGistCommentEdge> | null;
  readonly nodes: ReadonlyArray<IGistComment> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface GistCommentConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: GistCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: GistCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const GistCommentConnection: GistCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(GistCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(GistComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IGistCommentEdge {
  readonly __typename: "GistCommentEdge";
  readonly cursor: string;
  readonly node: IGistComment | null;
}

interface GistCommentEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: GistCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const GistCommentEdge: GistCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(GistComment))
    ),
};

export interface IGistConnection {
  readonly __typename: "GistConnection";
  readonly edges: ReadonlyArray<IGistEdge> | null;
  readonly nodes: ReadonlyArray<IGist> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface GistConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: GistEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: GistSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const GistConnection: GistConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(GistEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Gist))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IGistEdge {
  readonly __typename: "GistEdge";
  readonly cursor: string;
  readonly node: IGist | null;
}

interface GistEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: GistSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const GistEdge: GistEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Gist))),
};

export interface IGistFile {
  readonly __typename: "GistFile";
  readonly encodedName: string | null;
  readonly encoding: string | null;
  readonly extension: string | null;
  readonly isImage: boolean;
  readonly isTruncated: boolean;
  readonly language: ILanguage | null;
  readonly name: string | null;
  readonly size: number | null;
  readonly text: string | null;
}

interface GistFileSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The file name encoded to remove characters that are invalid in URL paths.
   */

  readonly encodedName: () => Field<"encodedName">;

  /**
   * @description The gist file encoding.
   */

  readonly encoding: () => Field<"encoding">;

  /**
   * @description The file extension from the file name.
   */

  readonly extension: () => Field<"extension">;

  /**
   * @description Indicates if this file is an image.
   */

  readonly isImage: () => Field<"isImage">;

  /**
   * @description Whether the file's contents were truncated.
   */

  readonly isTruncated: () => Field<"isTruncated">;

  /**
   * @description The programming language this file is written in.
   */

  readonly language: <T extends Array<Selection>>(
    select: (t: LanguageSelector) => T
  ) => Field<"language", never, SelectionSet<T>>;

  /**
   * @description The gist file name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The gist file size in bytes.
   */

  readonly size: () => Field<"size">;

  /**
   * @description UTF8 text data or null if the file is binary
   */

  readonly text: (variables: {
    truncate?: Variable<"truncate"> | number;
  }) => Field<"text", [Argument<"truncate", Variable<"truncate"> | number>]>;
}

export const GistFile: GistFileSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The file name encoded to remove characters that are invalid in URL paths.
   */
  encodedName: () => new Field("encodedName"),

  /**
   * @description The gist file encoding.
   */
  encoding: () => new Field("encoding"),

  /**
   * @description The file extension from the file name.
   */
  extension: () => new Field("extension"),

  /**
   * @description Indicates if this file is an image.
   */
  isImage: () => new Field("isImage"),

  /**
   * @description Whether the file's contents were truncated.
   */
  isTruncated: () => new Field("isTruncated"),

  /**
   * @description The programming language this file is written in.
   */

  language: (select) =>
    new Field(
      "language",
      undefined as never,
      new SelectionSet(select(Language))
    ),

  /**
   * @description The gist file name.
   */
  name: () => new Field("name"),

  /**
   * @description The gist file size in bytes.
   */
  size: () => new Field("size"),

  /**
   * @description UTF8 text data or null if the file is binary
   */
  text: (variables) => new Field("text"),
};

export interface IGitActor {
  readonly __typename: "GitActor";
  readonly avatarUrl: unknown;
  readonly date: unknown | null;
  readonly email: string | null;
  readonly name: string | null;
  readonly user: IUser | null;
}

interface GitActorSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the author's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description The timestamp of the Git action (authoring or committing).
   */

  readonly date: () => Field<"date">;

  /**
   * @description The email in the Git commit.
   */

  readonly email: () => Field<"email">;

  /**
   * @description The name in the Git commit.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The GitHub user corresponding to the email field. Null if no such user exists.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const GitActor: GitActorSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the author's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description The timestamp of the Git action (authoring or committing).
   */
  date: () => new Field("date"),

  /**
   * @description The email in the Git commit.
   */
  email: () => new Field("email"),

  /**
   * @description The name in the Git commit.
   */
  name: () => new Field("name"),

  /**
   * @description The GitHub user corresponding to the email field. Null if no such user exists.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IGitActorConnection {
  readonly __typename: "GitActorConnection";
  readonly edges: ReadonlyArray<IGitActorEdge> | null;
  readonly nodes: ReadonlyArray<IGitActor> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface GitActorConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: GitActorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const GitActorConnection: GitActorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(GitActorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(GitActor))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IGitActorEdge {
  readonly __typename: "GitActorEdge";
  readonly cursor: string;
  readonly node: IGitActor | null;
}

interface GitActorEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const GitActorEdge: GitActorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(GitActor))),
};

export interface IGitHubMetadata {
  readonly __typename: "GitHubMetadata";
  readonly gitHubServicesSha: unknown;
  readonly gitIpAddresses: ReadonlyArray<string> | null;
  readonly hookIpAddresses: ReadonlyArray<string> | null;
  readonly importerIpAddresses: ReadonlyArray<string> | null;
  readonly isPasswordAuthenticationVerifiable: boolean;
  readonly pagesIpAddresses: ReadonlyArray<string> | null;
}

interface GitHubMetadataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Returns a String that's a SHA of `github-services`
   */

  readonly gitHubServicesSha: () => Field<"gitHubServicesSha">;

  /**
   * @description IP addresses that users connect to for git operations
   */

  readonly gitIpAddresses: () => Field<"gitIpAddresses">;

  /**
   * @description IP addresses that service hooks are sent from
   */

  readonly hookIpAddresses: () => Field<"hookIpAddresses">;

  /**
   * @description IP addresses that the importer connects from
   */

  readonly importerIpAddresses: () => Field<"importerIpAddresses">;

  /**
   * @description Whether or not users are verified
   */

  readonly isPasswordAuthenticationVerifiable: () => Field<"isPasswordAuthenticationVerifiable">;

  /**
   * @description IP addresses for GitHub Pages' A records
   */

  readonly pagesIpAddresses: () => Field<"pagesIpAddresses">;
}

export const GitHubMetadata: GitHubMetadataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Returns a String that's a SHA of `github-services`
   */
  gitHubServicesSha: () => new Field("gitHubServicesSha"),

  /**
   * @description IP addresses that users connect to for git operations
   */
  gitIpAddresses: () => new Field("gitIpAddresses"),

  /**
   * @description IP addresses that service hooks are sent from
   */
  hookIpAddresses: () => new Field("hookIpAddresses"),

  /**
   * @description IP addresses that the importer connects from
   */
  importerIpAddresses: () => new Field("importerIpAddresses"),

  /**
   * @description Whether or not users are verified
   */
  isPasswordAuthenticationVerifiable: () =>
    new Field("isPasswordAuthenticationVerifiable"),

  /**
   * @description IP addresses for GitHub Pages' A records
   */
  pagesIpAddresses: () => new Field("pagesIpAddresses"),
};

export interface IGitObject {
  readonly __typename: string;
  readonly abbreviatedOid: string;
  readonly commitResourcePath: unknown;
  readonly commitUrl: unknown;
  readonly id: string;
  readonly oid: unknown;
  readonly repository: IRepository;
}

interface GitObjectSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  readonly abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description The HTTP path for this Git object
   */

  readonly commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  readonly commitUrl: () => Field<"commitUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The Git object ID
   */

  readonly oid: () => Field<"oid">;

  /**
   * @description The Repository the Git object belongs to
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  readonly on: <
    T extends Array<Selection>,
    F extends "Blob" | "Commit" | "Tag" | "Tree"
  >(
    type: F,
    select: (
      t: F extends "Blob"
        ? BlobSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "Tag"
        ? TagSelector
        : F extends "Tree"
        ? TreeSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const GitObject: GitObjectSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),
  id: () => new Field("id"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The Repository the Git object belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  on: (type, select) => {
    switch (type) {
      case "Blob": {
        return new InlineFragment(
          new NamedType("Blob") as any,
          new SelectionSet(select(Blob as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "Tag": {
        return new InlineFragment(
          new NamedType("Tag") as any,
          new SelectionSet(select(Tag as any))
        );
      }

      case "Tree": {
        return new InlineFragment(
          new NamedType("Tree") as any,
          new SelectionSet(select(Tree as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "GitObject",
        });
    }
  },
};

export interface IGitSignature {
  readonly __typename: string;
  readonly email: string;
  readonly isValid: boolean;
  readonly payload: string;
  readonly signature: string;
  readonly signer: IUser | null;
  readonly state: GitSignatureState;
  readonly wasSignedByGitHub: boolean;
}

interface GitSignatureSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Email used to sign this object.
   */

  readonly email: () => Field<"email">;

  /**
   * @description True if the signature is valid and verified by GitHub.
   */

  readonly isValid: () => Field<"isValid">;

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */

  readonly payload: () => Field<"payload">;

  /**
   * @description ASCII-armored signature header from object.
   */

  readonly signature: () => Field<"signature">;

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  readonly signer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"signer", never, SelectionSet<T>>;

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */

  readonly state: () => Field<"state">;

  /**
   * @description True if the signature was made with GitHub's signing key.
   */

  readonly wasSignedByGitHub: () => Field<"wasSignedByGitHub">;

  readonly on: <
    T extends Array<Selection>,
    F extends "GpgSignature" | "SmimeSignature" | "UnknownSignature"
  >(
    type: F,
    select: (
      t: F extends "GpgSignature"
        ? GpgSignatureSelector
        : F extends "SmimeSignature"
        ? SmimeSignatureSelector
        : F extends "UnknownSignature"
        ? UnknownSignatureSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const GitSignature: GitSignatureSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Email used to sign this object.
   */
  email: () => new Field("email"),

  /**
   * @description True if the signature is valid and verified by GitHub.
   */
  isValid: () => new Field("isValid"),

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */
  payload: () => new Field("payload"),

  /**
   * @description ASCII-armored signature header from object.
   */
  signature: () => new Field("signature"),

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: (select) =>
    new Field("signer", undefined as never, new SelectionSet(select(User))),

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */
  state: () => new Field("state"),

  /**
   * @description True if the signature was made with GitHub's signing key.
   */
  wasSignedByGitHub: () => new Field("wasSignedByGitHub"),

  on: (type, select) => {
    switch (type) {
      case "GpgSignature": {
        return new InlineFragment(
          new NamedType("GpgSignature") as any,
          new SelectionSet(select(GpgSignature as any))
        );
      }

      case "SmimeSignature": {
        return new InlineFragment(
          new NamedType("SmimeSignature") as any,
          new SelectionSet(select(SmimeSignature as any))
        );
      }

      case "UnknownSignature": {
        return new InlineFragment(
          new NamedType("UnknownSignature") as any,
          new SelectionSet(select(UnknownSignature as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "GitSignature",
        });
    }
  },
};

export interface IGpgSignature extends IGitSignature {
  readonly __typename: "GpgSignature";
  readonly keyId: string | null;
}

interface GpgSignatureSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Email used to sign this object.
   */

  readonly email: () => Field<"email">;

  /**
   * @description True if the signature is valid and verified by GitHub.
   */

  readonly isValid: () => Field<"isValid">;

  /**
   * @description Hex-encoded ID of the key that signed this object.
   */

  readonly keyId: () => Field<"keyId">;

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */

  readonly payload: () => Field<"payload">;

  /**
   * @description ASCII-armored signature header from object.
   */

  readonly signature: () => Field<"signature">;

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  readonly signer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"signer", never, SelectionSet<T>>;

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */

  readonly state: () => Field<"state">;

  /**
   * @description True if the signature was made with GitHub's signing key.
   */

  readonly wasSignedByGitHub: () => Field<"wasSignedByGitHub">;
}

export const isGpgSignature = (
  object: Record<string, any>
): object is Partial<IGpgSignature> => {
  return object.__typename === "GpgSignature";
};

export const GpgSignature: GpgSignatureSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Email used to sign this object.
   */
  email: () => new Field("email"),

  /**
   * @description True if the signature is valid and verified by GitHub.
   */
  isValid: () => new Field("isValid"),

  /**
   * @description Hex-encoded ID of the key that signed this object.
   */
  keyId: () => new Field("keyId"),

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */
  payload: () => new Field("payload"),

  /**
   * @description ASCII-armored signature header from object.
   */
  signature: () => new Field("signature"),

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: (select) =>
    new Field("signer", undefined as never, new SelectionSet(select(User))),

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */
  state: () => new Field("state"),

  /**
   * @description True if the signature was made with GitHub's signing key.
   */
  wasSignedByGitHub: () => new Field("wasSignedByGitHub"),
};

export interface IHeadRefDeletedEvent extends INode {
  readonly __typename: "HeadRefDeletedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly headRef: IRef | null;
  readonly headRefName: string;
  readonly pullRequest: IPullRequest;
}

interface HeadRefDeletedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the Ref associated with the `head_ref_deleted` event.
   */

  readonly headRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"headRef", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the Ref associated with the `head_ref_deleted` event.
   */

  readonly headRefName: () => Field<"headRefName">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isHeadRefDeletedEvent = (
  object: Record<string, any>
): object is Partial<IHeadRefDeletedEvent> => {
  return object.__typename === "HeadRefDeletedEvent";
};

export const HeadRefDeletedEvent: HeadRefDeletedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the Ref associated with the `head_ref_deleted` event.
   */

  headRef: (select) =>
    new Field("headRef", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the name of the Ref associated with the `head_ref_deleted` event.
   */
  headRefName: () => new Field("headRefName"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IHeadRefForcePushedEvent extends INode {
  readonly __typename: "HeadRefForcePushedEvent";
  readonly actor: IActor | null;
  readonly afterCommit: ICommit | null;
  readonly beforeCommit: ICommit | null;
  readonly createdAt: unknown;
  readonly pullRequest: IPullRequest;
  readonly ref: IRef | null;
}

interface HeadRefForcePushedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the after commit SHA for the 'head_ref_force_pushed' event.
   */

  readonly afterCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"afterCommit", never, SelectionSet<T>>;

  /**
   * @description Identifies the before commit SHA for the 'head_ref_force_pushed' event.
   */

  readonly beforeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"beforeCommit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the fully qualified ref name for the 'head_ref_force_pushed' event.
   */

  readonly ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const isHeadRefForcePushedEvent = (
  object: Record<string, any>
): object is Partial<IHeadRefForcePushedEvent> => {
  return object.__typename === "HeadRefForcePushedEvent";
};

export const HeadRefForcePushedEvent: HeadRefForcePushedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the after commit SHA for the 'head_ref_force_pushed' event.
   */

  afterCommit: (select) =>
    new Field(
      "afterCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Identifies the before commit SHA for the 'head_ref_force_pushed' event.
   */

  beforeCommit: (select) =>
    new Field(
      "beforeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the fully qualified ref name for the 'head_ref_force_pushed' event.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IHeadRefRestoredEvent extends INode {
  readonly __typename: "HeadRefRestoredEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly pullRequest: IPullRequest;
}

interface HeadRefRestoredEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isHeadRefRestoredEvent = (
  object: Record<string, any>
): object is Partial<IHeadRefRestoredEvent> => {
  return object.__typename === "HeadRefRestoredEvent";
};

export const HeadRefRestoredEvent: HeadRefRestoredEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IHovercard {
  readonly __typename: "Hovercard";
  readonly contexts: ReadonlyArray<IHovercardContext>;
}

interface HovercardSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Each of the contexts for this hovercard
   */

  readonly contexts: <T extends Array<Selection>>(
    select: (t: HovercardContextSelector) => T
  ) => Field<"contexts", never, SelectionSet<T>>;
}

export const Hovercard: HovercardSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Each of the contexts for this hovercard
   */

  contexts: (select) =>
    new Field(
      "contexts",
      undefined as never,
      new SelectionSet(select(HovercardContext))
    ),
};

export interface IHovercardContext {
  readonly __typename: string;
  readonly message: string;
  readonly octicon: string;
}

interface HovercardContextSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  readonly message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  readonly octicon: () => Field<"octicon">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "GenericHovercardContext"
      | "OrganizationTeamsHovercardContext"
      | "OrganizationsHovercardContext"
      | "ReviewStatusHovercardContext"
      | "ViewerHovercardContext"
  >(
    type: F,
    select: (
      t: F extends "GenericHovercardContext"
        ? GenericHovercardContextSelector
        : F extends "OrganizationTeamsHovercardContext"
        ? OrganizationTeamsHovercardContextSelector
        : F extends "OrganizationsHovercardContext"
        ? OrganizationsHovercardContextSelector
        : F extends "ReviewStatusHovercardContext"
        ? ReviewStatusHovercardContextSelector
        : F extends "ViewerHovercardContext"
        ? ViewerHovercardContextSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const HovercardContext: HovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  on: (type, select) => {
    switch (type) {
      case "GenericHovercardContext": {
        return new InlineFragment(
          new NamedType("GenericHovercardContext") as any,
          new SelectionSet(select(GenericHovercardContext as any))
        );
      }

      case "OrganizationTeamsHovercardContext": {
        return new InlineFragment(
          new NamedType("OrganizationTeamsHovercardContext") as any,
          new SelectionSet(select(OrganizationTeamsHovercardContext as any))
        );
      }

      case "OrganizationsHovercardContext": {
        return new InlineFragment(
          new NamedType("OrganizationsHovercardContext") as any,
          new SelectionSet(select(OrganizationsHovercardContext as any))
        );
      }

      case "ReviewStatusHovercardContext": {
        return new InlineFragment(
          new NamedType("ReviewStatusHovercardContext") as any,
          new SelectionSet(select(ReviewStatusHovercardContext as any))
        );
      }

      case "ViewerHovercardContext": {
        return new InlineFragment(
          new NamedType("ViewerHovercardContext") as any,
          new SelectionSet(select(ViewerHovercardContext as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "HovercardContext",
        });
    }
  },
};

export interface IInviteEnterpriseAdminPayload {
  readonly __typename: "InviteEnterpriseAdminPayload";
  readonly clientMutationId: string | null;
  readonly invitation: IEnterpriseAdministratorInvitation | null;
}

interface InviteEnterpriseAdminPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The created enterprise administrator invitation.
   */

  readonly invitation: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"invitation", never, SelectionSet<T>>;
}

export const InviteEnterpriseAdminPayload: InviteEnterpriseAdminPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The created enterprise administrator invitation.
   */

  invitation: (select) =>
    new Field(
      "invitation",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),
};

export interface IIpAllowListEntry extends INode {
  readonly __typename: "IpAllowListEntry";
  readonly allowListValue: string;
  readonly createdAt: unknown;
  readonly isActive: boolean;
  readonly name: string | null;
  readonly owner: IIpAllowListOwner;
  readonly updatedAt: unknown;
}

interface IpAllowListEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A single IP address or range of IP addresses in CIDR notation.
   */

  readonly allowListValue: () => Field<"allowListValue">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the entry is currently active.
   */

  readonly isActive: () => Field<"isActive">;

  /**
   * @description The name of the IP allow list entry.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The owner of the IP allow list entry.
   */

  readonly owner: <T extends Array<Selection>>(
    select: (t: IpAllowListOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const isIpAllowListEntry = (
  object: Record<string, any>
): object is Partial<IIpAllowListEntry> => {
  return object.__typename === "IpAllowListEntry";
};

export const IpAllowListEntry: IpAllowListEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A single IP address or range of IP addresses in CIDR notation.
   */
  allowListValue: () => new Field("allowListValue"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the entry is currently active.
   */
  isActive: () => new Field("isActive"),

  /**
   * @description The name of the IP allow list entry.
   */
  name: () => new Field("name"),

  /**
   * @description The owner of the IP allow list entry.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(IpAllowListOwner))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IIpAllowListEntryConnection {
  readonly __typename: "IpAllowListEntryConnection";
  readonly edges: ReadonlyArray<IIpAllowListEntryEdge> | null;
  readonly nodes: ReadonlyArray<IIpAllowListEntry> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface IpAllowListEntryConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: IpAllowListEntryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const IpAllowListEntryConnection: IpAllowListEntryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(IpAllowListEntryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IIpAllowListEntryEdge {
  readonly __typename: "IpAllowListEntryEdge";
  readonly cursor: string;
  readonly node: IIpAllowListEntry | null;
}

interface IpAllowListEntryEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IpAllowListEntryEdge: IpAllowListEntryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),
};

export interface IIssue
  extends IAssignable,
    IClosable,
    IComment,
    ILabelable,
    ILockable,
    INode,
    IReactable,
    IRepositoryNode,
    ISubscribable,
    IUniformResourceLocatable,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "Issue";
  readonly bodyResourcePath: unknown;
  readonly bodyUrl: unknown;
  readonly comments: IIssueCommentConnection;
  readonly hovercard: IHovercard;
  readonly isReadByViewer: boolean | null;
  readonly milestone: IMilestone | null;
  readonly number: number;
  readonly participants: IUserConnection;
  readonly projectCards: IProjectCardConnection;
  readonly state: IssueState;
  readonly timeline: IIssueTimelineConnection;
  readonly timelineItems: IIssueTimelineItemsConnection;
  readonly title: string;
}

interface IssueSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Reason that the conversation was locked.
   */

  readonly activeLockReason: () => Field<"activeLockReason">;

  /**
   * @description A list of Users assigned to this object.
   */

  readonly assignees: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "assignees",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Identifies the body of the issue.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The http path for this issue body
   */

  readonly bodyResourcePath: () => Field<"bodyResourcePath">;

  /**
   * @description Identifies the body of the issue rendered to text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description The http URL for this issue body
   */

  readonly bodyUrl: () => Field<"bodyUrl">;

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */

  readonly closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  readonly closedAt: () => Field<"closedAt">;

  /**
   * @description A list of comments associated with the Issue.
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueCommentOrder;
    },
    select: (t: IssueCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueCommentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  /**
   * @description The hovercard information for this issue
   */

  readonly hovercard: <T extends Array<Selection>>(
    variables: {
      includeNotificationContexts?:
        | Variable<"includeNotificationContexts">
        | boolean;
    },
    select: (t: HovercardSelector) => T
  ) => Field<
    "hovercard",
    [
      Argument<
        "includeNotificationContexts",
        Variable<"includeNotificationContexts"> | boolean
      >
    ],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Is this issue read by the viewer
   */

  readonly isReadByViewer: () => Field<"isReadByViewer">;

  /**
   * @description A list of labels associated with the object.
   */

  readonly labels: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LabelOrder;
    },
    select: (t: LabelConnectionSelector) => T
  ) => Field<
    "labels",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LabelOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description `true` if the object is locked
   */

  readonly locked: () => Field<"locked">;

  /**
   * @description Identifies the milestone associated with the issue.
   */

  readonly milestone: <T extends Array<Selection>>(
    select: (t: MilestoneSelector) => T
  ) => Field<"milestone", never, SelectionSet<T>>;

  /**
   * @description Identifies the issue number.
   */

  readonly number: () => Field<"number">;

  /**
   * @description A list of Users that are participating in the Issue conversation.
   */

  readonly participants: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "participants",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description List of project cards associated with this issue.
   */

  readonly projectCards: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      archivedStates?: Variable<"archivedStates"> | ProjectCardArchivedState;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectCardConnectionSelector) => T
  ) => Field<
    "projectCards",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<
        "archivedStates",
        Variable<"archivedStates"> | ProjectCardArchivedState
      >,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this issue
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the state of the issue.
   */

  readonly state: () => Field<"state">;

  /**
   * @description A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */

  readonly timeline: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      since?: Variable<"since"> | unknown;
    },
    select: (t: IssueTimelineConnectionSelector) => T
  ) => Field<
    "timeline",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"since", Variable<"since"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of events, comments, commits, etc. associated with the issue.
   */

  readonly timelineItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      itemTypes?: Variable<"itemTypes"> | IssueTimelineItemsItemType;
      last?: Variable<"last"> | number;
      since?: Variable<"since"> | unknown;
      skip?: Variable<"skip"> | number;
    },
    select: (t: IssueTimelineItemsConnectionSelector) => T
  ) => Field<
    "timelineItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"itemTypes", Variable<"itemTypes"> | IssueTimelineItemsItemType>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"since", Variable<"since"> | unknown>,
      Argument<"skip", Variable<"skip"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the issue title.
   */

  readonly title: () => Field<"title">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this issue
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  readonly viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  readonly viewerSubscription: () => Field<"viewerSubscription">;
}

export const isIssue = (
  object: Record<string, any>
): object is Partial<IIssue> => {
  return object.__typename === "Issue";
};

export const Issue: IssueSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Reason that the conversation was locked.
   */
  activeLockReason: () => new Field("activeLockReason"),

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: (variables, select) =>
    new Field(
      "assignees",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Identifies the body of the issue.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The http path for this issue body
   */
  bodyResourcePath: () => new Field("bodyResourcePath"),

  /**
   * @description Identifies the body of the issue rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description The http URL for this issue body
   */
  bodyUrl: () => new Field("bodyUrl"),

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  /**
   * @description A list of comments associated with the Issue.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IssueCommentConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The hovercard information for this issue
   */

  hovercard: (variables, select) =>
    new Field(
      "hovercard",
      [
        new Argument(
          "includeNotificationContexts",
          variables.includeNotificationContexts
        ),
      ],
      new SelectionSet(select(Hovercard))
    ),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Is this issue read by the viewer
   */
  isReadByViewer: () => new Field("isReadByViewer"),

  /**
   * @description A list of labels associated with the object.
   */

  labels: (variables, select) =>
    new Field(
      "labels",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(LabelConnection))
    ),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description `true` if the object is locked
   */
  locked: () => new Field("locked"),

  /**
   * @description Identifies the milestone associated with the issue.
   */

  milestone: (select) =>
    new Field(
      "milestone",
      undefined as never,
      new SelectionSet(select(Milestone))
    ),

  /**
   * @description Identifies the issue number.
   */
  number: () => new Field("number"),

  /**
   * @description A list of Users that are participating in the Issue conversation.
   */

  participants: (variables, select) =>
    new Field(
      "participants",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description List of project cards associated with this issue.
   */

  projectCards: (variables, select) =>
    new Field(
      "projectCards",
      [
        new Argument("after", variables.after),
        new Argument(
          "archivedStates",
          variables.archivedStates,
          ProjectCardArchivedState
        ),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectCardConnection))
    ),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this issue
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the state of the issue.
   */
  state: () => new Field("state"),

  /**
   * @description A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */

  timeline: (variables, select) =>
    new Field(
      "timeline",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("since", variables.since),
      ],
      new SelectionSet(select(IssueTimelineConnection))
    ),

  /**
   * @description A list of events, comments, commits, etc. associated with the issue.
   */

  timelineItems: (variables, select) =>
    new Field(
      "timelineItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument(
          "itemTypes",
          variables.itemTypes,
          IssueTimelineItemsItemType
        ),
        new Argument("last", variables.last),
        new Argument("since", variables.since),
        new Argument("skip", variables.skip),
      ],
      new SelectionSet(select(IssueTimelineItemsConnection))
    ),

  /**
   * @description Identifies the issue title.
   */
  title: () => new Field("title"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this issue
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),
};

export interface IIssueComment
  extends IComment,
    IDeletable,
    IMinimizable,
    INode,
    IReactable,
    IRepositoryNode,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "IssueComment";
  readonly issue: IIssue;
  readonly pullRequest: IPullRequest | null;
  readonly resourcePath: unknown;
  readonly url: unknown;
}

interface IssueCommentSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The body as Markdown.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  readonly isMinimized: () => Field<"isMinimized">;

  /**
   * @description Identifies the issue associated with the comment.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Returns why the comment was minimized.
   */

  readonly minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
     * @description Returns the pull request associated with the comment, if this comment was made on a
pull request.
     */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this issue comment
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this issue comment
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  readonly viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  readonly viewerCanMinimize: () => Field<"viewerCanMinimize">;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isIssueComment = (
  object: Record<string, any>
): object is Partial<IIssueComment> => {
  return object.__typename === "IssueComment";
};

export const IssueComment: IssueCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description Identifies the issue associated with the comment.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
     * @description Returns the pull request associated with the comment, if this comment was made on a
pull request.
     */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this issue comment
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this issue comment
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface IIssueCommentConnection {
  readonly __typename: "IssueCommentConnection";
  readonly edges: ReadonlyArray<IIssueCommentEdge> | null;
  readonly nodes: ReadonlyArray<IIssueComment> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface IssueCommentConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: IssueCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: IssueCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const IssueCommentConnection: IssueCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(IssueCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(IssueComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IIssueCommentEdge {
  readonly __typename: "IssueCommentEdge";
  readonly cursor: string;
  readonly node: IIssueComment | null;
}

interface IssueCommentEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: IssueCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IssueCommentEdge: IssueCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(IssueComment))
    ),
};

export interface IIssueConnection {
  readonly __typename: "IssueConnection";
  readonly edges: ReadonlyArray<IIssueEdge> | null;
  readonly nodes: ReadonlyArray<IIssue> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface IssueConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: IssueEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const IssueConnection: IssueConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(IssueEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Issue))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IIssueContributionsByRepository {
  readonly __typename: "IssueContributionsByRepository";
  readonly contributions: ICreatedIssueContributionConnection;
  readonly repository: IRepository;
}

interface IssueContributionsByRepositorySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The issue contributions.
   */

  readonly contributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedIssueContributionConnectionSelector) => T
  ) => Field<
    "contributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository in which the issues were opened.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const IssueContributionsByRepository: IssueContributionsByRepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The issue contributions.
   */

  contributions: (variables, select) =>
    new Field(
      "contributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedIssueContributionConnection))
    ),

  /**
   * @description The repository in which the issues were opened.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IIssueEdge {
  readonly __typename: "IssueEdge";
  readonly cursor: string;
  readonly node: IIssue | null;
}

interface IssueEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IssueEdge: IssueEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Issue))),
};

export interface IIssueTemplate {
  readonly __typename: "IssueTemplate";
  readonly about: string | null;
  readonly body: string | null;
  readonly name: string;
  readonly title: string | null;
}

interface IssueTemplateSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The template purpose.
   */

  readonly about: () => Field<"about">;

  /**
   * @description The suggested issue body.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The template name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The suggested issue title.
   */

  readonly title: () => Field<"title">;
}

export const IssueTemplate: IssueTemplateSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The template purpose.
   */
  about: () => new Field("about"),

  /**
   * @description The suggested issue body.
   */
  body: () => new Field("body"),

  /**
   * @description The template name.
   */
  name: () => new Field("name"),

  /**
   * @description The suggested issue title.
   */
  title: () => new Field("title"),
};

export interface IIssueTimelineConnection {
  readonly __typename: "IssueTimelineConnection";
  readonly edges: ReadonlyArray<IIssueTimelineItemEdge> | null;
  readonly nodes: ReadonlyArray<IIssueTimelineItem> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface IssueTimelineConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const IssueTimelineConnection: IssueTimelineConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(IssueTimelineItemEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(IssueTimelineItem))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IIssueTimelineItemEdge {
  readonly __typename: "IssueTimelineItemEdge";
  readonly cursor: string;
  readonly node: IIssueTimelineItem | null;
}

interface IssueTimelineItemEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IssueTimelineItemEdge: IssueTimelineItemEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(IssueTimelineItem))
    ),
};

export interface IIssueTimelineItemsConnection {
  readonly __typename: "IssueTimelineItemsConnection";
  readonly edges: ReadonlyArray<IIssueTimelineItemsEdge> | null;
  readonly filteredCount: number;
  readonly nodes: ReadonlyArray<IIssueTimelineItems> | null;
  readonly pageCount: number;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
  readonly updatedAt: unknown;
}

interface IssueTimelineItemsConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemsEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description Identifies the count of items after applying `before` and `after` filters.
   */

  readonly filteredCount: () => Field<"filteredCount">;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemsSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
   */

  readonly pageCount: () => Field<"pageCount">;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;

  /**
   * @description Identifies the date and time when the timeline was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const IssueTimelineItemsConnection: IssueTimelineItemsConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(IssueTimelineItemsEdge))
    ),

  /**
   * @description Identifies the count of items after applying `before` and `after` filters.
   */
  filteredCount: () => new Field("filteredCount"),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(IssueTimelineItems))
    ),

  /**
   * @description Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
   */
  pageCount: () => new Field("pageCount"),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description Identifies the date and time when the timeline was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IIssueTimelineItemsEdge {
  readonly __typename: "IssueTimelineItemsEdge";
  readonly cursor: string;
  readonly node: IIssueTimelineItems | null;
}

interface IssueTimelineItemsEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemsSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IssueTimelineItemsEdge: IssueTimelineItemsEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(IssueTimelineItems))
    ),
};

export interface IJoinedGitHubContribution extends IContribution {
  readonly __typename: "JoinedGitHubContribution";
}

interface JoinedGitHubContributionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  readonly isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  readonly occurredAt: () => Field<"occurredAt">;

  /**
   * @description The HTTP path for this contribution.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isJoinedGitHubContribution = (
  object: Record<string, any>
): object is Partial<IJoinedGitHubContribution> => {
  return object.__typename === "JoinedGitHubContribution";
};

export const JoinedGitHubContribution: JoinedGitHubContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ILabel extends INode {
  readonly __typename: "Label";
  readonly color: string;
  readonly createdAt: unknown | null;
  readonly description: string | null;
  readonly isDefault: boolean;
  readonly issues: IIssueConnection;
  readonly name: string;
  readonly pullRequests: IPullRequestConnection;
  readonly repository: IRepository;
  readonly resourcePath: unknown;
  readonly updatedAt: unknown | null;
  readonly url: unknown;
}

interface LabelSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the label color.
   */

  readonly color: () => Field<"color">;

  /**
   * @description Identifies the date and time when the label was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description A brief description of this label.
   */

  readonly description: () => Field<"description">;

  readonly id: () => Field<"id">;

  /**
   * @description Indicates whether or not this is a default label.
   */

  readonly isDefault: () => Field<"isDefault">;

  /**
   * @description A list of issues associated with this label.
   */

  readonly issues: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | IssueFilters;
      first?: Variable<"first"> | number;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | IssueState;
    },
    select: (t: IssueConnectionSelector) => T
  ) => Field<
    "issues",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | IssueFilters>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | IssueState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the label name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description A list of pull requests associated with this label.
   */

  readonly pullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "pullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this label.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this label.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the label was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this label.
   */

  readonly url: () => Field<"url">;
}

export const isLabel = (
  object: Record<string, any>
): object is Partial<ILabel> => {
  return object.__typename === "Label";
};

export const Label: LabelSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the label color.
   */
  color: () => new Field("color"),

  /**
   * @description Identifies the date and time when the label was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description A brief description of this label.
   */
  description: () => new Field("description"),
  id: () => new Field("id"),

  /**
   * @description Indicates whether or not this is a default label.
   */
  isDefault: () => new Field("isDefault"),

  /**
   * @description A list of issues associated with this label.
   */

  issues: (variables, select) =>
    new Field(
      "issues",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, IssueState),
      ],
      new SelectionSet(select(IssueConnection))
    ),

  /**
   * @description Identifies the label name.
   */
  name: () => new Field("name"),

  /**
   * @description A list of pull requests associated with this label.
   */

  pullRequests: (variables, select) =>
    new Field(
      "pullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description The repository associated with this label.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this label.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the label was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this label.
   */
  url: () => new Field("url"),
};

export interface ILabelConnection {
  readonly __typename: "LabelConnection";
  readonly edges: ReadonlyArray<ILabelEdge> | null;
  readonly nodes: ReadonlyArray<ILabel> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface LabelConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: LabelEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: LabelSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const LabelConnection: LabelConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(LabelEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Label))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ILabelEdge {
  readonly __typename: "LabelEdge";
  readonly cursor: string;
  readonly node: ILabel | null;
}

interface LabelEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: LabelSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const LabelEdge: LabelEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Label))),
};

export interface ILabelable {
  readonly __typename: string;
  readonly labels: ILabelConnection | null;
}

interface LabelableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of labels associated with the object.
   */

  readonly labels: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LabelOrder;
    },
    select: (t: LabelConnectionSelector) => T
  ) => Field<
    "labels",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LabelOrder>
    ],
    SelectionSet<T>
  >;

  readonly on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Labelable: LabelableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of labels associated with the object.
   */

  labels: (variables, select) =>
    new Field(
      "labels",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(LabelConnection))
    ),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Labelable",
        });
    }
  },
};

export interface ILabeledEvent extends INode {
  readonly __typename: "LabeledEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly label: ILabel;
  readonly labelable: ILabelable;
}

interface LabeledEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the label associated with the 'labeled' event.
   */

  readonly label: <T extends Array<Selection>>(
    select: (t: LabelSelector) => T
  ) => Field<"label", never, SelectionSet<T>>;

  /**
   * @description Identifies the `Labelable` associated with the event.
   */

  readonly labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const isLabeledEvent = (
  object: Record<string, any>
): object is Partial<ILabeledEvent> => {
  return object.__typename === "LabeledEvent";
};

export const LabeledEvent: LabeledEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the label associated with the 'labeled' event.
   */

  label: (select) =>
    new Field("label", undefined as never, new SelectionSet(select(Label))),

  /**
   * @description Identifies the `Labelable` associated with the event.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface ILanguage extends INode {
  readonly __typename: "Language";
  readonly color: string | null;
  readonly name: string;
}

interface LanguageSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The color defined for the current language.
   */

  readonly color: () => Field<"color">;

  readonly id: () => Field<"id">;

  /**
   * @description The name of the current language.
   */

  readonly name: () => Field<"name">;
}

export const isLanguage = (
  object: Record<string, any>
): object is Partial<ILanguage> => {
  return object.__typename === "Language";
};

export const Language: LanguageSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The color defined for the current language.
   */
  color: () => new Field("color"),
  id: () => new Field("id"),

  /**
   * @description The name of the current language.
   */
  name: () => new Field("name"),
};

export interface ILanguageConnection {
  readonly __typename: "LanguageConnection";
  readonly edges: ReadonlyArray<ILanguageEdge> | null;
  readonly nodes: ReadonlyArray<ILanguage> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
  readonly totalSize: number;
}

interface LanguageConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: LanguageEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: LanguageSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;

  /**
   * @description The total size in bytes of files written in that language.
   */

  readonly totalSize: () => Field<"totalSize">;
}

export const LanguageConnection: LanguageConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(LanguageEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Language))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description The total size in bytes of files written in that language.
   */
  totalSize: () => new Field("totalSize"),
};

export interface ILanguageEdge {
  readonly __typename: "LanguageEdge";
  readonly cursor: string;
  readonly node: ILanguage;
  readonly size: number;
}

interface LanguageEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  readonly cursor: () => Field<"cursor">;

  readonly node: <T extends Array<Selection>>(
    select: (t: LanguageSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The number of bytes of code written in the language.
   */

  readonly size: () => Field<"size">;
}

export const LanguageEdge: LanguageEdgeSelector = {
  __typename: () => new Field("__typename"),

  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Language))),

  /**
   * @description The number of bytes of code written in the language.
   */
  size: () => new Field("size"),
};

export interface ILicense extends INode {
  readonly __typename: "License";
  readonly body: string;
  readonly conditions: ReadonlyArray<ILicenseRule>;
  readonly description: string | null;
  readonly featured: boolean;
  readonly hidden: boolean;
  readonly implementation: string | null;
  readonly key: string;
  readonly limitations: ReadonlyArray<ILicenseRule>;
  readonly name: string;
  readonly nickname: string | null;
  readonly permissions: ReadonlyArray<ILicenseRule>;
  readonly pseudoLicense: boolean;
  readonly spdxId: string | null;
  readonly url: unknown | null;
}

interface LicenseSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The full text of the license
   */

  readonly body: () => Field<"body">;

  /**
   * @description The conditions set by the license
   */

  readonly conditions: <T extends Array<Selection>>(
    select: (t: LicenseRuleSelector) => T
  ) => Field<"conditions", never, SelectionSet<T>>;

  /**
   * @description A human-readable description of the license
   */

  readonly description: () => Field<"description">;

  /**
   * @description Whether the license should be featured
   */

  readonly featured: () => Field<"featured">;

  /**
   * @description Whether the license should be displayed in license pickers
   */

  readonly hidden: () => Field<"hidden">;

  readonly id: () => Field<"id">;

  /**
   * @description Instructions on how to implement the license
   */

  readonly implementation: () => Field<"implementation">;

  /**
   * @description The lowercased SPDX ID of the license
   */

  readonly key: () => Field<"key">;

  /**
   * @description The limitations set by the license
   */

  readonly limitations: <T extends Array<Selection>>(
    select: (t: LicenseRuleSelector) => T
  ) => Field<"limitations", never, SelectionSet<T>>;

  /**
   * @description The license full name specified by <https://spdx.org/licenses>
   */

  readonly name: () => Field<"name">;

  /**
   * @description Customary short name if applicable (e.g, GPLv3)
   */

  readonly nickname: () => Field<"nickname">;

  /**
   * @description The permissions set by the license
   */

  readonly permissions: <T extends Array<Selection>>(
    select: (t: LicenseRuleSelector) => T
  ) => Field<"permissions", never, SelectionSet<T>>;

  /**
   * @description Whether the license is a pseudo-license placeholder (e.g., other, no-license)
   */

  readonly pseudoLicense: () => Field<"pseudoLicense">;

  /**
   * @description Short identifier specified by <https://spdx.org/licenses>
   */

  readonly spdxId: () => Field<"spdxId">;

  /**
   * @description URL to the license on <https://choosealicense.com>
   */

  readonly url: () => Field<"url">;
}

export const isLicense = (
  object: Record<string, any>
): object is Partial<ILicense> => {
  return object.__typename === "License";
};

export const License: LicenseSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The full text of the license
   */
  body: () => new Field("body"),

  /**
   * @description The conditions set by the license
   */

  conditions: (select) =>
    new Field(
      "conditions",
      undefined as never,
      new SelectionSet(select(LicenseRule))
    ),

  /**
   * @description A human-readable description of the license
   */
  description: () => new Field("description"),

  /**
   * @description Whether the license should be featured
   */
  featured: () => new Field("featured"),

  /**
   * @description Whether the license should be displayed in license pickers
   */
  hidden: () => new Field("hidden"),
  id: () => new Field("id"),

  /**
   * @description Instructions on how to implement the license
   */
  implementation: () => new Field("implementation"),

  /**
   * @description The lowercased SPDX ID of the license
   */
  key: () => new Field("key"),

  /**
   * @description The limitations set by the license
   */

  limitations: (select) =>
    new Field(
      "limitations",
      undefined as never,
      new SelectionSet(select(LicenseRule))
    ),

  /**
   * @description The license full name specified by <https://spdx.org/licenses>
   */
  name: () => new Field("name"),

  /**
   * @description Customary short name if applicable (e.g, GPLv3)
   */
  nickname: () => new Field("nickname"),

  /**
   * @description The permissions set by the license
   */

  permissions: (select) =>
    new Field(
      "permissions",
      undefined as never,
      new SelectionSet(select(LicenseRule))
    ),

  /**
   * @description Whether the license is a pseudo-license placeholder (e.g., other, no-license)
   */
  pseudoLicense: () => new Field("pseudoLicense"),

  /**
   * @description Short identifier specified by <https://spdx.org/licenses>
   */
  spdxId: () => new Field("spdxId"),

  /**
   * @description URL to the license on <https://choosealicense.com>
   */
  url: () => new Field("url"),
};

export interface ILicenseRule {
  readonly __typename: "LicenseRule";
  readonly description: string;
  readonly key: string;
  readonly label: string;
}

interface LicenseRuleSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A description of the rule
   */

  readonly description: () => Field<"description">;

  /**
   * @description The machine-readable rule key
   */

  readonly key: () => Field<"key">;

  /**
   * @description The human-readable rule label
   */

  readonly label: () => Field<"label">;
}

export const LicenseRule: LicenseRuleSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A description of the rule
   */
  description: () => new Field("description"),

  /**
   * @description The machine-readable rule key
   */
  key: () => new Field("key"),

  /**
   * @description The human-readable rule label
   */
  label: () => new Field("label"),
};

export interface ILinkRepositoryToProjectPayload {
  readonly __typename: "LinkRepositoryToProjectPayload";
  readonly clientMutationId: string | null;
  readonly project: IProject | null;
  readonly repository: IRepository | null;
}

interface LinkRepositoryToProjectPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The linked Project.
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;

  /**
   * @description The linked Repository.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const LinkRepositoryToProjectPayload: LinkRepositoryToProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The linked Project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description The linked Repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ILockLockablePayload {
  readonly __typename: "LockLockablePayload";
  readonly actor: IActor | null;
  readonly clientMutationId: string | null;
  readonly lockedRecord: ILockable | null;
}

interface LockLockablePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The item that was locked.
   */

  readonly lockedRecord: <T extends Array<Selection>>(
    select: (t: LockableSelector) => T
  ) => Field<"lockedRecord", never, SelectionSet<T>>;
}

export const LockLockablePayload: LockLockablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The item that was locked.
   */

  lockedRecord: (select) =>
    new Field(
      "lockedRecord",
      undefined as never,
      new SelectionSet(select(Lockable))
    ),
};

export interface ILockable {
  readonly __typename: string;
  readonly activeLockReason: LockReason | null;
  readonly locked: boolean;
}

interface LockableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Reason that the conversation was locked.
   */

  readonly activeLockReason: () => Field<"activeLockReason">;

  /**
   * @description `true` if the object is locked
   */

  readonly locked: () => Field<"locked">;

  readonly on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Lockable: LockableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Reason that the conversation was locked.
   */
  activeLockReason: () => new Field("activeLockReason"),

  /**
   * @description `true` if the object is locked
   */
  locked: () => new Field("locked"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Lockable",
        });
    }
  },
};

export interface ILockedEvent extends INode {
  readonly __typename: "LockedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly lockReason: LockReason | null;
  readonly lockable: ILockable;
}

interface LockedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Reason that the conversation was locked (optional).
   */

  readonly lockReason: () => Field<"lockReason">;

  /**
   * @description Object that was locked.
   */

  readonly lockable: <T extends Array<Selection>>(
    select: (t: LockableSelector) => T
  ) => Field<"lockable", never, SelectionSet<T>>;
}

export const isLockedEvent = (
  object: Record<string, any>
): object is Partial<ILockedEvent> => {
  return object.__typename === "LockedEvent";
};

export const LockedEvent: LockedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reason that the conversation was locked (optional).
   */
  lockReason: () => new Field("lockReason"),

  /**
   * @description Object that was locked.
   */

  lockable: (select) =>
    new Field(
      "lockable",
      undefined as never,
      new SelectionSet(select(Lockable))
    ),
};

export interface IMannequin extends IActor, INode, IUniformResourceLocatable {
  readonly __typename: "Mannequin";
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly email: string | null;
  readonly updatedAt: unknown;
}

interface MannequinSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the GitHub App's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The mannequin's email on the source instance.
   */

  readonly email: () => Field<"email">;

  readonly id: () => Field<"id">;

  /**
   * @description The username of the actor.
   */

  readonly login: () => Field<"login">;

  /**
   * @description The HTML path to this resource.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The URL to this resource.
   */

  readonly url: () => Field<"url">;
}

export const isMannequin = (
  object: Record<string, any>
): object is Partial<IMannequin> => {
  return object.__typename === "Mannequin";
};

export const Mannequin: MannequinSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the GitHub App's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The mannequin's email on the source instance.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description The username of the actor.
   */
  login: () => new Field("login"),

  /**
   * @description The HTML path to this resource.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The URL to this resource.
   */
  url: () => new Field("url"),
};

export interface IMarkFileAsViewedPayload {
  readonly __typename: "MarkFileAsViewedPayload";
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
}

interface MarkFileAsViewedPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated pull request.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const MarkFileAsViewedPayload: MarkFileAsViewedPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated pull request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IMarkPullRequestReadyForReviewPayload {
  readonly __typename: "MarkPullRequestReadyForReviewPayload";
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
}

interface MarkPullRequestReadyForReviewPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that is ready for review.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const MarkPullRequestReadyForReviewPayload: MarkPullRequestReadyForReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that is ready for review.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IMarkedAsDuplicateEvent extends INode {
  readonly __typename: "MarkedAsDuplicateEvent";
  readonly actor: IActor | null;
  readonly canonical: IIssueOrPullRequest | null;
  readonly createdAt: unknown;
  readonly duplicate: IIssueOrPullRequest | null;
  readonly isCrossRepository: boolean;
}

interface MarkedAsDuplicateEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The authoritative issue or pull request which has been duplicated by another.
   */

  readonly canonical: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"canonical", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The issue or pull request which has been marked as a duplicate of another.
   */

  readonly duplicate: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"duplicate", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Canonical and duplicate belong to different repositories.
   */

  readonly isCrossRepository: () => Field<"isCrossRepository">;
}

export const isMarkedAsDuplicateEvent = (
  object: Record<string, any>
): object is Partial<IMarkedAsDuplicateEvent> => {
  return object.__typename === "MarkedAsDuplicateEvent";
};

export const MarkedAsDuplicateEvent: MarkedAsDuplicateEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The authoritative issue or pull request which has been duplicated by another.
   */

  canonical: (select) =>
    new Field(
      "canonical",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The issue or pull request which has been marked as a duplicate of another.
   */

  duplicate: (select) =>
    new Field(
      "duplicate",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),

  id: () => new Field("id"),

  /**
   * @description Canonical and duplicate belong to different repositories.
   */
  isCrossRepository: () => new Field("isCrossRepository"),
};

export interface IMarketplaceCategory extends INode {
  readonly __typename: "MarketplaceCategory";
  readonly description: string | null;
  readonly howItWorks: string | null;
  readonly name: string;
  readonly primaryListingCount: number;
  readonly resourcePath: unknown;
  readonly secondaryListingCount: number;
  readonly slug: string;
  readonly url: unknown;
}

interface MarketplaceCategorySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The category's description.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The technical description of how apps listed in this category work with GitHub.
   */

  readonly howItWorks: () => Field<"howItWorks">;

  readonly id: () => Field<"id">;

  /**
   * @description The category's name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description How many Marketplace listings have this as their primary category.
   */

  readonly primaryListingCount: () => Field<"primaryListingCount">;

  /**
   * @description The HTTP path for this Marketplace category.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description How many Marketplace listings have this as their secondary category.
   */

  readonly secondaryListingCount: () => Field<"secondaryListingCount">;

  /**
   * @description The short name of the category used in its URL.
   */

  readonly slug: () => Field<"slug">;

  /**
   * @description The HTTP URL for this Marketplace category.
   */

  readonly url: () => Field<"url">;
}

export const isMarketplaceCategory = (
  object: Record<string, any>
): object is Partial<IMarketplaceCategory> => {
  return object.__typename === "MarketplaceCategory";
};

export const MarketplaceCategory: MarketplaceCategorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The category's description.
   */
  description: () => new Field("description"),

  /**
   * @description The technical description of how apps listed in this category work with GitHub.
   */
  howItWorks: () => new Field("howItWorks"),
  id: () => new Field("id"),

  /**
   * @description The category's name.
   */
  name: () => new Field("name"),

  /**
   * @description How many Marketplace listings have this as their primary category.
   */
  primaryListingCount: () => new Field("primaryListingCount"),

  /**
   * @description The HTTP path for this Marketplace category.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description How many Marketplace listings have this as their secondary category.
   */
  secondaryListingCount: () => new Field("secondaryListingCount"),

  /**
   * @description The short name of the category used in its URL.
   */
  slug: () => new Field("slug"),

  /**
   * @description The HTTP URL for this Marketplace category.
   */
  url: () => new Field("url"),
};

export interface IMarketplaceListing extends INode {
  readonly __typename: "MarketplaceListing";
  readonly app: IApp | null;
  readonly companyUrl: unknown | null;
  readonly configurationResourcePath: unknown;
  readonly configurationUrl: unknown;
  readonly documentationUrl: unknown | null;
  readonly extendedDescription: string | null;
  readonly extendedDescriptionHTML: unknown;
  readonly fullDescription: string;
  readonly fullDescriptionHTML: unknown;
  readonly hasPublishedFreeTrialPlans: boolean;
  readonly hasTermsOfService: boolean;
  readonly hasVerifiedOwner: boolean;
  readonly howItWorks: string | null;
  readonly howItWorksHTML: unknown;
  readonly installationUrl: unknown | null;
  readonly installedForViewer: boolean;
  readonly isArchived: boolean;
  readonly isDraft: boolean;
  readonly isPaid: boolean;
  readonly isPublic: boolean;
  readonly isRejected: boolean;
  readonly isUnverified: boolean;
  readonly isUnverifiedPending: boolean;
  readonly isVerificationPendingFromDraft: boolean;
  readonly isVerificationPendingFromUnverified: boolean;
  readonly isVerified: boolean;
  readonly logoBackgroundColor: string;
  readonly logoUrl: unknown | null;
  readonly name: string;
  readonly normalizedShortDescription: string;
  readonly pricingUrl: unknown | null;
  readonly primaryCategory: IMarketplaceCategory;
  readonly privacyPolicyUrl: unknown;
  readonly resourcePath: unknown;
  readonly screenshotUrls: ReadonlyArray<string>;
  readonly secondaryCategory: IMarketplaceCategory | null;
  readonly shortDescription: string;
  readonly slug: string;
  readonly statusUrl: unknown | null;
  readonly supportEmail: string | null;
  readonly supportUrl: unknown;
  readonly termsOfServiceUrl: unknown | null;
  readonly url: unknown;
  readonly viewerCanAddPlans: boolean;
  readonly viewerCanApprove: boolean;
  readonly viewerCanDelist: boolean;
  readonly viewerCanEdit: boolean;
  readonly viewerCanEditCategories: boolean;
  readonly viewerCanEditPlans: boolean;
  readonly viewerCanRedraft: boolean;
  readonly viewerCanReject: boolean;
  readonly viewerCanRequestApproval: boolean;
  readonly viewerHasPurchased: boolean;
  readonly viewerHasPurchasedForAllOrganizations: boolean;
  readonly viewerIsListingAdmin: boolean;
}

interface MarketplaceListingSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The GitHub App this listing represents.
   */

  readonly app: <T extends Array<Selection>>(
    select: (t: AppSelector) => T
  ) => Field<"app", never, SelectionSet<T>>;

  /**
   * @description URL to the listing owner's company site.
   */

  readonly companyUrl: () => Field<"companyUrl">;

  /**
   * @description The HTTP path for configuring access to the listing's integration or OAuth app
   */

  readonly configurationResourcePath: () => Field<"configurationResourcePath">;

  /**
   * @description The HTTP URL for configuring access to the listing's integration or OAuth app
   */

  readonly configurationUrl: () => Field<"configurationUrl">;

  /**
   * @description URL to the listing's documentation.
   */

  readonly documentationUrl: () => Field<"documentationUrl">;

  /**
   * @description The listing's detailed description.
   */

  readonly extendedDescription: () => Field<"extendedDescription">;

  /**
   * @description The listing's detailed description rendered to HTML.
   */

  readonly extendedDescriptionHTML: () => Field<"extendedDescriptionHTML">;

  /**
   * @description The listing's introductory description.
   */

  readonly fullDescription: () => Field<"fullDescription">;

  /**
   * @description The listing's introductory description rendered to HTML.
   */

  readonly fullDescriptionHTML: () => Field<"fullDescriptionHTML">;

  /**
   * @description Does this listing have any plans with a free trial?
   */

  readonly hasPublishedFreeTrialPlans: () => Field<"hasPublishedFreeTrialPlans">;

  /**
   * @description Does this listing have a terms of service link?
   */

  readonly hasTermsOfService: () => Field<"hasTermsOfService">;

  /**
   * @description Whether the creator of the app is a verified org
   */

  readonly hasVerifiedOwner: () => Field<"hasVerifiedOwner">;

  /**
   * @description A technical description of how this app works with GitHub.
   */

  readonly howItWorks: () => Field<"howItWorks">;

  /**
   * @description The listing's technical description rendered to HTML.
   */

  readonly howItWorksHTML: () => Field<"howItWorksHTML">;

  readonly id: () => Field<"id">;

  /**
   * @description URL to install the product to the viewer's account or organization.
   */

  readonly installationUrl: () => Field<"installationUrl">;

  /**
   * @description Whether this listing's app has been installed for the current viewer
   */

  readonly installedForViewer: () => Field<"installedForViewer">;

  /**
   * @description Whether this listing has been removed from the Marketplace.
   */

  readonly isArchived: () => Field<"isArchived">;

  /**
     * @description Whether this listing is still an editable draft that has not been submitted
for review and is not publicly visible in the Marketplace.
     */

  readonly isDraft: () => Field<"isDraft">;

  /**
   * @description Whether the product this listing represents is available as part of a paid plan.
   */

  readonly isPaid: () => Field<"isPaid">;

  /**
   * @description Whether this listing has been approved for display in the Marketplace.
   */

  readonly isPublic: () => Field<"isPublic">;

  /**
   * @description Whether this listing has been rejected by GitHub for display in the Marketplace.
   */

  readonly isRejected: () => Field<"isRejected">;

  /**
   * @description Whether this listing has been approved for unverified display in the Marketplace.
   */

  readonly isUnverified: () => Field<"isUnverified">;

  /**
   * @description Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace.
   */

  readonly isUnverifiedPending: () => Field<"isUnverifiedPending">;

  /**
   * @description Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
   */

  readonly isVerificationPendingFromDraft: () => Field<"isVerificationPendingFromDraft">;

  /**
   * @description Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
   */

  readonly isVerificationPendingFromUnverified: () => Field<"isVerificationPendingFromUnverified">;

  /**
   * @description Whether this listing has been approved for verified display in the Marketplace.
   */

  readonly isVerified: () => Field<"isVerified">;

  /**
   * @description The hex color code, without the leading '#', for the logo background.
   */

  readonly logoBackgroundColor: () => Field<"logoBackgroundColor">;

  /**
   * @description URL for the listing's logo image.
   */

  readonly logoUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"logoUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description The listing's full name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The listing's very short description without a trailing period or ampersands.
   */

  readonly normalizedShortDescription: () => Field<"normalizedShortDescription">;

  /**
   * @description URL to the listing's detailed pricing.
   */

  readonly pricingUrl: () => Field<"pricingUrl">;

  /**
   * @description The category that best describes the listing.
   */

  readonly primaryCategory: <T extends Array<Selection>>(
    select: (t: MarketplaceCategorySelector) => T
  ) => Field<"primaryCategory", never, SelectionSet<T>>;

  /**
   * @description URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL.
   */

  readonly privacyPolicyUrl: () => Field<"privacyPolicyUrl">;

  /**
   * @description The HTTP path for the Marketplace listing.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The URLs for the listing's screenshots.
   */

  readonly screenshotUrls: () => Field<"screenshotUrls">;

  /**
   * @description An alternate category that describes the listing.
   */

  readonly secondaryCategory: <T extends Array<Selection>>(
    select: (t: MarketplaceCategorySelector) => T
  ) => Field<"secondaryCategory", never, SelectionSet<T>>;

  /**
   * @description The listing's very short description.
   */

  readonly shortDescription: () => Field<"shortDescription">;

  /**
   * @description The short name of the listing used in its URL.
   */

  readonly slug: () => Field<"slug">;

  /**
   * @description URL to the listing's status page.
   */

  readonly statusUrl: () => Field<"statusUrl">;

  /**
   * @description An email address for support for this listing's app.
   */

  readonly supportEmail: () => Field<"supportEmail">;

  /**
     * @description Either a URL or an email address for support for this listing's app, may
return an empty string for listings that do not require a support URL.
     */

  readonly supportUrl: () => Field<"supportUrl">;

  /**
   * @description URL to the listing's terms of service.
   */

  readonly termsOfServiceUrl: () => Field<"termsOfServiceUrl">;

  /**
   * @description The HTTP URL for the Marketplace listing.
   */

  readonly url: () => Field<"url">;

  /**
   * @description Can the current viewer add plans for this Marketplace listing.
   */

  readonly viewerCanAddPlans: () => Field<"viewerCanAddPlans">;

  /**
   * @description Can the current viewer approve this Marketplace listing.
   */

  readonly viewerCanApprove: () => Field<"viewerCanApprove">;

  /**
   * @description Can the current viewer delist this Marketplace listing.
   */

  readonly viewerCanDelist: () => Field<"viewerCanDelist">;

  /**
   * @description Can the current viewer edit this Marketplace listing.
   */

  readonly viewerCanEdit: () => Field<"viewerCanEdit">;

  /**
     * @description Can the current viewer edit the primary and secondary category of this
Marketplace listing.
     */

  readonly viewerCanEditCategories: () => Field<"viewerCanEditCategories">;

  /**
   * @description Can the current viewer edit the plans for this Marketplace listing.
   */

  readonly viewerCanEditPlans: () => Field<"viewerCanEditPlans">;

  /**
     * @description Can the current viewer return this Marketplace listing to draft state
so it becomes editable again.
     */

  readonly viewerCanRedraft: () => Field<"viewerCanRedraft">;

  /**
     * @description Can the current viewer reject this Marketplace listing by returning it to
an editable draft state or rejecting it entirely.
     */

  readonly viewerCanReject: () => Field<"viewerCanReject">;

  /**
     * @description Can the current viewer request this listing be reviewed for display in
the Marketplace as verified.
     */

  readonly viewerCanRequestApproval: () => Field<"viewerCanRequestApproval">;

  /**
   * @description Indicates whether the current user has an active subscription to this Marketplace listing.
   */

  readonly viewerHasPurchased: () => Field<"viewerHasPurchased">;

  /**
     * @description Indicates if the current user has purchased a subscription to this Marketplace listing
for all of the organizations the user owns.
     */

  readonly viewerHasPurchasedForAllOrganizations: () => Field<"viewerHasPurchasedForAllOrganizations">;

  /**
   * @description Does the current viewer role allow them to administer this Marketplace listing.
   */

  readonly viewerIsListingAdmin: () => Field<"viewerIsListingAdmin">;
}

export const isMarketplaceListing = (
  object: Record<string, any>
): object is Partial<IMarketplaceListing> => {
  return object.__typename === "MarketplaceListing";
};

export const MarketplaceListing: MarketplaceListingSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The GitHub App this listing represents.
   */

  app: (select) =>
    new Field("app", undefined as never, new SelectionSet(select(App))),

  /**
   * @description URL to the listing owner's company site.
   */
  companyUrl: () => new Field("companyUrl"),

  /**
   * @description The HTTP path for configuring access to the listing's integration or OAuth app
   */
  configurationResourcePath: () => new Field("configurationResourcePath"),

  /**
   * @description The HTTP URL for configuring access to the listing's integration or OAuth app
   */
  configurationUrl: () => new Field("configurationUrl"),

  /**
   * @description URL to the listing's documentation.
   */
  documentationUrl: () => new Field("documentationUrl"),

  /**
   * @description The listing's detailed description.
   */
  extendedDescription: () => new Field("extendedDescription"),

  /**
   * @description The listing's detailed description rendered to HTML.
   */
  extendedDescriptionHTML: () => new Field("extendedDescriptionHTML"),

  /**
   * @description The listing's introductory description.
   */
  fullDescription: () => new Field("fullDescription"),

  /**
   * @description The listing's introductory description rendered to HTML.
   */
  fullDescriptionHTML: () => new Field("fullDescriptionHTML"),

  /**
   * @description Does this listing have any plans with a free trial?
   */
  hasPublishedFreeTrialPlans: () => new Field("hasPublishedFreeTrialPlans"),

  /**
   * @description Does this listing have a terms of service link?
   */
  hasTermsOfService: () => new Field("hasTermsOfService"),

  /**
   * @description Whether the creator of the app is a verified org
   */
  hasVerifiedOwner: () => new Field("hasVerifiedOwner"),

  /**
   * @description A technical description of how this app works with GitHub.
   */
  howItWorks: () => new Field("howItWorks"),

  /**
   * @description The listing's technical description rendered to HTML.
   */
  howItWorksHTML: () => new Field("howItWorksHTML"),
  id: () => new Field("id"),

  /**
   * @description URL to install the product to the viewer's account or organization.
   */
  installationUrl: () => new Field("installationUrl"),

  /**
   * @description Whether this listing's app has been installed for the current viewer
   */
  installedForViewer: () => new Field("installedForViewer"),

  /**
   * @description Whether this listing has been removed from the Marketplace.
   */
  isArchived: () => new Field("isArchived"),

  /**
     * @description Whether this listing is still an editable draft that has not been submitted
for review and is not publicly visible in the Marketplace.
     */
  isDraft: () => new Field("isDraft"),

  /**
   * @description Whether the product this listing represents is available as part of a paid plan.
   */
  isPaid: () => new Field("isPaid"),

  /**
   * @description Whether this listing has been approved for display in the Marketplace.
   */
  isPublic: () => new Field("isPublic"),

  /**
   * @description Whether this listing has been rejected by GitHub for display in the Marketplace.
   */
  isRejected: () => new Field("isRejected"),

  /**
   * @description Whether this listing has been approved for unverified display in the Marketplace.
   */
  isUnverified: () => new Field("isUnverified"),

  /**
   * @description Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace.
   */
  isUnverifiedPending: () => new Field("isUnverifiedPending"),

  /**
   * @description Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
   */
  isVerificationPendingFromDraft: () =>
    new Field("isVerificationPendingFromDraft"),

  /**
   * @description Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
   */
  isVerificationPendingFromUnverified: () =>
    new Field("isVerificationPendingFromUnverified"),

  /**
   * @description Whether this listing has been approved for verified display in the Marketplace.
   */
  isVerified: () => new Field("isVerified"),

  /**
   * @description The hex color code, without the leading '#', for the logo background.
   */
  logoBackgroundColor: () => new Field("logoBackgroundColor"),

  /**
   * @description URL for the listing's logo image.
   */
  logoUrl: (variables) => new Field("logoUrl"),

  /**
   * @description The listing's full name.
   */
  name: () => new Field("name"),

  /**
   * @description The listing's very short description without a trailing period or ampersands.
   */
  normalizedShortDescription: () => new Field("normalizedShortDescription"),

  /**
   * @description URL to the listing's detailed pricing.
   */
  pricingUrl: () => new Field("pricingUrl"),

  /**
   * @description The category that best describes the listing.
   */

  primaryCategory: (select) =>
    new Field(
      "primaryCategory",
      undefined as never,
      new SelectionSet(select(MarketplaceCategory))
    ),

  /**
   * @description URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL.
   */
  privacyPolicyUrl: () => new Field("privacyPolicyUrl"),

  /**
   * @description The HTTP path for the Marketplace listing.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The URLs for the listing's screenshots.
   */
  screenshotUrls: () => new Field("screenshotUrls"),

  /**
   * @description An alternate category that describes the listing.
   */

  secondaryCategory: (select) =>
    new Field(
      "secondaryCategory",
      undefined as never,
      new SelectionSet(select(MarketplaceCategory))
    ),

  /**
   * @description The listing's very short description.
   */
  shortDescription: () => new Field("shortDescription"),

  /**
   * @description The short name of the listing used in its URL.
   */
  slug: () => new Field("slug"),

  /**
   * @description URL to the listing's status page.
   */
  statusUrl: () => new Field("statusUrl"),

  /**
   * @description An email address for support for this listing's app.
   */
  supportEmail: () => new Field("supportEmail"),

  /**
     * @description Either a URL or an email address for support for this listing's app, may
return an empty string for listings that do not require a support URL.
     */
  supportUrl: () => new Field("supportUrl"),

  /**
   * @description URL to the listing's terms of service.
   */
  termsOfServiceUrl: () => new Field("termsOfServiceUrl"),

  /**
   * @description The HTTP URL for the Marketplace listing.
   */
  url: () => new Field("url"),

  /**
   * @description Can the current viewer add plans for this Marketplace listing.
   */
  viewerCanAddPlans: () => new Field("viewerCanAddPlans"),

  /**
   * @description Can the current viewer approve this Marketplace listing.
   */
  viewerCanApprove: () => new Field("viewerCanApprove"),

  /**
   * @description Can the current viewer delist this Marketplace listing.
   */
  viewerCanDelist: () => new Field("viewerCanDelist"),

  /**
   * @description Can the current viewer edit this Marketplace listing.
   */
  viewerCanEdit: () => new Field("viewerCanEdit"),

  /**
     * @description Can the current viewer edit the primary and secondary category of this
Marketplace listing.
     */
  viewerCanEditCategories: () => new Field("viewerCanEditCategories"),

  /**
   * @description Can the current viewer edit the plans for this Marketplace listing.
   */
  viewerCanEditPlans: () => new Field("viewerCanEditPlans"),

  /**
     * @description Can the current viewer return this Marketplace listing to draft state
so it becomes editable again.
     */
  viewerCanRedraft: () => new Field("viewerCanRedraft"),

  /**
     * @description Can the current viewer reject this Marketplace listing by returning it to
an editable draft state or rejecting it entirely.
     */
  viewerCanReject: () => new Field("viewerCanReject"),

  /**
     * @description Can the current viewer request this listing be reviewed for display in
the Marketplace as verified.
     */
  viewerCanRequestApproval: () => new Field("viewerCanRequestApproval"),

  /**
   * @description Indicates whether the current user has an active subscription to this Marketplace listing.
   */
  viewerHasPurchased: () => new Field("viewerHasPurchased"),

  /**
     * @description Indicates if the current user has purchased a subscription to this Marketplace listing
for all of the organizations the user owns.
     */
  viewerHasPurchasedForAllOrganizations: () =>
    new Field("viewerHasPurchasedForAllOrganizations"),

  /**
   * @description Does the current viewer role allow them to administer this Marketplace listing.
   */
  viewerIsListingAdmin: () => new Field("viewerIsListingAdmin"),
};

export interface IMarketplaceListingConnection {
  readonly __typename: "MarketplaceListingConnection";
  readonly edges: ReadonlyArray<IMarketplaceListingEdge> | null;
  readonly nodes: ReadonlyArray<IMarketplaceListing> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface MarketplaceListingConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: MarketplaceListingEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: MarketplaceListingSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const MarketplaceListingConnection: MarketplaceListingConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(MarketplaceListingEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(MarketplaceListing))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IMarketplaceListingEdge {
  readonly __typename: "MarketplaceListingEdge";
  readonly cursor: string;
  readonly node: IMarketplaceListing | null;
}

interface MarketplaceListingEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: MarketplaceListingSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const MarketplaceListingEdge: MarketplaceListingEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(MarketplaceListing))
    ),
};

export interface IMemberStatusable {
  readonly __typename: string;
  readonly memberStatuses: IUserStatusConnection;
}

interface MemberStatusableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  readonly memberStatuses: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | UserStatusOrder;
    },
    select: (t: UserStatusConnectionSelector) => T
  ) => Field<
    "memberStatuses",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | UserStatusOrder>
    ],
    SelectionSet<T>
  >;

  readonly on: <T extends Array<Selection>, F extends "Organization" | "Team">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "Team"
        ? TeamSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const MemberStatusable: MemberStatusableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: (variables, select) =>
    new Field(
      "memberStatuses",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(UserStatusConnection))
    ),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "MemberStatusable",
        });
    }
  },
};

export interface IMembersCanDeleteReposClearAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "MembersCanDeleteReposClearAuditEntry";
}

interface MembersCanDeleteReposClearAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isMembersCanDeleteReposClearAuditEntry = (
  object: Record<string, any>
): object is Partial<IMembersCanDeleteReposClearAuditEntry> => {
  return object.__typename === "MembersCanDeleteReposClearAuditEntry";
};

export const MembersCanDeleteReposClearAuditEntry: MembersCanDeleteReposClearAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IMembersCanDeleteReposDisableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "MembersCanDeleteReposDisableAuditEntry";
}

interface MembersCanDeleteReposDisableAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isMembersCanDeleteReposDisableAuditEntry = (
  object: Record<string, any>
): object is Partial<IMembersCanDeleteReposDisableAuditEntry> => {
  return object.__typename === "MembersCanDeleteReposDisableAuditEntry";
};

export const MembersCanDeleteReposDisableAuditEntry: MembersCanDeleteReposDisableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IMembersCanDeleteReposEnableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "MembersCanDeleteReposEnableAuditEntry";
}

interface MembersCanDeleteReposEnableAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isMembersCanDeleteReposEnableAuditEntry = (
  object: Record<string, any>
): object is Partial<IMembersCanDeleteReposEnableAuditEntry> => {
  return object.__typename === "MembersCanDeleteReposEnableAuditEntry";
};

export const MembersCanDeleteReposEnableAuditEntry: MembersCanDeleteReposEnableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IMentionedEvent extends INode {
  readonly __typename: "MentionedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
}

interface MentionedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;
}

export const isMentionedEvent = (
  object: Record<string, any>
): object is Partial<IMentionedEvent> => {
  return object.__typename === "MentionedEvent";
};

export const MentionedEvent: MentionedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface IMergeBranchPayload {
  readonly __typename: "MergeBranchPayload";
  readonly clientMutationId: string | null;
  readonly mergeCommit: ICommit | null;
}

interface MergeBranchPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The resulting merge Commit.
   */

  readonly mergeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"mergeCommit", never, SelectionSet<T>>;
}

export const MergeBranchPayload: MergeBranchPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The resulting merge Commit.
   */

  mergeCommit: (select) =>
    new Field(
      "mergeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),
};

export interface IMergePullRequestPayload {
  readonly __typename: "MergePullRequestPayload";
  readonly actor: IActor | null;
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
}

interface MergePullRequestPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that was merged.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const MergePullRequestPayload: MergePullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that was merged.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IMergedEvent extends INode, IUniformResourceLocatable {
  readonly __typename: "MergedEvent";
  readonly actor: IActor | null;
  readonly commit: ICommit | null;
  readonly createdAt: unknown;
  readonly mergeRef: IRef | null;
  readonly mergeRefName: string;
  readonly pullRequest: IPullRequest;
}

interface MergedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the commit associated with the `merge` event.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the Ref associated with the `merge` event.
   */

  readonly mergeRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"mergeRef", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the Ref associated with the `merge` event.
   */

  readonly mergeRefName: () => Field<"mergeRefName">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this merged event.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this merged event.
   */

  readonly url: () => Field<"url">;
}

export const isMergedEvent = (
  object: Record<string, any>
): object is Partial<IMergedEvent> => {
  return object.__typename === "MergedEvent";
};

export const MergedEvent: MergedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the commit associated with the `merge` event.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the Ref associated with the `merge` event.
   */

  mergeRef: (select) =>
    new Field("mergeRef", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the name of the Ref associated with the `merge` event.
   */
  mergeRefName: () => new Field("mergeRefName"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this merged event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this merged event.
   */
  url: () => new Field("url"),
};

export interface IMilestone
  extends IClosable,
    INode,
    IUniformResourceLocatable {
  readonly __typename: "Milestone";
  readonly createdAt: unknown;
  readonly creator: IActor | null;
  readonly description: string | null;
  readonly dueOn: unknown | null;
  readonly issues: IIssueConnection;
  readonly number: number;
  readonly progressPercentage: number;
  readonly pullRequests: IPullRequestConnection;
  readonly repository: IRepository;
  readonly state: MilestoneState;
  readonly title: string;
  readonly updatedAt: unknown;
}

interface MilestoneSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */

  readonly closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  readonly closedAt: () => Field<"closedAt">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the actor who created the milestone.
   */

  readonly creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the description of the milestone.
   */

  readonly description: () => Field<"description">;

  /**
   * @description Identifies the due date of the milestone.
   */

  readonly dueOn: () => Field<"dueOn">;

  readonly id: () => Field<"id">;

  /**
   * @description A list of issues associated with the milestone.
   */

  readonly issues: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | IssueFilters;
      first?: Variable<"first"> | number;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | IssueState;
    },
    select: (t: IssueConnectionSelector) => T
  ) => Field<
    "issues",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | IssueFilters>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | IssueState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the number of the milestone.
   */

  readonly number: () => Field<"number">;

  /**
   * @description Indentifies the percentage complete for the milestone
   */

  readonly progressPercentage: () => Field<"progressPercentage">;

  /**
   * @description A list of pull requests associated with the milestone.
   */

  readonly pullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "pullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this milestone.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this milestone
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the state of the milestone.
   */

  readonly state: () => Field<"state">;

  /**
   * @description Identifies the title of the milestone.
   */

  readonly title: () => Field<"title">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this milestone
   */

  readonly url: () => Field<"url">;
}

export const isMilestone = (
  object: Record<string, any>
): object is Partial<IMilestone> => {
  return object.__typename === "Milestone";
};

export const Milestone: MilestoneSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the actor who created the milestone.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the description of the milestone.
   */
  description: () => new Field("description"),

  /**
   * @description Identifies the due date of the milestone.
   */
  dueOn: () => new Field("dueOn"),
  id: () => new Field("id"),

  /**
   * @description A list of issues associated with the milestone.
   */

  issues: (variables, select) =>
    new Field(
      "issues",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, IssueState),
      ],
      new SelectionSet(select(IssueConnection))
    ),

  /**
   * @description Identifies the number of the milestone.
   */
  number: () => new Field("number"),

  /**
   * @description Indentifies the percentage complete for the milestone
   */
  progressPercentage: () => new Field("progressPercentage"),

  /**
   * @description A list of pull requests associated with the milestone.
   */

  pullRequests: (variables, select) =>
    new Field(
      "pullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description The repository associated with this milestone.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this milestone
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the state of the milestone.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies the title of the milestone.
   */
  title: () => new Field("title"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this milestone
   */
  url: () => new Field("url"),
};

export interface IMilestoneConnection {
  readonly __typename: "MilestoneConnection";
  readonly edges: ReadonlyArray<IMilestoneEdge> | null;
  readonly nodes: ReadonlyArray<IMilestone> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface MilestoneConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: MilestoneEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: MilestoneSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const MilestoneConnection: MilestoneConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(MilestoneEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Milestone))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IMilestoneEdge {
  readonly __typename: "MilestoneEdge";
  readonly cursor: string;
  readonly node: IMilestone | null;
}

interface MilestoneEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: MilestoneSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const MilestoneEdge: MilestoneEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Milestone))),
};

export interface IMilestonedEvent extends INode {
  readonly __typename: "MilestonedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly milestoneTitle: string;
  readonly subject: IMilestoneItem;
}

interface MilestonedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the milestone title associated with the 'milestoned' event.
   */

  readonly milestoneTitle: () => Field<"milestoneTitle">;

  /**
   * @description Object referenced by event.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: MilestoneItemSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isMilestonedEvent = (
  object: Record<string, any>
): object is Partial<IMilestonedEvent> => {
  return object.__typename === "MilestonedEvent";
};

export const MilestonedEvent: MilestonedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the milestone title associated with the 'milestoned' event.
   */
  milestoneTitle: () => new Field("milestoneTitle"),

  /**
   * @description Object referenced by event.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(MilestoneItem))
    ),
};

export interface IMinimizable {
  readonly __typename: string;
  readonly isMinimized: boolean;
  readonly minimizedReason: string | null;
  readonly viewerCanMinimize: boolean;
}

interface MinimizableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  readonly isMinimized: () => Field<"isMinimized">;

  /**
   * @description Returns why the comment was minimized.
   */

  readonly minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  readonly viewerCanMinimize: () => Field<"viewerCanMinimize">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "IssueComment"
      | "PullRequestReviewComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Minimizable: MinimizableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Minimizable",
        });
    }
  },
};

export interface IMinimizeCommentPayload {
  readonly __typename: "MinimizeCommentPayload";
  readonly clientMutationId: string | null;
  readonly minimizedComment: IMinimizable | null;
}

interface MinimizeCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The comment that was minimized.
   */

  readonly minimizedComment: <T extends Array<Selection>>(
    select: (t: MinimizableSelector) => T
  ) => Field<"minimizedComment", never, SelectionSet<T>>;
}

export const MinimizeCommentPayload: MinimizeCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The comment that was minimized.
   */

  minimizedComment: (select) =>
    new Field(
      "minimizedComment",
      undefined as never,
      new SelectionSet(select(Minimizable))
    ),
};

export interface IMoveProjectCardPayload {
  readonly __typename: "MoveProjectCardPayload";
  readonly cardEdge: IProjectCardEdge | null;
  readonly clientMutationId: string | null;
}

interface MoveProjectCardPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The new edge of the moved card.
   */

  readonly cardEdge: <T extends Array<Selection>>(
    select: (t: ProjectCardEdgeSelector) => T
  ) => Field<"cardEdge", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const MoveProjectCardPayload: MoveProjectCardPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The new edge of the moved card.
   */

  cardEdge: (select) =>
    new Field(
      "cardEdge",
      undefined as never,
      new SelectionSet(select(ProjectCardEdge))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IMoveProjectColumnPayload {
  readonly __typename: "MoveProjectColumnPayload";
  readonly clientMutationId: string | null;
  readonly columnEdge: IProjectColumnEdge | null;
}

interface MoveProjectColumnPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new edge of the moved column.
   */

  readonly columnEdge: <T extends Array<Selection>>(
    select: (t: ProjectColumnEdgeSelector) => T
  ) => Field<"columnEdge", never, SelectionSet<T>>;
}

export const MoveProjectColumnPayload: MoveProjectColumnPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new edge of the moved column.
   */

  columnEdge: (select) =>
    new Field(
      "columnEdge",
      undefined as never,
      new SelectionSet(select(ProjectColumnEdge))
    ),
};

export interface IMovedColumnsInProjectEvent extends INode {
  readonly __typename: "MovedColumnsInProjectEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
}

interface MovedColumnsInProjectEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;
}

export const isMovedColumnsInProjectEvent = (
  object: Record<string, any>
): object is Partial<IMovedColumnsInProjectEvent> => {
  return object.__typename === "MovedColumnsInProjectEvent";
};

export const MovedColumnsInProjectEvent: MovedColumnsInProjectEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface IMutation {
  readonly __typename: "Mutation";
  readonly acceptEnterpriseAdministratorInvitation: IAcceptEnterpriseAdministratorInvitationPayload | null;
  readonly acceptTopicSuggestion: IAcceptTopicSuggestionPayload | null;
  readonly addAssigneesToAssignable: IAddAssigneesToAssignablePayload | null;
  readonly addComment: IAddCommentPayload | null;
  readonly addLabelsToLabelable: IAddLabelsToLabelablePayload | null;
  readonly addProjectCard: IAddProjectCardPayload | null;
  readonly addProjectColumn: IAddProjectColumnPayload | null;
  readonly addPullRequestReview: IAddPullRequestReviewPayload | null;
  readonly addPullRequestReviewComment: IAddPullRequestReviewCommentPayload | null;
  readonly addPullRequestReviewThread: IAddPullRequestReviewThreadPayload | null;
  readonly addReaction: IAddReactionPayload | null;
  readonly addStar: IAddStarPayload | null;
  readonly archiveRepository: IArchiveRepositoryPayload | null;
  readonly cancelEnterpriseAdminInvitation: ICancelEnterpriseAdminInvitationPayload | null;
  readonly changeUserStatus: IChangeUserStatusPayload | null;
  readonly clearLabelsFromLabelable: IClearLabelsFromLabelablePayload | null;
  readonly cloneProject: ICloneProjectPayload | null;
  readonly cloneTemplateRepository: ICloneTemplateRepositoryPayload | null;
  readonly closeIssue: ICloseIssuePayload | null;
  readonly closePullRequest: IClosePullRequestPayload | null;
  readonly convertProjectCardNoteToIssue: IConvertProjectCardNoteToIssuePayload | null;
  readonly createBranchProtectionRule: ICreateBranchProtectionRulePayload | null;
  readonly createCheckRun: ICreateCheckRunPayload | null;
  readonly createCheckSuite: ICreateCheckSuitePayload | null;
  readonly createEnterpriseOrganization: ICreateEnterpriseOrganizationPayload | null;
  readonly createIpAllowListEntry: ICreateIpAllowListEntryPayload | null;
  readonly createIssue: ICreateIssuePayload | null;
  readonly createProject: ICreateProjectPayload | null;
  readonly createPullRequest: ICreatePullRequestPayload | null;
  readonly createRef: ICreateRefPayload | null;
  readonly createRepository: ICreateRepositoryPayload | null;
  readonly createTeamDiscussion: ICreateTeamDiscussionPayload | null;
  readonly createTeamDiscussionComment: ICreateTeamDiscussionCommentPayload | null;
  readonly declineTopicSuggestion: IDeclineTopicSuggestionPayload | null;
  readonly deleteBranchProtectionRule: IDeleteBranchProtectionRulePayload | null;
  readonly deleteDeployment: IDeleteDeploymentPayload | null;
  readonly deleteIpAllowListEntry: IDeleteIpAllowListEntryPayload | null;
  readonly deleteIssue: IDeleteIssuePayload | null;
  readonly deleteIssueComment: IDeleteIssueCommentPayload | null;
  readonly deleteProject: IDeleteProjectPayload | null;
  readonly deleteProjectCard: IDeleteProjectCardPayload | null;
  readonly deleteProjectColumn: IDeleteProjectColumnPayload | null;
  readonly deletePullRequestReview: IDeletePullRequestReviewPayload | null;
  readonly deletePullRequestReviewComment: IDeletePullRequestReviewCommentPayload | null;
  readonly deleteRef: IDeleteRefPayload | null;
  readonly deleteTeamDiscussion: IDeleteTeamDiscussionPayload | null;
  readonly deleteTeamDiscussionComment: IDeleteTeamDiscussionCommentPayload | null;
  readonly dismissPullRequestReview: IDismissPullRequestReviewPayload | null;
  readonly followUser: IFollowUserPayload | null;
  readonly inviteEnterpriseAdmin: IInviteEnterpriseAdminPayload | null;
  readonly linkRepositoryToProject: ILinkRepositoryToProjectPayload | null;
  readonly lockLockable: ILockLockablePayload | null;
  readonly markFileAsViewed: IMarkFileAsViewedPayload | null;
  readonly markPullRequestReadyForReview: IMarkPullRequestReadyForReviewPayload | null;
  readonly mergeBranch: IMergeBranchPayload | null;
  readonly mergePullRequest: IMergePullRequestPayload | null;
  readonly minimizeComment: IMinimizeCommentPayload | null;
  readonly moveProjectCard: IMoveProjectCardPayload | null;
  readonly moveProjectColumn: IMoveProjectColumnPayload | null;
  readonly regenerateEnterpriseIdentityProviderRecoveryCodes: IRegenerateEnterpriseIdentityProviderRecoveryCodesPayload | null;
  readonly removeAssigneesFromAssignable: IRemoveAssigneesFromAssignablePayload | null;
  readonly removeEnterpriseAdmin: IRemoveEnterpriseAdminPayload | null;
  readonly removeEnterpriseIdentityProvider: IRemoveEnterpriseIdentityProviderPayload | null;
  readonly removeEnterpriseOrganization: IRemoveEnterpriseOrganizationPayload | null;
  readonly removeLabelsFromLabelable: IRemoveLabelsFromLabelablePayload | null;
  readonly removeOutsideCollaborator: IRemoveOutsideCollaboratorPayload | null;
  readonly removeReaction: IRemoveReactionPayload | null;
  readonly removeStar: IRemoveStarPayload | null;
  readonly reopenIssue: IReopenIssuePayload | null;
  readonly reopenPullRequest: IReopenPullRequestPayload | null;
  readonly requestReviews: IRequestReviewsPayload | null;
  readonly rerequestCheckSuite: IRerequestCheckSuitePayload | null;
  readonly resolveReviewThread: IResolveReviewThreadPayload | null;
  readonly setEnterpriseIdentityProvider: ISetEnterpriseIdentityProviderPayload | null;
  readonly setOrganizationInteractionLimit: ISetOrganizationInteractionLimitPayload | null;
  readonly setRepositoryInteractionLimit: ISetRepositoryInteractionLimitPayload | null;
  readonly setUserInteractionLimit: ISetUserInteractionLimitPayload | null;
  readonly submitPullRequestReview: ISubmitPullRequestReviewPayload | null;
  readonly transferIssue: ITransferIssuePayload | null;
  readonly unarchiveRepository: IUnarchiveRepositoryPayload | null;
  readonly unfollowUser: IUnfollowUserPayload | null;
  readonly unlinkRepositoryFromProject: IUnlinkRepositoryFromProjectPayload | null;
  readonly unlockLockable: IUnlockLockablePayload | null;
  readonly unmarkFileAsViewed: IUnmarkFileAsViewedPayload | null;
  readonly unmarkIssueAsDuplicate: IUnmarkIssueAsDuplicatePayload | null;
  readonly unminimizeComment: IUnminimizeCommentPayload | null;
  readonly unresolveReviewThread: IUnresolveReviewThreadPayload | null;
  readonly updateBranchProtectionRule: IUpdateBranchProtectionRulePayload | null;
  readonly updateCheckRun: IUpdateCheckRunPayload | null;
  readonly updateCheckSuitePreferences: IUpdateCheckSuitePreferencesPayload | null;
  readonly updateEnterpriseAdministratorRole: IUpdateEnterpriseAdministratorRolePayload | null;
  readonly updateEnterpriseAllowPrivateRepositoryForkingSetting: IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload | null;
  readonly updateEnterpriseDefaultRepositoryPermissionSetting: IUpdateEnterpriseDefaultRepositoryPermissionSettingPayload | null;
  readonly updateEnterpriseMembersCanChangeRepositoryVisibilitySetting: IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload | null;
  readonly updateEnterpriseMembersCanCreateRepositoriesSetting: IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload | null;
  readonly updateEnterpriseMembersCanDeleteIssuesSetting: IUpdateEnterpriseMembersCanDeleteIssuesSettingPayload | null;
  readonly updateEnterpriseMembersCanDeleteRepositoriesSetting: IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload | null;
  readonly updateEnterpriseMembersCanInviteCollaboratorsSetting: IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload | null;
  readonly updateEnterpriseMembersCanMakePurchasesSetting: IUpdateEnterpriseMembersCanMakePurchasesSettingPayload | null;
  readonly updateEnterpriseMembersCanUpdateProtectedBranchesSetting: IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload | null;
  readonly updateEnterpriseMembersCanViewDependencyInsightsSetting: IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload | null;
  readonly updateEnterpriseOrganizationProjectsSetting: IUpdateEnterpriseOrganizationProjectsSettingPayload | null;
  readonly updateEnterpriseProfile: IUpdateEnterpriseProfilePayload | null;
  readonly updateEnterpriseRepositoryProjectsSetting: IUpdateEnterpriseRepositoryProjectsSettingPayload | null;
  readonly updateEnterpriseTeamDiscussionsSetting: IUpdateEnterpriseTeamDiscussionsSettingPayload | null;
  readonly updateEnterpriseTwoFactorAuthenticationRequiredSetting: IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload | null;
  readonly updateIpAllowListEnabledSetting: IUpdateIpAllowListEnabledSettingPayload | null;
  readonly updateIpAllowListEntry: IUpdateIpAllowListEntryPayload | null;
  readonly updateIssue: IUpdateIssuePayload | null;
  readonly updateIssueComment: IUpdateIssueCommentPayload | null;
  readonly updateProject: IUpdateProjectPayload | null;
  readonly updateProjectCard: IUpdateProjectCardPayload | null;
  readonly updateProjectColumn: IUpdateProjectColumnPayload | null;
  readonly updatePullRequest: IUpdatePullRequestPayload | null;
  readonly updatePullRequestReview: IUpdatePullRequestReviewPayload | null;
  readonly updatePullRequestReviewComment: IUpdatePullRequestReviewCommentPayload | null;
  readonly updateRef: IUpdateRefPayload | null;
  readonly updateRepository: IUpdateRepositoryPayload | null;
  readonly updateSubscription: IUpdateSubscriptionPayload | null;
  readonly updateTeamDiscussion: IUpdateTeamDiscussionPayload | null;
  readonly updateTeamDiscussionComment: IUpdateTeamDiscussionCommentPayload | null;
  readonly updateTopics: IUpdateTopicsPayload | null;
}

interface MutationSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Accepts a pending invitation for a user to become an administrator of an enterprise.
   */

  readonly acceptEnterpriseAdministratorInvitation: <
    T extends Array<Selection>
  >(
    variables: {
      input?: Variable<"input"> | AcceptEnterpriseAdministratorInvitationInput;
    },
    select: (t: AcceptEnterpriseAdministratorInvitationPayloadSelector) => T
  ) => Field<
    "acceptEnterpriseAdministratorInvitation",
    [
      Argument<
        "input",
        Variable<"input"> | AcceptEnterpriseAdministratorInvitationInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Applies a suggested topic to the repository.
   */

  readonly acceptTopicSuggestion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AcceptTopicSuggestionInput },
    select: (t: AcceptTopicSuggestionPayloadSelector) => T
  ) => Field<
    "acceptTopicSuggestion",
    [Argument<"input", Variable<"input"> | AcceptTopicSuggestionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds assignees to an assignable object.
   */

  readonly addAssigneesToAssignable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddAssigneesToAssignableInput },
    select: (t: AddAssigneesToAssignablePayloadSelector) => T
  ) => Field<
    "addAssigneesToAssignable",
    [Argument<"input", Variable<"input"> | AddAssigneesToAssignableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a comment to an Issue or Pull Request.
   */

  readonly addComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddCommentInput },
    select: (t: AddCommentPayloadSelector) => T
  ) => Field<
    "addComment",
    [Argument<"input", Variable<"input"> | AddCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds labels to a labelable object.
   */

  readonly addLabelsToLabelable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddLabelsToLabelableInput },
    select: (t: AddLabelsToLabelablePayloadSelector) => T
  ) => Field<
    "addLabelsToLabelable",
    [Argument<"input", Variable<"input"> | AddLabelsToLabelableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both.
   */

  readonly addProjectCard: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddProjectCardInput },
    select: (t: AddProjectCardPayloadSelector) => T
  ) => Field<
    "addProjectCard",
    [Argument<"input", Variable<"input"> | AddProjectCardInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a column to a Project.
   */

  readonly addProjectColumn: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddProjectColumnInput },
    select: (t: AddProjectColumnPayloadSelector) => T
  ) => Field<
    "addProjectColumn",
    [Argument<"input", Variable<"input"> | AddProjectColumnInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a review to a Pull Request.
   */

  readonly addPullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddPullRequestReviewInput },
    select: (t: AddPullRequestReviewPayloadSelector) => T
  ) => Field<
    "addPullRequestReview",
    [Argument<"input", Variable<"input"> | AddPullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a comment to a review.
   */

  readonly addPullRequestReviewComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddPullRequestReviewCommentInput },
    select: (t: AddPullRequestReviewCommentPayloadSelector) => T
  ) => Field<
    "addPullRequestReviewComment",
    [Argument<"input", Variable<"input"> | AddPullRequestReviewCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a new thread to a pending Pull Request Review.
   */

  readonly addPullRequestReviewThread: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddPullRequestReviewThreadInput },
    select: (t: AddPullRequestReviewThreadPayloadSelector) => T
  ) => Field<
    "addPullRequestReviewThread",
    [Argument<"input", Variable<"input"> | AddPullRequestReviewThreadInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a reaction to a subject.
   */

  readonly addReaction: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddReactionInput },
    select: (t: AddReactionPayloadSelector) => T
  ) => Field<
    "addReaction",
    [Argument<"input", Variable<"input"> | AddReactionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a star to a Starrable.
   */

  readonly addStar: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddStarInput },
    select: (t: AddStarPayloadSelector) => T
  ) => Field<
    "addStar",
    [Argument<"input", Variable<"input"> | AddStarInput>],
    SelectionSet<T>
  >;

  /**
   * @description Marks a repository as archived.
   */

  readonly archiveRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ArchiveRepositoryInput },
    select: (t: ArchiveRepositoryPayloadSelector) => T
  ) => Field<
    "archiveRepository",
    [Argument<"input", Variable<"input"> | ArchiveRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Cancels a pending invitation for an administrator to join an enterprise.
   */

  readonly cancelEnterpriseAdminInvitation: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | CancelEnterpriseAdminInvitationInput;
    },
    select: (t: CancelEnterpriseAdminInvitationPayloadSelector) => T
  ) => Field<
    "cancelEnterpriseAdminInvitation",
    [
      Argument<
        "input",
        Variable<"input"> | CancelEnterpriseAdminInvitationInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Update your status on GitHub.
   */

  readonly changeUserStatus: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ChangeUserStatusInput },
    select: (t: ChangeUserStatusPayloadSelector) => T
  ) => Field<
    "changeUserStatus",
    [Argument<"input", Variable<"input"> | ChangeUserStatusInput>],
    SelectionSet<T>
  >;

  /**
   * @description Clears all labels from a labelable object.
   */

  readonly clearLabelsFromLabelable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ClearLabelsFromLabelableInput },
    select: (t: ClearLabelsFromLabelablePayloadSelector) => T
  ) => Field<
    "clearLabelsFromLabelable",
    [Argument<"input", Variable<"input"> | ClearLabelsFromLabelableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new project by cloning configuration from an existing project.
   */

  readonly cloneProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CloneProjectInput },
    select: (t: CloneProjectPayloadSelector) => T
  ) => Field<
    "cloneProject",
    [Argument<"input", Variable<"input"> | CloneProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new repository with the same files and directory structure as a template repository.
   */

  readonly cloneTemplateRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CloneTemplateRepositoryInput },
    select: (t: CloneTemplateRepositoryPayloadSelector) => T
  ) => Field<
    "cloneTemplateRepository",
    [Argument<"input", Variable<"input"> | CloneTemplateRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Close an issue.
   */

  readonly closeIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CloseIssueInput },
    select: (t: CloseIssuePayloadSelector) => T
  ) => Field<
    "closeIssue",
    [Argument<"input", Variable<"input"> | CloseIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Close a pull request.
   */

  readonly closePullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ClosePullRequestInput },
    select: (t: ClosePullRequestPayloadSelector) => T
  ) => Field<
    "closePullRequest",
    [Argument<"input", Variable<"input"> | ClosePullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Convert a project note card to one associated with a newly created issue.
   */

  readonly convertProjectCardNoteToIssue: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | ConvertProjectCardNoteToIssueInput;
    },
    select: (t: ConvertProjectCardNoteToIssuePayloadSelector) => T
  ) => Field<
    "convertProjectCardNoteToIssue",
    [Argument<"input", Variable<"input"> | ConvertProjectCardNoteToIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new branch protection rule
   */

  readonly createBranchProtectionRule: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateBranchProtectionRuleInput },
    select: (t: CreateBranchProtectionRulePayloadSelector) => T
  ) => Field<
    "createBranchProtectionRule",
    [Argument<"input", Variable<"input"> | CreateBranchProtectionRuleInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a check run.
   */

  readonly createCheckRun: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateCheckRunInput },
    select: (t: CreateCheckRunPayloadSelector) => T
  ) => Field<
    "createCheckRun",
    [Argument<"input", Variable<"input"> | CreateCheckRunInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a check suite
   */

  readonly createCheckSuite: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateCheckSuiteInput },
    select: (t: CreateCheckSuitePayloadSelector) => T
  ) => Field<
    "createCheckSuite",
    [Argument<"input", Variable<"input"> | CreateCheckSuiteInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates an organization as part of an enterprise account.
   */

  readonly createEnterpriseOrganization: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | CreateEnterpriseOrganizationInput;
    },
    select: (t: CreateEnterpriseOrganizationPayloadSelector) => T
  ) => Field<
    "createEnterpriseOrganization",
    [Argument<"input", Variable<"input"> | CreateEnterpriseOrganizationInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new IP allow list entry.
   */

  readonly createIpAllowListEntry: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateIpAllowListEntryInput },
    select: (t: CreateIpAllowListEntryPayloadSelector) => T
  ) => Field<
    "createIpAllowListEntry",
    [Argument<"input", Variable<"input"> | CreateIpAllowListEntryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new issue.
   */

  readonly createIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateIssueInput },
    select: (t: CreateIssuePayloadSelector) => T
  ) => Field<
    "createIssue",
    [Argument<"input", Variable<"input"> | CreateIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new project.
   */

  readonly createProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateProjectInput },
    select: (t: CreateProjectPayloadSelector) => T
  ) => Field<
    "createProject",
    [Argument<"input", Variable<"input"> | CreateProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new pull request
   */

  readonly createPullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreatePullRequestInput },
    select: (t: CreatePullRequestPayloadSelector) => T
  ) => Field<
    "createPullRequest",
    [Argument<"input", Variable<"input"> | CreatePullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new Git Ref.
   */

  readonly createRef: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateRefInput },
    select: (t: CreateRefPayloadSelector) => T
  ) => Field<
    "createRef",
    [Argument<"input", Variable<"input"> | CreateRefInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new repository.
   */

  readonly createRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateRepositoryInput },
    select: (t: CreateRepositoryPayloadSelector) => T
  ) => Field<
    "createRepository",
    [Argument<"input", Variable<"input"> | CreateRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new team discussion.
   */

  readonly createTeamDiscussion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateTeamDiscussionInput },
    select: (t: CreateTeamDiscussionPayloadSelector) => T
  ) => Field<
    "createTeamDiscussion",
    [Argument<"input", Variable<"input"> | CreateTeamDiscussionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new team discussion comment.
   */

  readonly createTeamDiscussionComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateTeamDiscussionCommentInput },
    select: (t: CreateTeamDiscussionCommentPayloadSelector) => T
  ) => Field<
    "createTeamDiscussionComment",
    [Argument<"input", Variable<"input"> | CreateTeamDiscussionCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Rejects a suggested topic for the repository.
   */

  readonly declineTopicSuggestion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeclineTopicSuggestionInput },
    select: (t: DeclineTopicSuggestionPayloadSelector) => T
  ) => Field<
    "declineTopicSuggestion",
    [Argument<"input", Variable<"input"> | DeclineTopicSuggestionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Delete a branch protection rule
   */

  readonly deleteBranchProtectionRule: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteBranchProtectionRuleInput },
    select: (t: DeleteBranchProtectionRulePayloadSelector) => T
  ) => Field<
    "deleteBranchProtectionRule",
    [Argument<"input", Variable<"input"> | DeleteBranchProtectionRuleInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a deployment.
   */

  readonly deleteDeployment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteDeploymentInput },
    select: (t: DeleteDeploymentPayloadSelector) => T
  ) => Field<
    "deleteDeployment",
    [Argument<"input", Variable<"input"> | DeleteDeploymentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes an IP allow list entry.
   */

  readonly deleteIpAllowListEntry: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteIpAllowListEntryInput },
    select: (t: DeleteIpAllowListEntryPayloadSelector) => T
  ) => Field<
    "deleteIpAllowListEntry",
    [Argument<"input", Variable<"input"> | DeleteIpAllowListEntryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes an Issue object.
   */

  readonly deleteIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteIssueInput },
    select: (t: DeleteIssuePayloadSelector) => T
  ) => Field<
    "deleteIssue",
    [Argument<"input", Variable<"input"> | DeleteIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes an IssueComment object.
   */

  readonly deleteIssueComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteIssueCommentInput },
    select: (t: DeleteIssueCommentPayloadSelector) => T
  ) => Field<
    "deleteIssueComment",
    [Argument<"input", Variable<"input"> | DeleteIssueCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a project.
   */

  readonly deleteProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteProjectInput },
    select: (t: DeleteProjectPayloadSelector) => T
  ) => Field<
    "deleteProject",
    [Argument<"input", Variable<"input"> | DeleteProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a project card.
   */

  readonly deleteProjectCard: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteProjectCardInput },
    select: (t: DeleteProjectCardPayloadSelector) => T
  ) => Field<
    "deleteProjectCard",
    [Argument<"input", Variable<"input"> | DeleteProjectCardInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a project column.
   */

  readonly deleteProjectColumn: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteProjectColumnInput },
    select: (t: DeleteProjectColumnPayloadSelector) => T
  ) => Field<
    "deleteProjectColumn",
    [Argument<"input", Variable<"input"> | DeleteProjectColumnInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a pull request review.
   */

  readonly deletePullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeletePullRequestReviewInput },
    select: (t: DeletePullRequestReviewPayloadSelector) => T
  ) => Field<
    "deletePullRequestReview",
    [Argument<"input", Variable<"input"> | DeletePullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a pull request review comment.
   */

  readonly deletePullRequestReviewComment: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | DeletePullRequestReviewCommentInput;
    },
    select: (t: DeletePullRequestReviewCommentPayloadSelector) => T
  ) => Field<
    "deletePullRequestReviewComment",
    [
      Argument<"input", Variable<"input"> | DeletePullRequestReviewCommentInput>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Delete a Git Ref.
   */

  readonly deleteRef: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteRefInput },
    select: (t: DeleteRefPayloadSelector) => T
  ) => Field<
    "deleteRef",
    [Argument<"input", Variable<"input"> | DeleteRefInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a team discussion.
   */

  readonly deleteTeamDiscussion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteTeamDiscussionInput },
    select: (t: DeleteTeamDiscussionPayloadSelector) => T
  ) => Field<
    "deleteTeamDiscussion",
    [Argument<"input", Variable<"input"> | DeleteTeamDiscussionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a team discussion comment.
   */

  readonly deleteTeamDiscussionComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteTeamDiscussionCommentInput },
    select: (t: DeleteTeamDiscussionCommentPayloadSelector) => T
  ) => Field<
    "deleteTeamDiscussionComment",
    [Argument<"input", Variable<"input"> | DeleteTeamDiscussionCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Dismisses an approved or rejected pull request review.
   */

  readonly dismissPullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DismissPullRequestReviewInput },
    select: (t: DismissPullRequestReviewPayloadSelector) => T
  ) => Field<
    "dismissPullRequestReview",
    [Argument<"input", Variable<"input"> | DismissPullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Follow a user.
   */

  readonly followUser: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | FollowUserInput },
    select: (t: FollowUserPayloadSelector) => T
  ) => Field<
    "followUser",
    [Argument<"input", Variable<"input"> | FollowUserInput>],
    SelectionSet<T>
  >;

  /**
   * @description Invite someone to become an administrator of the enterprise.
   */

  readonly inviteEnterpriseAdmin: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | InviteEnterpriseAdminInput },
    select: (t: InviteEnterpriseAdminPayloadSelector) => T
  ) => Field<
    "inviteEnterpriseAdmin",
    [Argument<"input", Variable<"input"> | InviteEnterpriseAdminInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a repository link for a project.
   */

  readonly linkRepositoryToProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | LinkRepositoryToProjectInput },
    select: (t: LinkRepositoryToProjectPayloadSelector) => T
  ) => Field<
    "linkRepositoryToProject",
    [Argument<"input", Variable<"input"> | LinkRepositoryToProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Lock a lockable object
   */

  readonly lockLockable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | LockLockableInput },
    select: (t: LockLockablePayloadSelector) => T
  ) => Field<
    "lockLockable",
    [Argument<"input", Variable<"input"> | LockLockableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Mark a pull request file as viewed
   */

  readonly markFileAsViewed: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MarkFileAsViewedInput },
    select: (t: MarkFileAsViewedPayloadSelector) => T
  ) => Field<
    "markFileAsViewed",
    [Argument<"input", Variable<"input"> | MarkFileAsViewedInput>],
    SelectionSet<T>
  >;

  /**
   * @description Marks a pull request ready for review.
   */

  readonly markPullRequestReadyForReview: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | MarkPullRequestReadyForReviewInput;
    },
    select: (t: MarkPullRequestReadyForReviewPayloadSelector) => T
  ) => Field<
    "markPullRequestReadyForReview",
    [Argument<"input", Variable<"input"> | MarkPullRequestReadyForReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Merge a head into a branch.
   */

  readonly mergeBranch: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MergeBranchInput },
    select: (t: MergeBranchPayloadSelector) => T
  ) => Field<
    "mergeBranch",
    [Argument<"input", Variable<"input"> | MergeBranchInput>],
    SelectionSet<T>
  >;

  /**
   * @description Merge a pull request.
   */

  readonly mergePullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MergePullRequestInput },
    select: (t: MergePullRequestPayloadSelector) => T
  ) => Field<
    "mergePullRequest",
    [Argument<"input", Variable<"input"> | MergePullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Minimizes a comment on an Issue, Commit, Pull Request, or Gist
   */

  readonly minimizeComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MinimizeCommentInput },
    select: (t: MinimizeCommentPayloadSelector) => T
  ) => Field<
    "minimizeComment",
    [Argument<"input", Variable<"input"> | MinimizeCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Moves a project card to another place.
   */

  readonly moveProjectCard: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MoveProjectCardInput },
    select: (t: MoveProjectCardPayloadSelector) => T
  ) => Field<
    "moveProjectCard",
    [Argument<"input", Variable<"input"> | MoveProjectCardInput>],
    SelectionSet<T>
  >;

  /**
   * @description Moves a project column to another place.
   */

  readonly moveProjectColumn: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MoveProjectColumnInput },
    select: (t: MoveProjectColumnPayloadSelector) => T
  ) => Field<
    "moveProjectColumn",
    [Argument<"input", Variable<"input"> | MoveProjectColumnInput>],
    SelectionSet<T>
  >;

  /**
   * @description Regenerates the identity provider recovery codes for an enterprise
   */

  readonly regenerateEnterpriseIdentityProviderRecoveryCodes: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
    },
    select: (
      t: RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadSelector
    ) => T
  ) => Field<
    "regenerateEnterpriseIdentityProviderRecoveryCodes",
    [
      Argument<
        "input",
        | Variable<"input">
        | RegenerateEnterpriseIdentityProviderRecoveryCodesInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Removes assignees from an assignable object.
   */

  readonly removeAssigneesFromAssignable: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | RemoveAssigneesFromAssignableInput;
    },
    select: (t: RemoveAssigneesFromAssignablePayloadSelector) => T
  ) => Field<
    "removeAssigneesFromAssignable",
    [Argument<"input", Variable<"input"> | RemoveAssigneesFromAssignableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes an administrator from the enterprise.
   */

  readonly removeEnterpriseAdmin: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveEnterpriseAdminInput },
    select: (t: RemoveEnterpriseAdminPayloadSelector) => T
  ) => Field<
    "removeEnterpriseAdmin",
    [Argument<"input", Variable<"input"> | RemoveEnterpriseAdminInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes the identity provider from an enterprise
   */

  readonly removeEnterpriseIdentityProvider: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | RemoveEnterpriseIdentityProviderInput;
    },
    select: (t: RemoveEnterpriseIdentityProviderPayloadSelector) => T
  ) => Field<
    "removeEnterpriseIdentityProvider",
    [
      Argument<
        "input",
        Variable<"input"> | RemoveEnterpriseIdentityProviderInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Removes an organization from the enterprise
   */

  readonly removeEnterpriseOrganization: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | RemoveEnterpriseOrganizationInput;
    },
    select: (t: RemoveEnterpriseOrganizationPayloadSelector) => T
  ) => Field<
    "removeEnterpriseOrganization",
    [Argument<"input", Variable<"input"> | RemoveEnterpriseOrganizationInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes labels from a Labelable object.
   */

  readonly removeLabelsFromLabelable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveLabelsFromLabelableInput },
    select: (t: RemoveLabelsFromLabelablePayloadSelector) => T
  ) => Field<
    "removeLabelsFromLabelable",
    [Argument<"input", Variable<"input"> | RemoveLabelsFromLabelableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes outside collaborator from all repositories in an organization.
   */

  readonly removeOutsideCollaborator: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveOutsideCollaboratorInput },
    select: (t: RemoveOutsideCollaboratorPayloadSelector) => T
  ) => Field<
    "removeOutsideCollaborator",
    [Argument<"input", Variable<"input"> | RemoveOutsideCollaboratorInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes a reaction from a subject.
   */

  readonly removeReaction: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveReactionInput },
    select: (t: RemoveReactionPayloadSelector) => T
  ) => Field<
    "removeReaction",
    [Argument<"input", Variable<"input"> | RemoveReactionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes a star from a Starrable.
   */

  readonly removeStar: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveStarInput },
    select: (t: RemoveStarPayloadSelector) => T
  ) => Field<
    "removeStar",
    [Argument<"input", Variable<"input"> | RemoveStarInput>],
    SelectionSet<T>
  >;

  /**
   * @description Reopen a issue.
   */

  readonly reopenIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ReopenIssueInput },
    select: (t: ReopenIssuePayloadSelector) => T
  ) => Field<
    "reopenIssue",
    [Argument<"input", Variable<"input"> | ReopenIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Reopen a pull request.
   */

  readonly reopenPullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ReopenPullRequestInput },
    select: (t: ReopenPullRequestPayloadSelector) => T
  ) => Field<
    "reopenPullRequest",
    [Argument<"input", Variable<"input"> | ReopenPullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Set review requests on a pull request.
   */

  readonly requestReviews: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RequestReviewsInput },
    select: (t: RequestReviewsPayloadSelector) => T
  ) => Field<
    "requestReviews",
    [Argument<"input", Variable<"input"> | RequestReviewsInput>],
    SelectionSet<T>
  >;

  /**
   * @description Rerequests an existing check suite.
   */

  readonly rerequestCheckSuite: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RerequestCheckSuiteInput },
    select: (t: RerequestCheckSuitePayloadSelector) => T
  ) => Field<
    "rerequestCheckSuite",
    [Argument<"input", Variable<"input"> | RerequestCheckSuiteInput>],
    SelectionSet<T>
  >;

  /**
   * @description Marks a review thread as resolved.
   */

  readonly resolveReviewThread: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ResolveReviewThreadInput },
    select: (t: ResolveReviewThreadPayloadSelector) => T
  ) => Field<
    "resolveReviewThread",
    [Argument<"input", Variable<"input"> | ResolveReviewThreadInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates or updates the identity provider for an enterprise.
   */

  readonly setEnterpriseIdentityProvider: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | SetEnterpriseIdentityProviderInput;
    },
    select: (t: SetEnterpriseIdentityProviderPayloadSelector) => T
  ) => Field<
    "setEnterpriseIdentityProvider",
    [Argument<"input", Variable<"input"> | SetEnterpriseIdentityProviderInput>],
    SelectionSet<T>
  >;

  /**
   * @description Set an organization level interaction limit for an organization's public repositories.
   */

  readonly setOrganizationInteractionLimit: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | SetOrganizationInteractionLimitInput;
    },
    select: (t: SetOrganizationInteractionLimitPayloadSelector) => T
  ) => Field<
    "setOrganizationInteractionLimit",
    [
      Argument<
        "input",
        Variable<"input"> | SetOrganizationInteractionLimitInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets an interaction limit setting for a repository.
   */

  readonly setRepositoryInteractionLimit: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | SetRepositoryInteractionLimitInput;
    },
    select: (t: SetRepositoryInteractionLimitPayloadSelector) => T
  ) => Field<
    "setRepositoryInteractionLimit",
    [Argument<"input", Variable<"input"> | SetRepositoryInteractionLimitInput>],
    SelectionSet<T>
  >;

  /**
   * @description Set a user level interaction limit for an user's public repositories.
   */

  readonly setUserInteractionLimit: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | SetUserInteractionLimitInput },
    select: (t: SetUserInteractionLimitPayloadSelector) => T
  ) => Field<
    "setUserInteractionLimit",
    [Argument<"input", Variable<"input"> | SetUserInteractionLimitInput>],
    SelectionSet<T>
  >;

  /**
   * @description Submits a pending pull request review.
   */

  readonly submitPullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | SubmitPullRequestReviewInput },
    select: (t: SubmitPullRequestReviewPayloadSelector) => T
  ) => Field<
    "submitPullRequestReview",
    [Argument<"input", Variable<"input"> | SubmitPullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Transfer an issue to a different repository
   */

  readonly transferIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | TransferIssueInput },
    select: (t: TransferIssuePayloadSelector) => T
  ) => Field<
    "transferIssue",
    [Argument<"input", Variable<"input"> | TransferIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unarchives a repository.
   */

  readonly unarchiveRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnarchiveRepositoryInput },
    select: (t: UnarchiveRepositoryPayloadSelector) => T
  ) => Field<
    "unarchiveRepository",
    [Argument<"input", Variable<"input"> | UnarchiveRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unfollow a user.
   */

  readonly unfollowUser: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnfollowUserInput },
    select: (t: UnfollowUserPayloadSelector) => T
  ) => Field<
    "unfollowUser",
    [Argument<"input", Variable<"input"> | UnfollowUserInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a repository link from a project.
   */

  readonly unlinkRepositoryFromProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnlinkRepositoryFromProjectInput },
    select: (t: UnlinkRepositoryFromProjectPayloadSelector) => T
  ) => Field<
    "unlinkRepositoryFromProject",
    [Argument<"input", Variable<"input"> | UnlinkRepositoryFromProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unlock a lockable object
   */

  readonly unlockLockable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnlockLockableInput },
    select: (t: UnlockLockablePayloadSelector) => T
  ) => Field<
    "unlockLockable",
    [Argument<"input", Variable<"input"> | UnlockLockableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unmark a pull request file as viewed
   */

  readonly unmarkFileAsViewed: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnmarkFileAsViewedInput },
    select: (t: UnmarkFileAsViewedPayloadSelector) => T
  ) => Field<
    "unmarkFileAsViewed",
    [Argument<"input", Variable<"input"> | UnmarkFileAsViewedInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unmark an issue as a duplicate of another issue.
   */

  readonly unmarkIssueAsDuplicate: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnmarkIssueAsDuplicateInput },
    select: (t: UnmarkIssueAsDuplicatePayloadSelector) => T
  ) => Field<
    "unmarkIssueAsDuplicate",
    [Argument<"input", Variable<"input"> | UnmarkIssueAsDuplicateInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unminimizes a comment on an Issue, Commit, Pull Request, or Gist
   */

  readonly unminimizeComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnminimizeCommentInput },
    select: (t: UnminimizeCommentPayloadSelector) => T
  ) => Field<
    "unminimizeComment",
    [Argument<"input", Variable<"input"> | UnminimizeCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Marks a review thread as unresolved.
   */

  readonly unresolveReviewThread: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnresolveReviewThreadInput },
    select: (t: UnresolveReviewThreadPayloadSelector) => T
  ) => Field<
    "unresolveReviewThread",
    [Argument<"input", Variable<"input"> | UnresolveReviewThreadInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new branch protection rule
   */

  readonly updateBranchProtectionRule: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateBranchProtectionRuleInput },
    select: (t: UpdateBranchProtectionRulePayloadSelector) => T
  ) => Field<
    "updateBranchProtectionRule",
    [Argument<"input", Variable<"input"> | UpdateBranchProtectionRuleInput>],
    SelectionSet<T>
  >;

  /**
   * @description Update a check run
   */

  readonly updateCheckRun: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateCheckRunInput },
    select: (t: UpdateCheckRunPayloadSelector) => T
  ) => Field<
    "updateCheckRun",
    [Argument<"input", Variable<"input"> | UpdateCheckRunInput>],
    SelectionSet<T>
  >;

  /**
   * @description Modifies the settings of an existing check suite
   */

  readonly updateCheckSuitePreferences: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateCheckSuitePreferencesInput },
    select: (t: UpdateCheckSuitePreferencesPayloadSelector) => T
  ) => Field<
    "updateCheckSuitePreferences",
    [Argument<"input", Variable<"input"> | UpdateCheckSuitePreferencesInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates the role of an enterprise administrator.
   */

  readonly updateEnterpriseAdministratorRole: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | UpdateEnterpriseAdministratorRoleInput;
    },
    select: (t: UpdateEnterpriseAdministratorRolePayloadSelector) => T
  ) => Field<
    "updateEnterpriseAdministratorRole",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseAdministratorRoleInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether private repository forks are enabled for an enterprise.
   */

  readonly updateEnterpriseAllowPrivateRepositoryForkingSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
    },
    select: (
      t: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseAllowPrivateRepositoryForkingSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the default repository permission for organizations in an enterprise.
   */

  readonly updateEnterpriseDefaultRepositoryPermissionSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
    },
    select: (
      t: UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseDefaultRepositoryPermissionSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseDefaultRepositoryPermissionSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether organization members with admin permissions on a repository can change repository visibility.
   */

  readonly updateEnterpriseMembersCanChangeRepositoryVisibilitySetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanChangeRepositoryVisibilitySetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can create repositories setting for an enterprise.
   */

  readonly updateEnterpriseMembersCanCreateRepositoriesSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanCreateRepositoriesSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanCreateRepositoriesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can delete issues setting for an enterprise.
   */

  readonly updateEnterpriseMembersCanDeleteIssuesSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanDeleteIssuesSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseMembersCanDeleteIssuesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can delete repositories setting for an enterprise.
   */

  readonly updateEnterpriseMembersCanDeleteRepositoriesSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanDeleteRepositoriesSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether members can invite collaborators are enabled for an enterprise.
   */

  readonly updateEnterpriseMembersCanInviteCollaboratorsSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanInviteCollaboratorsSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether or not an organization admin can make purchases.
   */

  readonly updateEnterpriseMembersCanMakePurchasesSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanMakePurchasesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanMakePurchasesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanMakePurchasesSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseMembersCanMakePurchasesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can update protected branches setting for an enterprise.
   */

  readonly updateEnterpriseMembersCanUpdateProtectedBranchesSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanUpdateProtectedBranchesSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can view dependency insights for an enterprise.
   */

  readonly updateEnterpriseMembersCanViewDependencyInsightsSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanViewDependencyInsightsSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether organization projects are enabled for an enterprise.
   */

  readonly updateEnterpriseOrganizationProjectsSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseOrganizationProjectsSettingInput;
    },
    select: (t: UpdateEnterpriseOrganizationProjectsSettingPayloadSelector) => T
  ) => Field<
    "updateEnterpriseOrganizationProjectsSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseOrganizationProjectsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Updates an enterprise's profile.
   */

  readonly updateEnterpriseProfile: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateEnterpriseProfileInput },
    select: (t: UpdateEnterpriseProfilePayloadSelector) => T
  ) => Field<
    "updateEnterpriseProfile",
    [Argument<"input", Variable<"input"> | UpdateEnterpriseProfileInput>],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether repository projects are enabled for a enterprise.
   */

  readonly updateEnterpriseRepositoryProjectsSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseRepositoryProjectsSettingInput;
    },
    select: (t: UpdateEnterpriseRepositoryProjectsSettingPayloadSelector) => T
  ) => Field<
    "updateEnterpriseRepositoryProjectsSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseRepositoryProjectsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether team discussions are enabled for an enterprise.
   */

  readonly updateEnterpriseTeamDiscussionsSetting: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | UpdateEnterpriseTeamDiscussionsSettingInput;
    },
    select: (t: UpdateEnterpriseTeamDiscussionsSettingPayloadSelector) => T
  ) => Field<
    "updateEnterpriseTeamDiscussionsSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseTeamDiscussionsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether two factor authentication is required for all users in an enterprise.
   */

  readonly updateEnterpriseTwoFactorAuthenticationRequiredSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
    },
    select: (
      t: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseTwoFactorAuthenticationRequiredSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether an IP allow list is enabled on an owner.
   */

  readonly updateIpAllowListEnabledSetting: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | UpdateIpAllowListEnabledSettingInput;
    },
    select: (t: UpdateIpAllowListEnabledSettingPayloadSelector) => T
  ) => Field<
    "updateIpAllowListEnabledSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateIpAllowListEnabledSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Updates an IP allow list entry.
   */

  readonly updateIpAllowListEntry: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateIpAllowListEntryInput },
    select: (t: UpdateIpAllowListEntryPayloadSelector) => T
  ) => Field<
    "updateIpAllowListEntry",
    [Argument<"input", Variable<"input"> | UpdateIpAllowListEntryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an Issue.
   */

  readonly updateIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateIssueInput },
    select: (t: UpdateIssuePayloadSelector) => T
  ) => Field<
    "updateIssue",
    [Argument<"input", Variable<"input"> | UpdateIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an IssueComment object.
   */

  readonly updateIssueComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateIssueCommentInput },
    select: (t: UpdateIssueCommentPayloadSelector) => T
  ) => Field<
    "updateIssueComment",
    [Argument<"input", Variable<"input"> | UpdateIssueCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an existing project.
   */

  readonly updateProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateProjectInput },
    select: (t: UpdateProjectPayloadSelector) => T
  ) => Field<
    "updateProject",
    [Argument<"input", Variable<"input"> | UpdateProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an existing project card.
   */

  readonly updateProjectCard: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateProjectCardInput },
    select: (t: UpdateProjectCardPayloadSelector) => T
  ) => Field<
    "updateProjectCard",
    [Argument<"input", Variable<"input"> | UpdateProjectCardInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an existing project column.
   */

  readonly updateProjectColumn: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateProjectColumnInput },
    select: (t: UpdateProjectColumnPayloadSelector) => T
  ) => Field<
    "updateProjectColumn",
    [Argument<"input", Variable<"input"> | UpdateProjectColumnInput>],
    SelectionSet<T>
  >;

  /**
   * @description Update a pull request
   */

  readonly updatePullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdatePullRequestInput },
    select: (t: UpdatePullRequestPayloadSelector) => T
  ) => Field<
    "updatePullRequest",
    [Argument<"input", Variable<"input"> | UpdatePullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates the body of a pull request review.
   */

  readonly updatePullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdatePullRequestReviewInput },
    select: (t: UpdatePullRequestReviewPayloadSelector) => T
  ) => Field<
    "updatePullRequestReview",
    [Argument<"input", Variable<"input"> | UpdatePullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates a pull request review comment.
   */

  readonly updatePullRequestReviewComment: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | UpdatePullRequestReviewCommentInput;
    },
    select: (t: UpdatePullRequestReviewCommentPayloadSelector) => T
  ) => Field<
    "updatePullRequestReviewComment",
    [
      Argument<"input", Variable<"input"> | UpdatePullRequestReviewCommentInput>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Update a Git Ref.
   */

  readonly updateRef: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateRefInput },
    select: (t: UpdateRefPayloadSelector) => T
  ) => Field<
    "updateRef",
    [Argument<"input", Variable<"input"> | UpdateRefInput>],
    SelectionSet<T>
  >;

  /**
   * @description Update information about a repository.
   */

  readonly updateRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateRepositoryInput },
    select: (t: UpdateRepositoryPayloadSelector) => T
  ) => Field<
    "updateRepository",
    [Argument<"input", Variable<"input"> | UpdateRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates the state for subscribable subjects.
   */

  readonly updateSubscription: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateSubscriptionInput },
    select: (t: UpdateSubscriptionPayloadSelector) => T
  ) => Field<
    "updateSubscription",
    [Argument<"input", Variable<"input"> | UpdateSubscriptionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates a team discussion.
   */

  readonly updateTeamDiscussion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateTeamDiscussionInput },
    select: (t: UpdateTeamDiscussionPayloadSelector) => T
  ) => Field<
    "updateTeamDiscussion",
    [Argument<"input", Variable<"input"> | UpdateTeamDiscussionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates a discussion comment.
   */

  readonly updateTeamDiscussionComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateTeamDiscussionCommentInput },
    select: (t: UpdateTeamDiscussionCommentPayloadSelector) => T
  ) => Field<
    "updateTeamDiscussionComment",
    [Argument<"input", Variable<"input"> | UpdateTeamDiscussionCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Replaces the repository's topics with the given topics.
   */

  readonly updateTopics: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateTopicsInput },
    select: (t: UpdateTopicsPayloadSelector) => T
  ) => Field<
    "updateTopics",
    [Argument<"input", Variable<"input"> | UpdateTopicsInput>],
    SelectionSet<T>
  >;
}

export const Mutation: MutationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Accepts a pending invitation for a user to become an administrator of an enterprise.
   */

  acceptEnterpriseAdministratorInvitation: (variables, select) =>
    new Field(
      "acceptEnterpriseAdministratorInvitation",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AcceptEnterpriseAdministratorInvitationPayload))
    ),

  /**
   * @description Applies a suggested topic to the repository.
   */

  acceptTopicSuggestion: (variables, select) =>
    new Field(
      "acceptTopicSuggestion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AcceptTopicSuggestionPayload))
    ),

  /**
   * @description Adds assignees to an assignable object.
   */

  addAssigneesToAssignable: (variables, select) =>
    new Field(
      "addAssigneesToAssignable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddAssigneesToAssignablePayload))
    ),

  /**
   * @description Adds a comment to an Issue or Pull Request.
   */

  addComment: (variables, select) =>
    new Field(
      "addComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddCommentPayload))
    ),

  /**
   * @description Adds labels to a labelable object.
   */

  addLabelsToLabelable: (variables, select) =>
    new Field(
      "addLabelsToLabelable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddLabelsToLabelablePayload))
    ),

  /**
   * @description Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both.
   */

  addProjectCard: (variables, select) =>
    new Field(
      "addProjectCard",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddProjectCardPayload))
    ),

  /**
   * @description Adds a column to a Project.
   */

  addProjectColumn: (variables, select) =>
    new Field(
      "addProjectColumn",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddProjectColumnPayload))
    ),

  /**
   * @description Adds a review to a Pull Request.
   */

  addPullRequestReview: (variables, select) =>
    new Field(
      "addPullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddPullRequestReviewPayload))
    ),

  /**
   * @description Adds a comment to a review.
   */

  addPullRequestReviewComment: (variables, select) =>
    new Field(
      "addPullRequestReviewComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddPullRequestReviewCommentPayload))
    ),

  /**
   * @description Adds a new thread to a pending Pull Request Review.
   */

  addPullRequestReviewThread: (variables, select) =>
    new Field(
      "addPullRequestReviewThread",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddPullRequestReviewThreadPayload))
    ),

  /**
   * @description Adds a reaction to a subject.
   */

  addReaction: (variables, select) =>
    new Field(
      "addReaction",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddReactionPayload))
    ),

  /**
   * @description Adds a star to a Starrable.
   */

  addStar: (variables, select) =>
    new Field(
      "addStar",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddStarPayload))
    ),

  /**
   * @description Marks a repository as archived.
   */

  archiveRepository: (variables, select) =>
    new Field(
      "archiveRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ArchiveRepositoryPayload))
    ),

  /**
   * @description Cancels a pending invitation for an administrator to join an enterprise.
   */

  cancelEnterpriseAdminInvitation: (variables, select) =>
    new Field(
      "cancelEnterpriseAdminInvitation",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CancelEnterpriseAdminInvitationPayload))
    ),

  /**
   * @description Update your status on GitHub.
   */

  changeUserStatus: (variables, select) =>
    new Field(
      "changeUserStatus",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ChangeUserStatusPayload))
    ),

  /**
   * @description Clears all labels from a labelable object.
   */

  clearLabelsFromLabelable: (variables, select) =>
    new Field(
      "clearLabelsFromLabelable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ClearLabelsFromLabelablePayload))
    ),

  /**
   * @description Creates a new project by cloning configuration from an existing project.
   */

  cloneProject: (variables, select) =>
    new Field(
      "cloneProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CloneProjectPayload))
    ),

  /**
   * @description Create a new repository with the same files and directory structure as a template repository.
   */

  cloneTemplateRepository: (variables, select) =>
    new Field(
      "cloneTemplateRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CloneTemplateRepositoryPayload))
    ),

  /**
   * @description Close an issue.
   */

  closeIssue: (variables, select) =>
    new Field(
      "closeIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CloseIssuePayload))
    ),

  /**
   * @description Close a pull request.
   */

  closePullRequest: (variables, select) =>
    new Field(
      "closePullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ClosePullRequestPayload))
    ),

  /**
   * @description Convert a project note card to one associated with a newly created issue.
   */

  convertProjectCardNoteToIssue: (variables, select) =>
    new Field(
      "convertProjectCardNoteToIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ConvertProjectCardNoteToIssuePayload))
    ),

  /**
   * @description Create a new branch protection rule
   */

  createBranchProtectionRule: (variables, select) =>
    new Field(
      "createBranchProtectionRule",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateBranchProtectionRulePayload))
    ),

  /**
   * @description Create a check run.
   */

  createCheckRun: (variables, select) =>
    new Field(
      "createCheckRun",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateCheckRunPayload))
    ),

  /**
   * @description Create a check suite
   */

  createCheckSuite: (variables, select) =>
    new Field(
      "createCheckSuite",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateCheckSuitePayload))
    ),

  /**
   * @description Creates an organization as part of an enterprise account.
   */

  createEnterpriseOrganization: (variables, select) =>
    new Field(
      "createEnterpriseOrganization",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateEnterpriseOrganizationPayload))
    ),

  /**
   * @description Creates a new IP allow list entry.
   */

  createIpAllowListEntry: (variables, select) =>
    new Field(
      "createIpAllowListEntry",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateIpAllowListEntryPayload))
    ),

  /**
   * @description Creates a new issue.
   */

  createIssue: (variables, select) =>
    new Field(
      "createIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateIssuePayload))
    ),

  /**
   * @description Creates a new project.
   */

  createProject: (variables, select) =>
    new Field(
      "createProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateProjectPayload))
    ),

  /**
   * @description Create a new pull request
   */

  createPullRequest: (variables, select) =>
    new Field(
      "createPullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreatePullRequestPayload))
    ),

  /**
   * @description Create a new Git Ref.
   */

  createRef: (variables, select) =>
    new Field(
      "createRef",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateRefPayload))
    ),

  /**
   * @description Create a new repository.
   */

  createRepository: (variables, select) =>
    new Field(
      "createRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateRepositoryPayload))
    ),

  /**
   * @description Creates a new team discussion.
   */

  createTeamDiscussion: (variables, select) =>
    new Field(
      "createTeamDiscussion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateTeamDiscussionPayload))
    ),

  /**
   * @description Creates a new team discussion comment.
   */

  createTeamDiscussionComment: (variables, select) =>
    new Field(
      "createTeamDiscussionComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateTeamDiscussionCommentPayload))
    ),

  /**
   * @description Rejects a suggested topic for the repository.
   */

  declineTopicSuggestion: (variables, select) =>
    new Field(
      "declineTopicSuggestion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeclineTopicSuggestionPayload))
    ),

  /**
   * @description Delete a branch protection rule
   */

  deleteBranchProtectionRule: (variables, select) =>
    new Field(
      "deleteBranchProtectionRule",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteBranchProtectionRulePayload))
    ),

  /**
   * @description Deletes a deployment.
   */

  deleteDeployment: (variables, select) =>
    new Field(
      "deleteDeployment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteDeploymentPayload))
    ),

  /**
   * @description Deletes an IP allow list entry.
   */

  deleteIpAllowListEntry: (variables, select) =>
    new Field(
      "deleteIpAllowListEntry",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteIpAllowListEntryPayload))
    ),

  /**
   * @description Deletes an Issue object.
   */

  deleteIssue: (variables, select) =>
    new Field(
      "deleteIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteIssuePayload))
    ),

  /**
   * @description Deletes an IssueComment object.
   */

  deleteIssueComment: (variables, select) =>
    new Field(
      "deleteIssueComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteIssueCommentPayload))
    ),

  /**
   * @description Deletes a project.
   */

  deleteProject: (variables, select) =>
    new Field(
      "deleteProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteProjectPayload))
    ),

  /**
   * @description Deletes a project card.
   */

  deleteProjectCard: (variables, select) =>
    new Field(
      "deleteProjectCard",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteProjectCardPayload))
    ),

  /**
   * @description Deletes a project column.
   */

  deleteProjectColumn: (variables, select) =>
    new Field(
      "deleteProjectColumn",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteProjectColumnPayload))
    ),

  /**
   * @description Deletes a pull request review.
   */

  deletePullRequestReview: (variables, select) =>
    new Field(
      "deletePullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeletePullRequestReviewPayload))
    ),

  /**
   * @description Deletes a pull request review comment.
   */

  deletePullRequestReviewComment: (variables, select) =>
    new Field(
      "deletePullRequestReviewComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeletePullRequestReviewCommentPayload))
    ),

  /**
   * @description Delete a Git Ref.
   */

  deleteRef: (variables, select) =>
    new Field(
      "deleteRef",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteRefPayload))
    ),

  /**
   * @description Deletes a team discussion.
   */

  deleteTeamDiscussion: (variables, select) =>
    new Field(
      "deleteTeamDiscussion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteTeamDiscussionPayload))
    ),

  /**
   * @description Deletes a team discussion comment.
   */

  deleteTeamDiscussionComment: (variables, select) =>
    new Field(
      "deleteTeamDiscussionComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteTeamDiscussionCommentPayload))
    ),

  /**
   * @description Dismisses an approved or rejected pull request review.
   */

  dismissPullRequestReview: (variables, select) =>
    new Field(
      "dismissPullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DismissPullRequestReviewPayload))
    ),

  /**
   * @description Follow a user.
   */

  followUser: (variables, select) =>
    new Field(
      "followUser",
      [new Argument("input", variables.input)],
      new SelectionSet(select(FollowUserPayload))
    ),

  /**
   * @description Invite someone to become an administrator of the enterprise.
   */

  inviteEnterpriseAdmin: (variables, select) =>
    new Field(
      "inviteEnterpriseAdmin",
      [new Argument("input", variables.input)],
      new SelectionSet(select(InviteEnterpriseAdminPayload))
    ),

  /**
   * @description Creates a repository link for a project.
   */

  linkRepositoryToProject: (variables, select) =>
    new Field(
      "linkRepositoryToProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(LinkRepositoryToProjectPayload))
    ),

  /**
   * @description Lock a lockable object
   */

  lockLockable: (variables, select) =>
    new Field(
      "lockLockable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(LockLockablePayload))
    ),

  /**
   * @description Mark a pull request file as viewed
   */

  markFileAsViewed: (variables, select) =>
    new Field(
      "markFileAsViewed",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MarkFileAsViewedPayload))
    ),

  /**
   * @description Marks a pull request ready for review.
   */

  markPullRequestReadyForReview: (variables, select) =>
    new Field(
      "markPullRequestReadyForReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MarkPullRequestReadyForReviewPayload))
    ),

  /**
   * @description Merge a head into a branch.
   */

  mergeBranch: (variables, select) =>
    new Field(
      "mergeBranch",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MergeBranchPayload))
    ),

  /**
   * @description Merge a pull request.
   */

  mergePullRequest: (variables, select) =>
    new Field(
      "mergePullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MergePullRequestPayload))
    ),

  /**
   * @description Minimizes a comment on an Issue, Commit, Pull Request, or Gist
   */

  minimizeComment: (variables, select) =>
    new Field(
      "minimizeComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MinimizeCommentPayload))
    ),

  /**
   * @description Moves a project card to another place.
   */

  moveProjectCard: (variables, select) =>
    new Field(
      "moveProjectCard",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MoveProjectCardPayload))
    ),

  /**
   * @description Moves a project column to another place.
   */

  moveProjectColumn: (variables, select) =>
    new Field(
      "moveProjectColumn",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MoveProjectColumnPayload))
    ),

  /**
   * @description Regenerates the identity provider recovery codes for an enterprise
   */

  regenerateEnterpriseIdentityProviderRecoveryCodes: (variables, select) =>
    new Field(
      "regenerateEnterpriseIdentityProviderRecoveryCodes",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(RegenerateEnterpriseIdentityProviderRecoveryCodesPayload)
      )
    ),

  /**
   * @description Removes assignees from an assignable object.
   */

  removeAssigneesFromAssignable: (variables, select) =>
    new Field(
      "removeAssigneesFromAssignable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveAssigneesFromAssignablePayload))
    ),

  /**
   * @description Removes an administrator from the enterprise.
   */

  removeEnterpriseAdmin: (variables, select) =>
    new Field(
      "removeEnterpriseAdmin",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveEnterpriseAdminPayload))
    ),

  /**
   * @description Removes the identity provider from an enterprise
   */

  removeEnterpriseIdentityProvider: (variables, select) =>
    new Field(
      "removeEnterpriseIdentityProvider",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveEnterpriseIdentityProviderPayload))
    ),

  /**
   * @description Removes an organization from the enterprise
   */

  removeEnterpriseOrganization: (variables, select) =>
    new Field(
      "removeEnterpriseOrganization",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveEnterpriseOrganizationPayload))
    ),

  /**
   * @description Removes labels from a Labelable object.
   */

  removeLabelsFromLabelable: (variables, select) =>
    new Field(
      "removeLabelsFromLabelable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveLabelsFromLabelablePayload))
    ),

  /**
   * @description Removes outside collaborator from all repositories in an organization.
   */

  removeOutsideCollaborator: (variables, select) =>
    new Field(
      "removeOutsideCollaborator",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveOutsideCollaboratorPayload))
    ),

  /**
   * @description Removes a reaction from a subject.
   */

  removeReaction: (variables, select) =>
    new Field(
      "removeReaction",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveReactionPayload))
    ),

  /**
   * @description Removes a star from a Starrable.
   */

  removeStar: (variables, select) =>
    new Field(
      "removeStar",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveStarPayload))
    ),

  /**
   * @description Reopen a issue.
   */

  reopenIssue: (variables, select) =>
    new Field(
      "reopenIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ReopenIssuePayload))
    ),

  /**
   * @description Reopen a pull request.
   */

  reopenPullRequest: (variables, select) =>
    new Field(
      "reopenPullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ReopenPullRequestPayload))
    ),

  /**
   * @description Set review requests on a pull request.
   */

  requestReviews: (variables, select) =>
    new Field(
      "requestReviews",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RequestReviewsPayload))
    ),

  /**
   * @description Rerequests an existing check suite.
   */

  rerequestCheckSuite: (variables, select) =>
    new Field(
      "rerequestCheckSuite",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RerequestCheckSuitePayload))
    ),

  /**
   * @description Marks a review thread as resolved.
   */

  resolveReviewThread: (variables, select) =>
    new Field(
      "resolveReviewThread",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ResolveReviewThreadPayload))
    ),

  /**
   * @description Creates or updates the identity provider for an enterprise.
   */

  setEnterpriseIdentityProvider: (variables, select) =>
    new Field(
      "setEnterpriseIdentityProvider",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SetEnterpriseIdentityProviderPayload))
    ),

  /**
   * @description Set an organization level interaction limit for an organization's public repositories.
   */

  setOrganizationInteractionLimit: (variables, select) =>
    new Field(
      "setOrganizationInteractionLimit",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SetOrganizationInteractionLimitPayload))
    ),

  /**
   * @description Sets an interaction limit setting for a repository.
   */

  setRepositoryInteractionLimit: (variables, select) =>
    new Field(
      "setRepositoryInteractionLimit",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SetRepositoryInteractionLimitPayload))
    ),

  /**
   * @description Set a user level interaction limit for an user's public repositories.
   */

  setUserInteractionLimit: (variables, select) =>
    new Field(
      "setUserInteractionLimit",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SetUserInteractionLimitPayload))
    ),

  /**
   * @description Submits a pending pull request review.
   */

  submitPullRequestReview: (variables, select) =>
    new Field(
      "submitPullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SubmitPullRequestReviewPayload))
    ),

  /**
   * @description Transfer an issue to a different repository
   */

  transferIssue: (variables, select) =>
    new Field(
      "transferIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(TransferIssuePayload))
    ),

  /**
   * @description Unarchives a repository.
   */

  unarchiveRepository: (variables, select) =>
    new Field(
      "unarchiveRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnarchiveRepositoryPayload))
    ),

  /**
   * @description Unfollow a user.
   */

  unfollowUser: (variables, select) =>
    new Field(
      "unfollowUser",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnfollowUserPayload))
    ),

  /**
   * @description Deletes a repository link from a project.
   */

  unlinkRepositoryFromProject: (variables, select) =>
    new Field(
      "unlinkRepositoryFromProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnlinkRepositoryFromProjectPayload))
    ),

  /**
   * @description Unlock a lockable object
   */

  unlockLockable: (variables, select) =>
    new Field(
      "unlockLockable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnlockLockablePayload))
    ),

  /**
   * @description Unmark a pull request file as viewed
   */

  unmarkFileAsViewed: (variables, select) =>
    new Field(
      "unmarkFileAsViewed",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnmarkFileAsViewedPayload))
    ),

  /**
   * @description Unmark an issue as a duplicate of another issue.
   */

  unmarkIssueAsDuplicate: (variables, select) =>
    new Field(
      "unmarkIssueAsDuplicate",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnmarkIssueAsDuplicatePayload))
    ),

  /**
   * @description Unminimizes a comment on an Issue, Commit, Pull Request, or Gist
   */

  unminimizeComment: (variables, select) =>
    new Field(
      "unminimizeComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnminimizeCommentPayload))
    ),

  /**
   * @description Marks a review thread as unresolved.
   */

  unresolveReviewThread: (variables, select) =>
    new Field(
      "unresolveReviewThread",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnresolveReviewThreadPayload))
    ),

  /**
   * @description Create a new branch protection rule
   */

  updateBranchProtectionRule: (variables, select) =>
    new Field(
      "updateBranchProtectionRule",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateBranchProtectionRulePayload))
    ),

  /**
   * @description Update a check run
   */

  updateCheckRun: (variables, select) =>
    new Field(
      "updateCheckRun",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateCheckRunPayload))
    ),

  /**
   * @description Modifies the settings of an existing check suite
   */

  updateCheckSuitePreferences: (variables, select) =>
    new Field(
      "updateCheckSuitePreferences",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateCheckSuitePreferencesPayload))
    ),

  /**
   * @description Updates the role of an enterprise administrator.
   */

  updateEnterpriseAdministratorRole: (variables, select) =>
    new Field(
      "updateEnterpriseAdministratorRole",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateEnterpriseAdministratorRolePayload))
    ),

  /**
   * @description Sets whether private repository forks are enabled for an enterprise.
   */

  updateEnterpriseAllowPrivateRepositoryForkingSetting: (variables, select) =>
    new Field(
      "updateEnterpriseAllowPrivateRepositoryForkingSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload)
      )
    ),

  /**
   * @description Sets the default repository permission for organizations in an enterprise.
   */

  updateEnterpriseDefaultRepositoryPermissionSetting: (variables, select) =>
    new Field(
      "updateEnterpriseDefaultRepositoryPermissionSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseDefaultRepositoryPermissionSettingPayload)
      )
    ),

  /**
   * @description Sets whether organization members with admin permissions on a repository can change repository visibility.
   */

  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting: (
    variables,
    select
  ) =>
    new Field(
      "updateEnterpriseMembersCanChangeRepositoryVisibilitySetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(
          UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload
        )
      )
    ),

  /**
   * @description Sets the members can create repositories setting for an enterprise.
   */

  updateEnterpriseMembersCanCreateRepositoriesSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanCreateRepositoriesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload)
      )
    ),

  /**
   * @description Sets the members can delete issues setting for an enterprise.
   */

  updateEnterpriseMembersCanDeleteIssuesSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanDeleteIssuesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanDeleteIssuesSettingPayload)
      )
    ),

  /**
   * @description Sets the members can delete repositories setting for an enterprise.
   */

  updateEnterpriseMembersCanDeleteRepositoriesSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanDeleteRepositoriesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload)
      )
    ),

  /**
   * @description Sets whether members can invite collaborators are enabled for an enterprise.
   */

  updateEnterpriseMembersCanInviteCollaboratorsSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanInviteCollaboratorsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload)
      )
    ),

  /**
   * @description Sets whether or not an organization admin can make purchases.
   */

  updateEnterpriseMembersCanMakePurchasesSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanMakePurchasesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanMakePurchasesSettingPayload)
      )
    ),

  /**
   * @description Sets the members can update protected branches setting for an enterprise.
   */

  updateEnterpriseMembersCanUpdateProtectedBranchesSetting: (
    variables,
    select
  ) =>
    new Field(
      "updateEnterpriseMembersCanUpdateProtectedBranchesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload)
      )
    ),

  /**
   * @description Sets the members can view dependency insights for an enterprise.
   */

  updateEnterpriseMembersCanViewDependencyInsightsSetting: (
    variables,
    select
  ) =>
    new Field(
      "updateEnterpriseMembersCanViewDependencyInsightsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload)
      )
    ),

  /**
   * @description Sets whether organization projects are enabled for an enterprise.
   */

  updateEnterpriseOrganizationProjectsSetting: (variables, select) =>
    new Field(
      "updateEnterpriseOrganizationProjectsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseOrganizationProjectsSettingPayload)
      )
    ),

  /**
   * @description Updates an enterprise's profile.
   */

  updateEnterpriseProfile: (variables, select) =>
    new Field(
      "updateEnterpriseProfile",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateEnterpriseProfilePayload))
    ),

  /**
   * @description Sets whether repository projects are enabled for a enterprise.
   */

  updateEnterpriseRepositoryProjectsSetting: (variables, select) =>
    new Field(
      "updateEnterpriseRepositoryProjectsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateEnterpriseRepositoryProjectsSettingPayload))
    ),

  /**
   * @description Sets whether team discussions are enabled for an enterprise.
   */

  updateEnterpriseTeamDiscussionsSetting: (variables, select) =>
    new Field(
      "updateEnterpriseTeamDiscussionsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateEnterpriseTeamDiscussionsSettingPayload))
    ),

  /**
   * @description Sets whether two factor authentication is required for all users in an enterprise.
   */

  updateEnterpriseTwoFactorAuthenticationRequiredSetting: (variables, select) =>
    new Field(
      "updateEnterpriseTwoFactorAuthenticationRequiredSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload)
      )
    ),

  /**
   * @description Sets whether an IP allow list is enabled on an owner.
   */

  updateIpAllowListEnabledSetting: (variables, select) =>
    new Field(
      "updateIpAllowListEnabledSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateIpAllowListEnabledSettingPayload))
    ),

  /**
   * @description Updates an IP allow list entry.
   */

  updateIpAllowListEntry: (variables, select) =>
    new Field(
      "updateIpAllowListEntry",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateIpAllowListEntryPayload))
    ),

  /**
   * @description Updates an Issue.
   */

  updateIssue: (variables, select) =>
    new Field(
      "updateIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateIssuePayload))
    ),

  /**
   * @description Updates an IssueComment object.
   */

  updateIssueComment: (variables, select) =>
    new Field(
      "updateIssueComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateIssueCommentPayload))
    ),

  /**
   * @description Updates an existing project.
   */

  updateProject: (variables, select) =>
    new Field(
      "updateProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateProjectPayload))
    ),

  /**
   * @description Updates an existing project card.
   */

  updateProjectCard: (variables, select) =>
    new Field(
      "updateProjectCard",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateProjectCardPayload))
    ),

  /**
   * @description Updates an existing project column.
   */

  updateProjectColumn: (variables, select) =>
    new Field(
      "updateProjectColumn",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateProjectColumnPayload))
    ),

  /**
   * @description Update a pull request
   */

  updatePullRequest: (variables, select) =>
    new Field(
      "updatePullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdatePullRequestPayload))
    ),

  /**
   * @description Updates the body of a pull request review.
   */

  updatePullRequestReview: (variables, select) =>
    new Field(
      "updatePullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdatePullRequestReviewPayload))
    ),

  /**
   * @description Updates a pull request review comment.
   */

  updatePullRequestReviewComment: (variables, select) =>
    new Field(
      "updatePullRequestReviewComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdatePullRequestReviewCommentPayload))
    ),

  /**
   * @description Update a Git Ref.
   */

  updateRef: (variables, select) =>
    new Field(
      "updateRef",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateRefPayload))
    ),

  /**
   * @description Update information about a repository.
   */

  updateRepository: (variables, select) =>
    new Field(
      "updateRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateRepositoryPayload))
    ),

  /**
   * @description Updates the state for subscribable subjects.
   */

  updateSubscription: (variables, select) =>
    new Field(
      "updateSubscription",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateSubscriptionPayload))
    ),

  /**
   * @description Updates a team discussion.
   */

  updateTeamDiscussion: (variables, select) =>
    new Field(
      "updateTeamDiscussion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateTeamDiscussionPayload))
    ),

  /**
   * @description Updates a discussion comment.
   */

  updateTeamDiscussionComment: (variables, select) =>
    new Field(
      "updateTeamDiscussionComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateTeamDiscussionCommentPayload))
    ),

  /**
   * @description Replaces the repository's topics with the given topics.
   */

  updateTopics: (variables, select) =>
    new Field(
      "updateTopics",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateTopicsPayload))
    ),
};

export interface INode {
  readonly __typename: string;
  readonly id: string;
}

interface NodeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description ID of the object.
   */

  readonly id: () => Field<"id">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "AddedToProjectEvent"
      | "App"
      | "AssignedEvent"
      | "AutomaticBaseChangeFailedEvent"
      | "AutomaticBaseChangeSucceededEvent"
      | "BaseRefChangedEvent"
      | "BaseRefDeletedEvent"
      | "BaseRefForcePushedEvent"
      | "Blob"
      | "Bot"
      | "BranchProtectionRule"
      | "CheckRun"
      | "CheckSuite"
      | "ClosedEvent"
      | "CodeOfConduct"
      | "CommentDeletedEvent"
      | "Commit"
      | "CommitComment"
      | "CommitCommentThread"
      | "ConnectedEvent"
      | "ConvertToDraftEvent"
      | "ConvertedNoteToIssueEvent"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "DeployKey"
      | "DeployedEvent"
      | "Deployment"
      | "DeploymentEnvironmentChangedEvent"
      | "DeploymentStatus"
      | "DisconnectedEvent"
      | "Enterprise"
      | "EnterpriseAdministratorInvitation"
      | "EnterpriseIdentityProvider"
      | "EnterpriseRepositoryInfo"
      | "EnterpriseServerInstallation"
      | "EnterpriseServerUserAccount"
      | "EnterpriseServerUserAccountEmail"
      | "EnterpriseServerUserAccountsUpload"
      | "EnterpriseUserAccount"
      | "ExternalIdentity"
      | "Gist"
      | "GistComment"
      | "HeadRefDeletedEvent"
      | "HeadRefForcePushedEvent"
      | "HeadRefRestoredEvent"
      | "IpAllowListEntry"
      | "Issue"
      | "IssueComment"
      | "Label"
      | "LabeledEvent"
      | "Language"
      | "License"
      | "LockedEvent"
      | "Mannequin"
      | "MarkedAsDuplicateEvent"
      | "MarketplaceCategory"
      | "MarketplaceListing"
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "MentionedEvent"
      | "MergedEvent"
      | "Milestone"
      | "MilestonedEvent"
      | "MovedColumnsInProjectEvent"
      | "OauthApplicationCreateAuditEntry"
      | "OrgAddBillingManagerAuditEntry"
      | "OrgAddMemberAuditEntry"
      | "OrgBlockUserAuditEntry"
      | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
      | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
      | "OrgCreateAuditEntry"
      | "OrgDisableOauthAppRestrictionsAuditEntry"
      | "OrgDisableSamlAuditEntry"
      | "OrgDisableTwoFactorRequirementAuditEntry"
      | "OrgEnableOauthAppRestrictionsAuditEntry"
      | "OrgEnableSamlAuditEntry"
      | "OrgEnableTwoFactorRequirementAuditEntry"
      | "OrgInviteMemberAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
      | "OrgRemoveBillingManagerAuditEntry"
      | "OrgRemoveMemberAuditEntry"
      | "OrgRemoveOutsideCollaboratorAuditEntry"
      | "OrgRestoreMemberAuditEntry"
      | "OrgUnblockUserAuditEntry"
      | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
      | "OrgUpdateMemberAuditEntry"
      | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
      | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
      | "Organization"
      | "OrganizationIdentityProvider"
      | "OrganizationInvitation"
      | "Package"
      | "PackageFile"
      | "PackageTag"
      | "PackageVersion"
      | "PinnedEvent"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "Project"
      | "ProjectCard"
      | "ProjectColumn"
      | "PublicKey"
      | "PullRequest"
      | "PullRequestCommit"
      | "PullRequestCommitCommentThread"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "PullRequestReviewThread"
      | "Push"
      | "PushAllowance"
      | "Reaction"
      | "ReadyForReviewEvent"
      | "Ref"
      | "ReferencedEvent"
      | "Release"
      | "ReleaseAsset"
      | "RemovedFromProjectEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "Repository"
      | "RepositoryInvitation"
      | "RepositoryTopic"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
      | "RepositoryVulnerabilityAlert"
      | "ReviewDismissalAllowance"
      | "ReviewDismissedEvent"
      | "ReviewRequest"
      | "ReviewRequestRemovedEvent"
      | "ReviewRequestedEvent"
      | "SavedReply"
      | "SecurityAdvisory"
      | "SponsorsListing"
      | "SponsorsTier"
      | "Sponsorship"
      | "Status"
      | "StatusCheckRollup"
      | "StatusContext"
      | "SubscribedEvent"
      | "Tag"
      | "Team"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
      | "Topic"
      | "TransferredEvent"
      | "Tree"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnmarkedAsDuplicateEvent"
      | "UnpinnedEvent"
      | "UnsubscribedEvent"
      | "User"
      | "UserBlockedEvent"
      | "UserContentEdit"
      | "UserStatus"
  >(
    type: F,
    select: (
      t: F extends "AddedToProjectEvent"
        ? AddedToProjectEventSelector
        : F extends "App"
        ? AppSelector
        : F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "AutomaticBaseChangeFailedEvent"
        ? AutomaticBaseChangeFailedEventSelector
        : F extends "AutomaticBaseChangeSucceededEvent"
        ? AutomaticBaseChangeSucceededEventSelector
        : F extends "BaseRefChangedEvent"
        ? BaseRefChangedEventSelector
        : F extends "BaseRefDeletedEvent"
        ? BaseRefDeletedEventSelector
        : F extends "BaseRefForcePushedEvent"
        ? BaseRefForcePushedEventSelector
        : F extends "Blob"
        ? BlobSelector
        : F extends "Bot"
        ? BotSelector
        : F extends "BranchProtectionRule"
        ? BranchProtectionRuleSelector
        : F extends "CheckRun"
        ? CheckRunSelector
        : F extends "CheckSuite"
        ? CheckSuiteSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "CodeOfConduct"
        ? CodeOfConductSelector
        : F extends "CommentDeletedEvent"
        ? CommentDeletedEventSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "CommitCommentThread"
        ? CommitCommentThreadSelector
        : F extends "ConnectedEvent"
        ? ConnectedEventSelector
        : F extends "ConvertToDraftEvent"
        ? ConvertToDraftEventSelector
        : F extends "ConvertedNoteToIssueEvent"
        ? ConvertedNoteToIssueEventSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "DeployKey"
        ? DeployKeySelector
        : F extends "DeployedEvent"
        ? DeployedEventSelector
        : F extends "Deployment"
        ? DeploymentSelector
        : F extends "DeploymentEnvironmentChangedEvent"
        ? DeploymentEnvironmentChangedEventSelector
        : F extends "DeploymentStatus"
        ? DeploymentStatusSelector
        : F extends "DisconnectedEvent"
        ? DisconnectedEventSelector
        : F extends "Enterprise"
        ? EnterpriseSelector
        : F extends "EnterpriseAdministratorInvitation"
        ? EnterpriseAdministratorInvitationSelector
        : F extends "EnterpriseIdentityProvider"
        ? EnterpriseIdentityProviderSelector
        : F extends "EnterpriseRepositoryInfo"
        ? EnterpriseRepositoryInfoSelector
        : F extends "EnterpriseServerInstallation"
        ? EnterpriseServerInstallationSelector
        : F extends "EnterpriseServerUserAccount"
        ? EnterpriseServerUserAccountSelector
        : F extends "EnterpriseServerUserAccountEmail"
        ? EnterpriseServerUserAccountEmailSelector
        : F extends "EnterpriseServerUserAccountsUpload"
        ? EnterpriseServerUserAccountsUploadSelector
        : F extends "EnterpriseUserAccount"
        ? EnterpriseUserAccountSelector
        : F extends "ExternalIdentity"
        ? ExternalIdentitySelector
        : F extends "Gist"
        ? GistSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "HeadRefDeletedEvent"
        ? HeadRefDeletedEventSelector
        : F extends "HeadRefForcePushedEvent"
        ? HeadRefForcePushedEventSelector
        : F extends "HeadRefRestoredEvent"
        ? HeadRefRestoredEventSelector
        : F extends "IpAllowListEntry"
        ? IpAllowListEntrySelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "Label"
        ? LabelSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "Language"
        ? LanguageSelector
        : F extends "License"
        ? LicenseSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "Mannequin"
        ? MannequinSelector
        : F extends "MarkedAsDuplicateEvent"
        ? MarkedAsDuplicateEventSelector
        : F extends "MarketplaceCategory"
        ? MarketplaceCategorySelector
        : F extends "MarketplaceListing"
        ? MarketplaceListingSelector
        : F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "MentionedEvent"
        ? MentionedEventSelector
        : F extends "MergedEvent"
        ? MergedEventSelector
        : F extends "Milestone"
        ? MilestoneSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "MovedColumnsInProjectEvent"
        ? MovedColumnsInProjectEventSelector
        : F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgAddBillingManagerAuditEntry"
        ? OrgAddBillingManagerAuditEntrySelector
        : F extends "OrgAddMemberAuditEntry"
        ? OrgAddMemberAuditEntrySelector
        : F extends "OrgBlockUserAuditEntry"
        ? OrgBlockUserAuditEntrySelector
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? OrgConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? OrgConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgCreateAuditEntry"
        ? OrgCreateAuditEntrySelector
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? OrgDisableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgDisableSamlAuditEntry"
        ? OrgDisableSamlAuditEntrySelector
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? OrgDisableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? OrgEnableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgEnableSamlAuditEntry"
        ? OrgEnableSamlAuditEntrySelector
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? OrgEnableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgInviteMemberAuditEntry"
        ? OrgInviteMemberAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? OrgRemoveBillingManagerAuditEntrySelector
        : F extends "OrgRemoveMemberAuditEntry"
        ? OrgRemoveMemberAuditEntrySelector
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? OrgRemoveOutsideCollaboratorAuditEntrySelector
        : F extends "OrgRestoreMemberAuditEntry"
        ? OrgRestoreMemberAuditEntrySelector
        : F extends "OrgUnblockUserAuditEntry"
        ? OrgUnblockUserAuditEntrySelector
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? OrgUpdateDefaultRepositoryPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberAuditEntry"
        ? OrgUpdateMemberAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "OrganizationIdentityProvider"
        ? OrganizationIdentityProviderSelector
        : F extends "OrganizationInvitation"
        ? OrganizationInvitationSelector
        : F extends "Package"
        ? PackageSelector
        : F extends "PackageFile"
        ? PackageFileSelector
        : F extends "PackageTag"
        ? PackageTagSelector
        : F extends "PackageVersion"
        ? PackageVersionSelector
        : F extends "PinnedEvent"
        ? PinnedEventSelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "Project"
        ? ProjectSelector
        : F extends "ProjectCard"
        ? ProjectCardSelector
        : F extends "ProjectColumn"
        ? ProjectColumnSelector
        : F extends "PublicKey"
        ? PublicKeySelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestCommit"
        ? PullRequestCommitSelector
        : F extends "PullRequestCommitCommentThread"
        ? PullRequestCommitCommentThreadSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "PullRequestReviewThread"
        ? PullRequestReviewThreadSelector
        : F extends "Push"
        ? PushSelector
        : F extends "PushAllowance"
        ? PushAllowanceSelector
        : F extends "Reaction"
        ? ReactionSelector
        : F extends "ReadyForReviewEvent"
        ? ReadyForReviewEventSelector
        : F extends "Ref"
        ? RefSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "Release"
        ? ReleaseSelector
        : F extends "ReleaseAsset"
        ? ReleaseAssetSelector
        : F extends "RemovedFromProjectEvent"
        ? RemovedFromProjectEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "RepositoryInvitation"
        ? RepositoryInvitationSelector
        : F extends "RepositoryTopic"
        ? RepositoryTopicSelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : F extends "RepositoryVulnerabilityAlert"
        ? RepositoryVulnerabilityAlertSelector
        : F extends "ReviewDismissalAllowance"
        ? ReviewDismissalAllowanceSelector
        : F extends "ReviewDismissedEvent"
        ? ReviewDismissedEventSelector
        : F extends "ReviewRequest"
        ? ReviewRequestSelector
        : F extends "ReviewRequestRemovedEvent"
        ? ReviewRequestRemovedEventSelector
        : F extends "ReviewRequestedEvent"
        ? ReviewRequestedEventSelector
        : F extends "SavedReply"
        ? SavedReplySelector
        : F extends "SecurityAdvisory"
        ? SecurityAdvisorySelector
        : F extends "SponsorsListing"
        ? SponsorsListingSelector
        : F extends "SponsorsTier"
        ? SponsorsTierSelector
        : F extends "Sponsorship"
        ? SponsorshipSelector
        : F extends "Status"
        ? StatusSelector
        : F extends "StatusCheckRollup"
        ? StatusCheckRollupSelector
        : F extends "StatusContext"
        ? StatusContextSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "Tag"
        ? TagSelector
        : F extends "Team"
        ? TeamSelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : F extends "Topic"
        ? TopicSelector
        : F extends "TransferredEvent"
        ? TransferredEventSelector
        : F extends "Tree"
        ? TreeSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnmarkedAsDuplicateEvent"
        ? UnmarkedAsDuplicateEventSelector
        : F extends "UnpinnedEvent"
        ? UnpinnedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "User"
        ? UserSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : F extends "UserContentEdit"
        ? UserContentEditSelector
        : F extends "UserStatus"
        ? UserStatusSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Node: NodeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description ID of the object.
   */
  id: () => new Field("id"),

  on: (type, select) => {
    switch (type) {
      case "AddedToProjectEvent": {
        return new InlineFragment(
          new NamedType("AddedToProjectEvent") as any,
          new SelectionSet(select(AddedToProjectEvent as any))
        );
      }

      case "App": {
        return new InlineFragment(
          new NamedType("App") as any,
          new SelectionSet(select(App as any))
        );
      }

      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "AutomaticBaseChangeFailedEvent": {
        return new InlineFragment(
          new NamedType("AutomaticBaseChangeFailedEvent") as any,
          new SelectionSet(select(AutomaticBaseChangeFailedEvent as any))
        );
      }

      case "AutomaticBaseChangeSucceededEvent": {
        return new InlineFragment(
          new NamedType("AutomaticBaseChangeSucceededEvent") as any,
          new SelectionSet(select(AutomaticBaseChangeSucceededEvent as any))
        );
      }

      case "BaseRefChangedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefChangedEvent") as any,
          new SelectionSet(select(BaseRefChangedEvent as any))
        );
      }

      case "BaseRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefDeletedEvent") as any,
          new SelectionSet(select(BaseRefDeletedEvent as any))
        );
      }

      case "BaseRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefForcePushedEvent") as any,
          new SelectionSet(select(BaseRefForcePushedEvent as any))
        );
      }

      case "Blob": {
        return new InlineFragment(
          new NamedType("Blob") as any,
          new SelectionSet(select(Blob as any))
        );
      }

      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "BranchProtectionRule": {
        return new InlineFragment(
          new NamedType("BranchProtectionRule") as any,
          new SelectionSet(select(BranchProtectionRule as any))
        );
      }

      case "CheckRun": {
        return new InlineFragment(
          new NamedType("CheckRun") as any,
          new SelectionSet(select(CheckRun as any))
        );
      }

      case "CheckSuite": {
        return new InlineFragment(
          new NamedType("CheckSuite") as any,
          new SelectionSet(select(CheckSuite as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "CodeOfConduct": {
        return new InlineFragment(
          new NamedType("CodeOfConduct") as any,
          new SelectionSet(select(CodeOfConduct as any))
        );
      }

      case "CommentDeletedEvent": {
        return new InlineFragment(
          new NamedType("CommentDeletedEvent") as any,
          new SelectionSet(select(CommentDeletedEvent as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "CommitCommentThread": {
        return new InlineFragment(
          new NamedType("CommitCommentThread") as any,
          new SelectionSet(select(CommitCommentThread as any))
        );
      }

      case "ConnectedEvent": {
        return new InlineFragment(
          new NamedType("ConnectedEvent") as any,
          new SelectionSet(select(ConnectedEvent as any))
        );
      }

      case "ConvertToDraftEvent": {
        return new InlineFragment(
          new NamedType("ConvertToDraftEvent") as any,
          new SelectionSet(select(ConvertToDraftEvent as any))
        );
      }

      case "ConvertedNoteToIssueEvent": {
        return new InlineFragment(
          new NamedType("ConvertedNoteToIssueEvent") as any,
          new SelectionSet(select(ConvertedNoteToIssueEvent as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "DeployKey": {
        return new InlineFragment(
          new NamedType("DeployKey") as any,
          new SelectionSet(select(DeployKey as any))
        );
      }

      case "DeployedEvent": {
        return new InlineFragment(
          new NamedType("DeployedEvent") as any,
          new SelectionSet(select(DeployedEvent as any))
        );
      }

      case "Deployment": {
        return new InlineFragment(
          new NamedType("Deployment") as any,
          new SelectionSet(select(Deployment as any))
        );
      }

      case "DeploymentEnvironmentChangedEvent": {
        return new InlineFragment(
          new NamedType("DeploymentEnvironmentChangedEvent") as any,
          new SelectionSet(select(DeploymentEnvironmentChangedEvent as any))
        );
      }

      case "DeploymentStatus": {
        return new InlineFragment(
          new NamedType("DeploymentStatus") as any,
          new SelectionSet(select(DeploymentStatus as any))
        );
      }

      case "DisconnectedEvent": {
        return new InlineFragment(
          new NamedType("DisconnectedEvent") as any,
          new SelectionSet(select(DisconnectedEvent as any))
        );
      }

      case "Enterprise": {
        return new InlineFragment(
          new NamedType("Enterprise") as any,
          new SelectionSet(select(Enterprise as any))
        );
      }

      case "EnterpriseAdministratorInvitation": {
        return new InlineFragment(
          new NamedType("EnterpriseAdministratorInvitation") as any,
          new SelectionSet(select(EnterpriseAdministratorInvitation as any))
        );
      }

      case "EnterpriseIdentityProvider": {
        return new InlineFragment(
          new NamedType("EnterpriseIdentityProvider") as any,
          new SelectionSet(select(EnterpriseIdentityProvider as any))
        );
      }

      case "EnterpriseRepositoryInfo": {
        return new InlineFragment(
          new NamedType("EnterpriseRepositoryInfo") as any,
          new SelectionSet(select(EnterpriseRepositoryInfo as any))
        );
      }

      case "EnterpriseServerInstallation": {
        return new InlineFragment(
          new NamedType("EnterpriseServerInstallation") as any,
          new SelectionSet(select(EnterpriseServerInstallation as any))
        );
      }

      case "EnterpriseServerUserAccount": {
        return new InlineFragment(
          new NamedType("EnterpriseServerUserAccount") as any,
          new SelectionSet(select(EnterpriseServerUserAccount as any))
        );
      }

      case "EnterpriseServerUserAccountEmail": {
        return new InlineFragment(
          new NamedType("EnterpriseServerUserAccountEmail") as any,
          new SelectionSet(select(EnterpriseServerUserAccountEmail as any))
        );
      }

      case "EnterpriseServerUserAccountsUpload": {
        return new InlineFragment(
          new NamedType("EnterpriseServerUserAccountsUpload") as any,
          new SelectionSet(select(EnterpriseServerUserAccountsUpload as any))
        );
      }

      case "EnterpriseUserAccount": {
        return new InlineFragment(
          new NamedType("EnterpriseUserAccount") as any,
          new SelectionSet(select(EnterpriseUserAccount as any))
        );
      }

      case "ExternalIdentity": {
        return new InlineFragment(
          new NamedType("ExternalIdentity") as any,
          new SelectionSet(select(ExternalIdentity as any))
        );
      }

      case "Gist": {
        return new InlineFragment(
          new NamedType("Gist") as any,
          new SelectionSet(select(Gist as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "HeadRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefDeletedEvent") as any,
          new SelectionSet(select(HeadRefDeletedEvent as any))
        );
      }

      case "HeadRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefForcePushedEvent") as any,
          new SelectionSet(select(HeadRefForcePushedEvent as any))
        );
      }

      case "HeadRefRestoredEvent": {
        return new InlineFragment(
          new NamedType("HeadRefRestoredEvent") as any,
          new SelectionSet(select(HeadRefRestoredEvent as any))
        );
      }

      case "IpAllowListEntry": {
        return new InlineFragment(
          new NamedType("IpAllowListEntry") as any,
          new SelectionSet(select(IpAllowListEntry as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "Label": {
        return new InlineFragment(
          new NamedType("Label") as any,
          new SelectionSet(select(Label as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "Language": {
        return new InlineFragment(
          new NamedType("Language") as any,
          new SelectionSet(select(Language as any))
        );
      }

      case "License": {
        return new InlineFragment(
          new NamedType("License") as any,
          new SelectionSet(select(License as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "MarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("MarkedAsDuplicateEvent") as any,
          new SelectionSet(select(MarkedAsDuplicateEvent as any))
        );
      }

      case "MarketplaceCategory": {
        return new InlineFragment(
          new NamedType("MarketplaceCategory") as any,
          new SelectionSet(select(MarketplaceCategory as any))
        );
      }

      case "MarketplaceListing": {
        return new InlineFragment(
          new NamedType("MarketplaceListing") as any,
          new SelectionSet(select(MarketplaceListing as any))
        );
      }

      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "MentionedEvent": {
        return new InlineFragment(
          new NamedType("MentionedEvent") as any,
          new SelectionSet(select(MentionedEvent as any))
        );
      }

      case "MergedEvent": {
        return new InlineFragment(
          new NamedType("MergedEvent") as any,
          new SelectionSet(select(MergedEvent as any))
        );
      }

      case "Milestone": {
        return new InlineFragment(
          new NamedType("Milestone") as any,
          new SelectionSet(select(Milestone as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "MovedColumnsInProjectEvent": {
        return new InlineFragment(
          new NamedType("MovedColumnsInProjectEvent") as any,
          new SelectionSet(select(MovedColumnsInProjectEvent as any))
        );
      }

      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgAddBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgAddBillingManagerAuditEntry as any))
        );
      }

      case "OrgAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddMemberAuditEntry") as any,
          new SelectionSet(select(OrgAddMemberAuditEntry as any))
        );
      }

      case "OrgBlockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgBlockUserAuditEntry") as any,
          new SelectionSet(select(OrgBlockUserAuditEntry as any))
        );
      }

      case "OrgConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgCreateAuditEntry") as any,
          new SelectionSet(select(OrgCreateAuditEntry as any))
        );
      }

      case "OrgDisableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgDisableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableSamlAuditEntry") as any,
          new SelectionSet(select(OrgDisableSamlAuditEntry as any))
        );
      }

      case "OrgDisableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgEnableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgEnableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableSamlAuditEntry") as any,
          new SelectionSet(select(OrgEnableSamlAuditEntry as any))
        );
      }

      case "OrgEnableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgInviteMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteMemberAuditEntry") as any,
          new SelectionSet(select(OrgInviteMemberAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      case "OrgRemoveBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgRemoveBillingManagerAuditEntry as any))
        );
      }

      case "OrgRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveMemberAuditEntry") as any,
          new SelectionSet(select(OrgRemoveMemberAuditEntry as any))
        );
      }

      case "OrgRemoveOutsideCollaboratorAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveOutsideCollaboratorAuditEntry") as any,
          new SelectionSet(
            select(OrgRemoveOutsideCollaboratorAuditEntry as any)
          )
        );
      }

      case "OrgRestoreMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberAuditEntry") as any,
          new SelectionSet(select(OrgRestoreMemberAuditEntry as any))
        );
      }

      case "OrgUnblockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUnblockUserAuditEntry") as any,
          new SelectionSet(select(OrgUnblockUserAuditEntry as any))
        );
      }

      case "OrgUpdateDefaultRepositoryPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateDefaultRepositoryPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateDefaultRepositoryPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUpdateMemberAuditEntry") as any,
          new SelectionSet(select(OrgUpdateMemberAuditEntry as any))
        );
      }

      case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateMemberRepositoryCreationPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(
              OrgUpdateMemberRepositoryInvitationPermissionAuditEntry as any
            )
          )
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "OrganizationIdentityProvider": {
        return new InlineFragment(
          new NamedType("OrganizationIdentityProvider") as any,
          new SelectionSet(select(OrganizationIdentityProvider as any))
        );
      }

      case "OrganizationInvitation": {
        return new InlineFragment(
          new NamedType("OrganizationInvitation") as any,
          new SelectionSet(select(OrganizationInvitation as any))
        );
      }

      case "Package": {
        return new InlineFragment(
          new NamedType("Package") as any,
          new SelectionSet(select(Package as any))
        );
      }

      case "PackageFile": {
        return new InlineFragment(
          new NamedType("PackageFile") as any,
          new SelectionSet(select(PackageFile as any))
        );
      }

      case "PackageTag": {
        return new InlineFragment(
          new NamedType("PackageTag") as any,
          new SelectionSet(select(PackageTag as any))
        );
      }

      case "PackageVersion": {
        return new InlineFragment(
          new NamedType("PackageVersion") as any,
          new SelectionSet(select(PackageVersion as any))
        );
      }

      case "PinnedEvent": {
        return new InlineFragment(
          new NamedType("PinnedEvent") as any,
          new SelectionSet(select(PinnedEvent as any))
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "Project": {
        return new InlineFragment(
          new NamedType("Project") as any,
          new SelectionSet(select(Project as any))
        );
      }

      case "ProjectCard": {
        return new InlineFragment(
          new NamedType("ProjectCard") as any,
          new SelectionSet(select(ProjectCard as any))
        );
      }

      case "ProjectColumn": {
        return new InlineFragment(
          new NamedType("ProjectColumn") as any,
          new SelectionSet(select(ProjectColumn as any))
        );
      }

      case "PublicKey": {
        return new InlineFragment(
          new NamedType("PublicKey") as any,
          new SelectionSet(select(PublicKey as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestCommit": {
        return new InlineFragment(
          new NamedType("PullRequestCommit") as any,
          new SelectionSet(select(PullRequestCommit as any))
        );
      }

      case "PullRequestCommitCommentThread": {
        return new InlineFragment(
          new NamedType("PullRequestCommitCommentThread") as any,
          new SelectionSet(select(PullRequestCommitCommentThread as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "PullRequestReviewThread": {
        return new InlineFragment(
          new NamedType("PullRequestReviewThread") as any,
          new SelectionSet(select(PullRequestReviewThread as any))
        );
      }

      case "Push": {
        return new InlineFragment(
          new NamedType("Push") as any,
          new SelectionSet(select(Push as any))
        );
      }

      case "PushAllowance": {
        return new InlineFragment(
          new NamedType("PushAllowance") as any,
          new SelectionSet(select(PushAllowance as any))
        );
      }

      case "Reaction": {
        return new InlineFragment(
          new NamedType("Reaction") as any,
          new SelectionSet(select(Reaction as any))
        );
      }

      case "ReadyForReviewEvent": {
        return new InlineFragment(
          new NamedType("ReadyForReviewEvent") as any,
          new SelectionSet(select(ReadyForReviewEvent as any))
        );
      }

      case "Ref": {
        return new InlineFragment(
          new NamedType("Ref") as any,
          new SelectionSet(select(Ref as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "Release": {
        return new InlineFragment(
          new NamedType("Release") as any,
          new SelectionSet(select(Release as any))
        );
      }

      case "ReleaseAsset": {
        return new InlineFragment(
          new NamedType("ReleaseAsset") as any,
          new SelectionSet(select(ReleaseAsset as any))
        );
      }

      case "RemovedFromProjectEvent": {
        return new InlineFragment(
          new NamedType("RemovedFromProjectEvent") as any,
          new SelectionSet(select(RemovedFromProjectEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "RepositoryInvitation": {
        return new InlineFragment(
          new NamedType("RepositoryInvitation") as any,
          new SelectionSet(select(RepositoryInvitation as any))
        );
      }

      case "RepositoryTopic": {
        return new InlineFragment(
          new NamedType("RepositoryTopic") as any,
          new SelectionSet(select(RepositoryTopic as any))
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      case "RepositoryVulnerabilityAlert": {
        return new InlineFragment(
          new NamedType("RepositoryVulnerabilityAlert") as any,
          new SelectionSet(select(RepositoryVulnerabilityAlert as any))
        );
      }

      case "ReviewDismissalAllowance": {
        return new InlineFragment(
          new NamedType("ReviewDismissalAllowance") as any,
          new SelectionSet(select(ReviewDismissalAllowance as any))
        );
      }

      case "ReviewDismissedEvent": {
        return new InlineFragment(
          new NamedType("ReviewDismissedEvent") as any,
          new SelectionSet(select(ReviewDismissedEvent as any))
        );
      }

      case "ReviewRequest": {
        return new InlineFragment(
          new NamedType("ReviewRequest") as any,
          new SelectionSet(select(ReviewRequest as any))
        );
      }

      case "ReviewRequestRemovedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestRemovedEvent") as any,
          new SelectionSet(select(ReviewRequestRemovedEvent as any))
        );
      }

      case "ReviewRequestedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestedEvent") as any,
          new SelectionSet(select(ReviewRequestedEvent as any))
        );
      }

      case "SavedReply": {
        return new InlineFragment(
          new NamedType("SavedReply") as any,
          new SelectionSet(select(SavedReply as any))
        );
      }

      case "SecurityAdvisory": {
        return new InlineFragment(
          new NamedType("SecurityAdvisory") as any,
          new SelectionSet(select(SecurityAdvisory as any))
        );
      }

      case "SponsorsListing": {
        return new InlineFragment(
          new NamedType("SponsorsListing") as any,
          new SelectionSet(select(SponsorsListing as any))
        );
      }

      case "SponsorsTier": {
        return new InlineFragment(
          new NamedType("SponsorsTier") as any,
          new SelectionSet(select(SponsorsTier as any))
        );
      }

      case "Sponsorship": {
        return new InlineFragment(
          new NamedType("Sponsorship") as any,
          new SelectionSet(select(Sponsorship as any))
        );
      }

      case "Status": {
        return new InlineFragment(
          new NamedType("Status") as any,
          new SelectionSet(select(Status as any))
        );
      }

      case "StatusCheckRollup": {
        return new InlineFragment(
          new NamedType("StatusCheckRollup") as any,
          new SelectionSet(select(StatusCheckRollup as any))
        );
      }

      case "StatusContext": {
        return new InlineFragment(
          new NamedType("StatusContext") as any,
          new SelectionSet(select(StatusContext as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "Tag": {
        return new InlineFragment(
          new NamedType("Tag") as any,
          new SelectionSet(select(Tag as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      case "Topic": {
        return new InlineFragment(
          new NamedType("Topic") as any,
          new SelectionSet(select(Topic as any))
        );
      }

      case "TransferredEvent": {
        return new InlineFragment(
          new NamedType("TransferredEvent") as any,
          new SelectionSet(select(TransferredEvent as any))
        );
      }

      case "Tree": {
        return new InlineFragment(
          new NamedType("Tree") as any,
          new SelectionSet(select(Tree as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnmarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("UnmarkedAsDuplicateEvent") as any,
          new SelectionSet(select(UnmarkedAsDuplicateEvent as any))
        );
      }

      case "UnpinnedEvent": {
        return new InlineFragment(
          new NamedType("UnpinnedEvent") as any,
          new SelectionSet(select(UnpinnedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      case "UserContentEdit": {
        return new InlineFragment(
          new NamedType("UserContentEdit") as any,
          new SelectionSet(select(UserContentEdit as any))
        );
      }

      case "UserStatus": {
        return new InlineFragment(
          new NamedType("UserStatus") as any,
          new SelectionSet(select(UserStatus as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Node",
        });
    }
  },
};

export interface IOauthApplicationAuditEntryData {
  readonly __typename: string;
  readonly oauthApplicationName: string | null;
  readonly oauthApplicationResourcePath: unknown | null;
  readonly oauthApplicationUrl: unknown | null;
}

interface OauthApplicationAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The name of the OAuth Application.
   */

  readonly oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  readonly oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  readonly oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "OauthApplicationCreateAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const OauthApplicationAuditEntryData: OauthApplicationAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  on: (type, select) => {
    switch (type) {
      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "OauthApplicationAuditEntryData",
        });
    }
  },
};

export interface IOauthApplicationCreateAuditEntry
  extends IAuditEntry,
    INode,
    IOauthApplicationAuditEntryData,
    IOrganizationAuditEntryData {
  readonly __typename: "OauthApplicationCreateAuditEntry";
  readonly applicationUrl: unknown | null;
  readonly callbackUrl: unknown | null;
  readonly rateLimit: number | null;
  readonly state: OauthApplicationCreateAuditEntryState | null;
}

interface OauthApplicationCreateAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The application URL of the OAuth Application.
   */

  readonly applicationUrl: () => Field<"applicationUrl">;

  /**
   * @description The callback URL of the OAuth Application.
   */

  readonly callbackUrl: () => Field<"callbackUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The name of the OAuth Application.
   */

  readonly oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  readonly oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  readonly oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The rate limit of the OAuth Application.
   */

  readonly rateLimit: () => Field<"rateLimit">;

  /**
   * @description The state of the OAuth Application.
   */

  readonly state: () => Field<"state">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOauthApplicationCreateAuditEntry = (
  object: Record<string, any>
): object is Partial<IOauthApplicationCreateAuditEntry> => {
  return object.__typename === "OauthApplicationCreateAuditEntry";
};

export const OauthApplicationCreateAuditEntry: OauthApplicationCreateAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The application URL of the OAuth Application.
   */
  applicationUrl: () => new Field("applicationUrl"),

  /**
   * @description The callback URL of the OAuth Application.
   */
  callbackUrl: () => new Field("callbackUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The rate limit of the OAuth Application.
   */
  rateLimit: () => new Field("rateLimit"),

  /**
   * @description The state of the OAuth Application.
   */
  state: () => new Field("state"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgAddBillingManagerAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgAddBillingManagerAuditEntry";
  readonly invitationEmail: string | null;
}

interface OrgAddBillingManagerAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The email address used to invite a billing manager for the organization.
   */

  readonly invitationEmail: () => Field<"invitationEmail">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgAddBillingManagerAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgAddBillingManagerAuditEntry> => {
  return object.__typename === "OrgAddBillingManagerAuditEntry";
};

export const OrgAddBillingManagerAuditEntry: OrgAddBillingManagerAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The email address used to invite a billing manager for the organization.
   */
  invitationEmail: () => new Field("invitationEmail"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgAddMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgAddMemberAuditEntry";
  readonly permission: OrgAddMemberAuditEntryPermission | null;
}

interface OrgAddMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The permission level of the member added to the organization.
   */

  readonly permission: () => Field<"permission">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgAddMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgAddMemberAuditEntry> => {
  return object.__typename === "OrgAddMemberAuditEntry";
};

export const OrgAddMemberAuditEntry: OrgAddMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The permission level of the member added to the organization.
   */
  permission: () => new Field("permission"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgBlockUserAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgBlockUserAuditEntry";
  readonly blockedUser: IUser | null;
  readonly blockedUserName: string | null;
  readonly blockedUserResourcePath: unknown | null;
  readonly blockedUserUrl: unknown | null;
}

interface OrgBlockUserAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The blocked user.
   */

  readonly blockedUser: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"blockedUser", never, SelectionSet<T>>;

  /**
   * @description The username of the blocked user.
   */

  readonly blockedUserName: () => Field<"blockedUserName">;

  /**
   * @description The HTTP path for the blocked user.
   */

  readonly blockedUserResourcePath: () => Field<"blockedUserResourcePath">;

  /**
   * @description The HTTP URL for the blocked user.
   */

  readonly blockedUserUrl: () => Field<"blockedUserUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgBlockUserAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgBlockUserAuditEntry> => {
  return object.__typename === "OrgBlockUserAuditEntry";
};

export const OrgBlockUserAuditEntry: OrgBlockUserAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The blocked user.
   */

  blockedUser: (select) =>
    new Field(
      "blockedUser",
      undefined as never,
      new SelectionSet(select(User))
    ),

  /**
   * @description The username of the blocked user.
   */
  blockedUserName: () => new Field("blockedUserName"),

  /**
   * @description The HTTP path for the blocked user.
   */
  blockedUserResourcePath: () => new Field("blockedUserResourcePath"),

  /**
   * @description The HTTP URL for the blocked user.
   */
  blockedUserUrl: () => new Field("blockedUserUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgConfigDisableCollaboratorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgConfigDisableCollaboratorsOnlyAuditEntry";
}

interface OrgConfigDisableCollaboratorsOnlyAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgConfigDisableCollaboratorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgConfigDisableCollaboratorsOnlyAuditEntry> => {
  return object.__typename === "OrgConfigDisableCollaboratorsOnlyAuditEntry";
};

export const OrgConfigDisableCollaboratorsOnlyAuditEntry: OrgConfigDisableCollaboratorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgConfigEnableCollaboratorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgConfigEnableCollaboratorsOnlyAuditEntry";
}

interface OrgConfigEnableCollaboratorsOnlyAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgConfigEnableCollaboratorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgConfigEnableCollaboratorsOnlyAuditEntry> => {
  return object.__typename === "OrgConfigEnableCollaboratorsOnlyAuditEntry";
};

export const OrgConfigEnableCollaboratorsOnlyAuditEntry: OrgConfigEnableCollaboratorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgCreateAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgCreateAuditEntry";
  readonly billingPlan: OrgCreateAuditEntryBillingPlan | null;
}

interface OrgCreateAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The billing plan for the Organization.
   */

  readonly billingPlan: () => Field<"billingPlan">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgCreateAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgCreateAuditEntry> => {
  return object.__typename === "OrgCreateAuditEntry";
};

export const OrgCreateAuditEntry: OrgCreateAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The billing plan for the Organization.
   */
  billingPlan: () => new Field("billingPlan"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgDisableOauthAppRestrictionsAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgDisableOauthAppRestrictionsAuditEntry";
}

interface OrgDisableOauthAppRestrictionsAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgDisableOauthAppRestrictionsAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgDisableOauthAppRestrictionsAuditEntry> => {
  return object.__typename === "OrgDisableOauthAppRestrictionsAuditEntry";
};

export const OrgDisableOauthAppRestrictionsAuditEntry: OrgDisableOauthAppRestrictionsAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgDisableSamlAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgDisableSamlAuditEntry";
  readonly digestMethodUrl: unknown | null;
  readonly issuerUrl: unknown | null;
  readonly signatureMethodUrl: unknown | null;
  readonly singleSignOnUrl: unknown | null;
}

interface OrgDisableSamlAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The SAML provider's digest algorithm URL.
   */

  readonly digestMethodUrl: () => Field<"digestMethodUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The SAML provider's issuer URL.
   */

  readonly issuerUrl: () => Field<"issuerUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The SAML provider's signature algorithm URL.
   */

  readonly signatureMethodUrl: () => Field<"signatureMethodUrl">;

  /**
   * @description The SAML provider's single sign-on URL.
   */

  readonly singleSignOnUrl: () => Field<"singleSignOnUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgDisableSamlAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgDisableSamlAuditEntry> => {
  return object.__typename === "OrgDisableSamlAuditEntry";
};

export const OrgDisableSamlAuditEntry: OrgDisableSamlAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The SAML provider's digest algorithm URL.
   */
  digestMethodUrl: () => new Field("digestMethodUrl"),
  id: () => new Field("id"),

  /**
   * @description The SAML provider's issuer URL.
   */
  issuerUrl: () => new Field("issuerUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The SAML provider's signature algorithm URL.
   */
  signatureMethodUrl: () => new Field("signatureMethodUrl"),

  /**
   * @description The SAML provider's single sign-on URL.
   */
  singleSignOnUrl: () => new Field("singleSignOnUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgDisableTwoFactorRequirementAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgDisableTwoFactorRequirementAuditEntry";
}

interface OrgDisableTwoFactorRequirementAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgDisableTwoFactorRequirementAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgDisableTwoFactorRequirementAuditEntry> => {
  return object.__typename === "OrgDisableTwoFactorRequirementAuditEntry";
};

export const OrgDisableTwoFactorRequirementAuditEntry: OrgDisableTwoFactorRequirementAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgEnableOauthAppRestrictionsAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgEnableOauthAppRestrictionsAuditEntry";
}

interface OrgEnableOauthAppRestrictionsAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgEnableOauthAppRestrictionsAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgEnableOauthAppRestrictionsAuditEntry> => {
  return object.__typename === "OrgEnableOauthAppRestrictionsAuditEntry";
};

export const OrgEnableOauthAppRestrictionsAuditEntry: OrgEnableOauthAppRestrictionsAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgEnableSamlAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgEnableSamlAuditEntry";
  readonly digestMethodUrl: unknown | null;
  readonly issuerUrl: unknown | null;
  readonly signatureMethodUrl: unknown | null;
  readonly singleSignOnUrl: unknown | null;
}

interface OrgEnableSamlAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The SAML provider's digest algorithm URL.
   */

  readonly digestMethodUrl: () => Field<"digestMethodUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The SAML provider's issuer URL.
   */

  readonly issuerUrl: () => Field<"issuerUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The SAML provider's signature algorithm URL.
   */

  readonly signatureMethodUrl: () => Field<"signatureMethodUrl">;

  /**
   * @description The SAML provider's single sign-on URL.
   */

  readonly singleSignOnUrl: () => Field<"singleSignOnUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgEnableSamlAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgEnableSamlAuditEntry> => {
  return object.__typename === "OrgEnableSamlAuditEntry";
};

export const OrgEnableSamlAuditEntry: OrgEnableSamlAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The SAML provider's digest algorithm URL.
   */
  digestMethodUrl: () => new Field("digestMethodUrl"),
  id: () => new Field("id"),

  /**
   * @description The SAML provider's issuer URL.
   */
  issuerUrl: () => new Field("issuerUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The SAML provider's signature algorithm URL.
   */
  signatureMethodUrl: () => new Field("signatureMethodUrl"),

  /**
   * @description The SAML provider's single sign-on URL.
   */
  singleSignOnUrl: () => new Field("singleSignOnUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgEnableTwoFactorRequirementAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgEnableTwoFactorRequirementAuditEntry";
}

interface OrgEnableTwoFactorRequirementAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgEnableTwoFactorRequirementAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgEnableTwoFactorRequirementAuditEntry> => {
  return object.__typename === "OrgEnableTwoFactorRequirementAuditEntry";
};

export const OrgEnableTwoFactorRequirementAuditEntry: OrgEnableTwoFactorRequirementAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgInviteMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgInviteMemberAuditEntry";
  readonly email: string | null;
  readonly organizationInvitation: IOrganizationInvitation | null;
}

interface OrgInviteMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The email address of the organization invitation.
   */

  readonly email: () => Field<"email">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The organization invitation.
   */

  readonly organizationInvitation: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"organizationInvitation", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgInviteMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgInviteMemberAuditEntry> => {
  return object.__typename === "OrgInviteMemberAuditEntry";
};

export const OrgInviteMemberAuditEntry: OrgInviteMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The email address of the organization invitation.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The organization invitation.
   */

  organizationInvitation: (select) =>
    new Field(
      "organizationInvitation",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgInviteToBusinessAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgInviteToBusinessAuditEntry";
}

interface OrgInviteToBusinessAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgInviteToBusinessAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgInviteToBusinessAuditEntry> => {
  return object.__typename === "OrgInviteToBusinessAuditEntry";
};

export const OrgInviteToBusinessAuditEntry: OrgInviteToBusinessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgOauthAppAccessApprovedAuditEntry
  extends IAuditEntry,
    INode,
    IOauthApplicationAuditEntryData,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgOauthAppAccessApprovedAuditEntry";
}

interface OrgOauthAppAccessApprovedAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The name of the OAuth Application.
   */

  readonly oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  readonly oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  readonly oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgOauthAppAccessApprovedAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgOauthAppAccessApprovedAuditEntry> => {
  return object.__typename === "OrgOauthAppAccessApprovedAuditEntry";
};

export const OrgOauthAppAccessApprovedAuditEntry: OrgOauthAppAccessApprovedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgOauthAppAccessDeniedAuditEntry
  extends IAuditEntry,
    INode,
    IOauthApplicationAuditEntryData,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgOauthAppAccessDeniedAuditEntry";
}

interface OrgOauthAppAccessDeniedAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The name of the OAuth Application.
   */

  readonly oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  readonly oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  readonly oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgOauthAppAccessDeniedAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgOauthAppAccessDeniedAuditEntry> => {
  return object.__typename === "OrgOauthAppAccessDeniedAuditEntry";
};

export const OrgOauthAppAccessDeniedAuditEntry: OrgOauthAppAccessDeniedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgOauthAppAccessRequestedAuditEntry
  extends IAuditEntry,
    INode,
    IOauthApplicationAuditEntryData,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgOauthAppAccessRequestedAuditEntry";
}

interface OrgOauthAppAccessRequestedAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The name of the OAuth Application.
   */

  readonly oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  readonly oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  readonly oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgOauthAppAccessRequestedAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgOauthAppAccessRequestedAuditEntry> => {
  return object.__typename === "OrgOauthAppAccessRequestedAuditEntry";
};

export const OrgOauthAppAccessRequestedAuditEntry: OrgOauthAppAccessRequestedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRemoveBillingManagerAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgRemoveBillingManagerAuditEntry";
  readonly reason: OrgRemoveBillingManagerAuditEntryReason | null;
}

interface OrgRemoveBillingManagerAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The reason for the billing manager being removed.
   */

  readonly reason: () => Field<"reason">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgRemoveBillingManagerAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgRemoveBillingManagerAuditEntry> => {
  return object.__typename === "OrgRemoveBillingManagerAuditEntry";
};

export const OrgRemoveBillingManagerAuditEntry: OrgRemoveBillingManagerAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The reason for the billing manager being removed.
   */
  reason: () => new Field("reason"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRemoveMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgRemoveMemberAuditEntry";
  readonly membershipTypes: ReadonlyArray<OrgRemoveMemberAuditEntryMembershipType> | null;
  readonly reason: OrgRemoveMemberAuditEntryReason | null;
}

interface OrgRemoveMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The types of membership the member has with the organization.
   */

  readonly membershipTypes: () => Field<"membershipTypes">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The reason for the member being removed.
   */

  readonly reason: () => Field<"reason">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgRemoveMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgRemoveMemberAuditEntry> => {
  return object.__typename === "OrgRemoveMemberAuditEntry";
};

export const OrgRemoveMemberAuditEntry: OrgRemoveMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The types of membership the member has with the organization.
   */
  membershipTypes: () => new Field("membershipTypes"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The reason for the member being removed.
   */
  reason: () => new Field("reason"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRemoveOutsideCollaboratorAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgRemoveOutsideCollaboratorAuditEntry";
  readonly membershipTypes: ReadonlyArray<OrgRemoveOutsideCollaboratorAuditEntryMembershipType> | null;
  readonly reason: OrgRemoveOutsideCollaboratorAuditEntryReason | null;
}

interface OrgRemoveOutsideCollaboratorAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The types of membership the outside collaborator has with the organization.
   */

  readonly membershipTypes: () => Field<"membershipTypes">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The reason for the outside collaborator being removed from the Organization.
   */

  readonly reason: () => Field<"reason">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgRemoveOutsideCollaboratorAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgRemoveOutsideCollaboratorAuditEntry> => {
  return object.__typename === "OrgRemoveOutsideCollaboratorAuditEntry";
};

export const OrgRemoveOutsideCollaboratorAuditEntry: OrgRemoveOutsideCollaboratorAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The types of membership the outside collaborator has with the organization.
   */
  membershipTypes: () => new Field("membershipTypes"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The reason for the outside collaborator being removed from the Organization.
   */
  reason: () => new Field("reason"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRestoreMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgRestoreMemberAuditEntry";
  readonly restoredCustomEmailRoutingsCount: number | null;
  readonly restoredIssueAssignmentsCount: number | null;
  readonly restoredMemberships: ReadonlyArray<IOrgRestoreMemberAuditEntryMembership> | null;
  readonly restoredMembershipsCount: number | null;
  readonly restoredRepositoriesCount: number | null;
  readonly restoredRepositoryStarsCount: number | null;
  readonly restoredRepositoryWatchesCount: number | null;
}

interface OrgRestoreMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The number of custom email routings for the restored member.
   */

  readonly restoredCustomEmailRoutingsCount: () => Field<"restoredCustomEmailRoutingsCount">;

  /**
   * @description The number of issue assignemnts for the restored member.
   */

  readonly restoredIssueAssignmentsCount: () => Field<"restoredIssueAssignmentsCount">;

  /**
   * @description Restored organization membership objects.
   */

  readonly restoredMemberships: <T extends Array<Selection>>(
    select: (t: OrgRestoreMemberAuditEntryMembershipSelector) => T
  ) => Field<"restoredMemberships", never, SelectionSet<T>>;

  /**
   * @description The number of restored memberships.
   */

  readonly restoredMembershipsCount: () => Field<"restoredMembershipsCount">;

  /**
   * @description The number of repositories of the restored member.
   */

  readonly restoredRepositoriesCount: () => Field<"restoredRepositoriesCount">;

  /**
   * @description The number of starred repositories for the restored member.
   */

  readonly restoredRepositoryStarsCount: () => Field<"restoredRepositoryStarsCount">;

  /**
   * @description The number of watched repositories for the restored member.
   */

  readonly restoredRepositoryWatchesCount: () => Field<"restoredRepositoryWatchesCount">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgRestoreMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberAuditEntry> => {
  return object.__typename === "OrgRestoreMemberAuditEntry";
};

export const OrgRestoreMemberAuditEntry: OrgRestoreMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The number of custom email routings for the restored member.
   */
  restoredCustomEmailRoutingsCount: () =>
    new Field("restoredCustomEmailRoutingsCount"),

  /**
   * @description The number of issue assignemnts for the restored member.
   */
  restoredIssueAssignmentsCount: () =>
    new Field("restoredIssueAssignmentsCount"),

  /**
   * @description Restored organization membership objects.
   */

  restoredMemberships: (select) =>
    new Field(
      "restoredMemberships",
      undefined as never,
      new SelectionSet(select(OrgRestoreMemberAuditEntryMembership))
    ),

  /**
   * @description The number of restored memberships.
   */
  restoredMembershipsCount: () => new Field("restoredMembershipsCount"),

  /**
   * @description The number of repositories of the restored member.
   */
  restoredRepositoriesCount: () => new Field("restoredRepositoriesCount"),

  /**
   * @description The number of starred repositories for the restored member.
   */
  restoredRepositoryStarsCount: () => new Field("restoredRepositoryStarsCount"),

  /**
   * @description The number of watched repositories for the restored member.
   */
  restoredRepositoryWatchesCount: () =>
    new Field("restoredRepositoryWatchesCount"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRestoreMemberMembershipOrganizationAuditEntryData
  extends IOrganizationAuditEntryData {
  readonly __typename: "OrgRestoreMemberMembershipOrganizationAuditEntryData";
}

interface OrgRestoreMemberMembershipOrganizationAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;
}

export const isOrgRestoreMemberMembershipOrganizationAuditEntryData = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberMembershipOrganizationAuditEntryData> => {
  return (
    object.__typename === "OrgRestoreMemberMembershipOrganizationAuditEntryData"
  );
};

export const OrgRestoreMemberMembershipOrganizationAuditEntryData: OrgRestoreMemberMembershipOrganizationAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),
};

export interface IOrgRestoreMemberMembershipRepositoryAuditEntryData
  extends IRepositoryAuditEntryData {
  readonly __typename: "OrgRestoreMemberMembershipRepositoryAuditEntryData";
}

interface OrgRestoreMemberMembershipRepositoryAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;
}

export const isOrgRestoreMemberMembershipRepositoryAuditEntryData = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberMembershipRepositoryAuditEntryData> => {
  return (
    object.__typename === "OrgRestoreMemberMembershipRepositoryAuditEntryData"
  );
};

export const OrgRestoreMemberMembershipRepositoryAuditEntryData: OrgRestoreMemberMembershipRepositoryAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),
};

export interface IOrgRestoreMemberMembershipTeamAuditEntryData
  extends ITeamAuditEntryData {
  readonly __typename: "OrgRestoreMemberMembershipTeamAuditEntryData";
}

interface OrgRestoreMemberMembershipTeamAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The team associated with the action
   */

  readonly team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  readonly teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  readonly teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  readonly teamUrl: () => Field<"teamUrl">;
}

export const isOrgRestoreMemberMembershipTeamAuditEntryData = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberMembershipTeamAuditEntryData> => {
  return object.__typename === "OrgRestoreMemberMembershipTeamAuditEntryData";
};

export const OrgRestoreMemberMembershipTeamAuditEntryData: OrgRestoreMemberMembershipTeamAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),
};

export interface IOrgUnblockUserAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgUnblockUserAuditEntry";
  readonly blockedUser: IUser | null;
  readonly blockedUserName: string | null;
  readonly blockedUserResourcePath: unknown | null;
  readonly blockedUserUrl: unknown | null;
}

interface OrgUnblockUserAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The user being unblocked by the organization.
   */

  readonly blockedUser: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"blockedUser", never, SelectionSet<T>>;

  /**
   * @description The username of the blocked user.
   */

  readonly blockedUserName: () => Field<"blockedUserName">;

  /**
   * @description The HTTP path for the blocked user.
   */

  readonly blockedUserResourcePath: () => Field<"blockedUserResourcePath">;

  /**
   * @description The HTTP URL for the blocked user.
   */

  readonly blockedUserUrl: () => Field<"blockedUserUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgUnblockUserAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUnblockUserAuditEntry> => {
  return object.__typename === "OrgUnblockUserAuditEntry";
};

export const OrgUnblockUserAuditEntry: OrgUnblockUserAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The user being unblocked by the organization.
   */

  blockedUser: (select) =>
    new Field(
      "blockedUser",
      undefined as never,
      new SelectionSet(select(User))
    ),

  /**
   * @description The username of the blocked user.
   */
  blockedUserName: () => new Field("blockedUserName"),

  /**
   * @description The HTTP path for the blocked user.
   */
  blockedUserResourcePath: () => new Field("blockedUserResourcePath"),

  /**
   * @description The HTTP URL for the blocked user.
   */
  blockedUserUrl: () => new Field("blockedUserUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgUpdateDefaultRepositoryPermissionAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgUpdateDefaultRepositoryPermissionAuditEntry";
  readonly permission: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission | null;
  readonly permissionWas: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission | null;
}

interface OrgUpdateDefaultRepositoryPermissionAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The new default repository permission level for the organization.
   */

  readonly permission: () => Field<"permission">;

  /**
   * @description The former default repository permission level for the organization.
   */

  readonly permissionWas: () => Field<"permissionWas">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgUpdateDefaultRepositoryPermissionAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUpdateDefaultRepositoryPermissionAuditEntry> => {
  return object.__typename === "OrgUpdateDefaultRepositoryPermissionAuditEntry";
};

export const OrgUpdateDefaultRepositoryPermissionAuditEntry: OrgUpdateDefaultRepositoryPermissionAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The new default repository permission level for the organization.
   */
  permission: () => new Field("permission"),

  /**
   * @description The former default repository permission level for the organization.
   */
  permissionWas: () => new Field("permissionWas"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgUpdateMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgUpdateMemberAuditEntry";
  readonly permission: OrgUpdateMemberAuditEntryPermission | null;
  readonly permissionWas: OrgUpdateMemberAuditEntryPermission | null;
}

interface OrgUpdateMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The new member permission level for the organization.
   */

  readonly permission: () => Field<"permission">;

  /**
   * @description The former member permission level for the organization.
   */

  readonly permissionWas: () => Field<"permissionWas">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgUpdateMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUpdateMemberAuditEntry> => {
  return object.__typename === "OrgUpdateMemberAuditEntry";
};

export const OrgUpdateMemberAuditEntry: OrgUpdateMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The new member permission level for the organization.
   */
  permission: () => new Field("permission"),

  /**
   * @description The former member permission level for the organization.
   */
  permissionWas: () => new Field("permissionWas"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgUpdateMemberRepositoryCreationPermissionAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgUpdateMemberRepositoryCreationPermissionAuditEntry";
  readonly canCreateRepositories: boolean | null;
  readonly visibility: OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility | null;
}

interface OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description Can members create repositories in the organization.
   */

  readonly canCreateRepositories: () => Field<"canCreateRepositories">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;

  /**
   * @description The permission for visibility level of repositories for this organization.
   */

  readonly visibility: () => Field<"visibility">;
}

export const isOrgUpdateMemberRepositoryCreationPermissionAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUpdateMemberRepositoryCreationPermissionAuditEntry> => {
  return (
    object.__typename ===
    "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
  );
};

export const OrgUpdateMemberRepositoryCreationPermissionAuditEntry: OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description Can members create repositories in the organization.
   */
  canCreateRepositories: () => new Field("canCreateRepositories"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The permission for visibility level of repositories for this organization.
   */
  visibility: () => new Field("visibility"),
};

export interface IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry";
  readonly canInviteOutsideCollaboratorsToRepositories: boolean | null;
}

interface OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description Can outside collaborators be invited to repositories in the organization.
   */

  readonly canInviteOutsideCollaboratorsToRepositories: () => Field<"canInviteOutsideCollaboratorsToRepositories">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isOrgUpdateMemberRepositoryInvitationPermissionAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry> => {
  return (
    object.__typename ===
    "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
  );
};

export const OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description Can outside collaborators be invited to repositories in the organization.
   */
  canInviteOutsideCollaboratorsToRepositories: () =>
    new Field("canInviteOutsideCollaboratorsToRepositories"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrganization
  extends IActor,
    IMemberStatusable,
    INode,
    IPackageOwner,
    IProfileOwner,
    IProjectOwner,
    IRepositoryOwner,
    ISponsorable,
    IUniformResourceLocatable {
  readonly __typename: "Organization";
  readonly auditLog: IOrganizationAuditEntryConnection;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly description: string | null;
  readonly descriptionHTML: string | null;
  readonly interactionAbility: IRepositoryInteractionAbility | null;
  readonly ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  readonly ipAllowListEntries: IIpAllowListEntryConnection;
  readonly isVerified: boolean;
  readonly membersWithRole: IOrganizationMemberConnection;
  readonly newTeamResourcePath: unknown;
  readonly newTeamUrl: unknown;
  readonly organizationBillingEmail: string | null;
  readonly pendingMembers: IUserConnection;
  readonly requiresTwoFactorAuthentication: boolean | null;
  readonly samlIdentityProvider: IOrganizationIdentityProvider | null;
  readonly team: ITeam | null;
  readonly teams: ITeamConnection;
  readonly teamsResourcePath: unknown;
  readonly teamsUrl: unknown;
  readonly twitterUsername: string | null;
  readonly updatedAt: unknown;
  readonly viewerCanAdminister: boolean;
  readonly viewerCanCreateRepositories: boolean;
  readonly viewerCanCreateTeams: boolean;
  readonly viewerIsAMember: boolean;
}

interface OrganizationSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */

  readonly anyPinnableItems: (variables: {
    type?: Variable<"type"> | PinnableItemType;
  }) => Field<
    "anyPinnableItems",
    [Argument<"type", Variable<"type"> | PinnableItemType>]
  >;

  /**
   * @description Audit log entries of the organization
   */

  readonly auditLog: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | AuditLogOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: OrganizationAuditEntryConnectionSelector) => T
  ) => Field<
    "auditLog",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | AuditLogOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A URL pointing to the organization's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The organization's public profile description.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The organization's public profile description rendered to HTML.
   */

  readonly descriptionHTML: () => Field<"descriptionHTML">;

  /**
   * @description The organization's public email.
   */

  readonly email: () => Field<"email">;

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */

  readonly hasSponsorsListing: () => Field<"hasSponsorsListing">;

  readonly id: () => Field<"id">;

  /**
   * @description The interaction ability settings for this organization.
   */

  readonly interactionAbility: <T extends Array<Selection>>(
    select: (t: RepositoryInteractionAbilitySelector) => T
  ) => Field<"interactionAbility", never, SelectionSet<T>>;

  /**
   * @description The setting value for whether the organization has an IP allow list enabled.
   */

  readonly ipAllowListEnabledSetting: () => Field<"ipAllowListEnabledSetting">;

  /**
   * @description The IP addresses that are allowed to access resources owned by the organization.
   */

  readonly ipAllowListEntries: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IpAllowListEntryOrder;
    },
    select: (t: IpAllowListEntryConnectionSelector) => T
  ) => Field<
    "ipAllowListEntries",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IpAllowListEntryOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */

  readonly isSponsoringViewer: () => Field<"isSponsoringViewer">;

  /**
   * @description Whether the organization has verified its profile email and website, always false on Enterprise.
   */

  readonly isVerified: () => Field<"isVerified">;

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  readonly itemShowcase: <T extends Array<Selection>>(
    select: (t: ProfileItemShowcaseSelector) => T
  ) => Field<"itemShowcase", never, SelectionSet<T>>;

  /**
   * @description The organization's public profile location.
   */

  readonly location: () => Field<"location">;

  /**
   * @description The organization's login name.
   */

  readonly login: () => Field<"login">;

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  readonly memberStatuses: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | UserStatusOrder;
    },
    select: (t: UserStatusConnectionSelector) => T
  ) => Field<
    "memberStatuses",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | UserStatusOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users who are members of this organization.
   */

  readonly membersWithRole: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: OrganizationMemberConnectionSelector) => T
  ) => Field<
    "membersWithRole",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The organization's public profile name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The HTTP path creating a new team
   */

  readonly newTeamResourcePath: () => Field<"newTeamResourcePath">;

  /**
   * @description The HTTP URL creating a new team
   */

  readonly newTeamUrl: () => Field<"newTeamUrl">;

  /**
   * @description The billing email for the organization.
   */

  readonly organizationBillingEmail: () => Field<"organizationBillingEmail">;

  /**
   * @description A list of packages under the owner.
   */

  readonly packages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      names?: Variable<"names"> | string;
      orderBy?: Variable<"orderBy"> | PackageOrder;
      packageType?: Variable<"packageType"> | PackageType;
      repositoryId?: Variable<"repositoryId"> | string;
    },
    select: (t: PackageConnectionSelector) => T
  ) => Field<
    "packages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"names", Variable<"names"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | PackageOrder>,
      Argument<"packageType", Variable<"packageType"> | PackageType>,
      Argument<"repositoryId", Variable<"repositoryId"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users who have been invited to join this organization.
   */

  readonly pendingMembers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "pendingMembers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  readonly pinnableItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnableItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  readonly pinnedItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnedItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */

  readonly pinnedItemsRemaining: () => Field<"pinnedItemsRemaining">;

  /**
   * @description Find project by number.
   */

  readonly project: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: ProjectSelector) => T
  ) => Field<
    "project",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of projects under the owner.
   */

  readonly projects: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ProjectOrder;
      search?: Variable<"search"> | string;
      states?: Variable<"states"> | ProjectState;
    },
    select: (t: ProjectConnectionSelector) => T
  ) => Field<
    "projects",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ProjectOrder>,
      Argument<"search", Variable<"search"> | string>,
      Argument<"states", Variable<"states"> | ProjectState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing organization's projects
   */

  readonly projectsResourcePath: () => Field<"projectsResourcePath">;

  /**
   * @description The HTTP URL listing organization's projects
   */

  readonly projectsUrl: () => Field<"projectsUrl">;

  /**
   * @description A list of repositories that the user owns.
   */

  readonly repositories: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isFork?: Variable<"isFork"> | boolean;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isFork", Variable<"isFork"> | boolean>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find Repository.
   */

  readonly repository: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: RepositorySelector) => T
  ) => Field<
    "repository",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
     * @description When true the organization requires all members, billing managers, and outside
collaborators to enable two-factor authentication.
     */

  readonly requiresTwoFactorAuthentication: () => Field<"requiresTwoFactorAuthentication">;

  /**
   * @description The HTTP path for this organization.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The Organization's SAML identity providers
   */

  readonly samlIdentityProvider: <T extends Array<Selection>>(
    select: (t: OrganizationIdentityProviderSelector) => T
  ) => Field<"samlIdentityProvider", never, SelectionSet<T>>;

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  readonly sponsorsListing: <T extends Array<Selection>>(
    select: (t: SponsorsListingSelector) => T
  ) => Field<"sponsorsListing", never, SelectionSet<T>>;

  /**
   * @description This object's sponsorships as the maintainer.
   */

  readonly sponsorshipsAsMaintainer: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      includePrivate?: Variable<"includePrivate"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsMaintainer",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"includePrivate", Variable<"includePrivate"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description This object's sponsorships as the sponsor.
   */

  readonly sponsorshipsAsSponsor: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsSponsor",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find an organization's team by its slug.
   */

  readonly team: <T extends Array<Selection>>(
    variables: { slug?: Variable<"slug"> | string },
    select: (t: TeamSelector) => T
  ) => Field<
    "team",
    [Argument<"slug", Variable<"slug"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description A list of teams in this organization.
   */

  readonly teams: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      ldapMapped?: Variable<"ldapMapped"> | boolean;
      orderBy?: Variable<"orderBy"> | TeamOrder;
      privacy?: Variable<"privacy"> | TeamPrivacy;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | TeamRole;
      rootTeamsOnly?: Variable<"rootTeamsOnly"> | boolean;
      userLogins?: Variable<"userLogins"> | string;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "teams",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"ldapMapped", Variable<"ldapMapped"> | boolean>,
      Argument<"orderBy", Variable<"orderBy"> | TeamOrder>,
      Argument<"privacy", Variable<"privacy"> | TeamPrivacy>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | TeamRole>,
      Argument<"rootTeamsOnly", Variable<"rootTeamsOnly"> | boolean>,
      Argument<"userLogins", Variable<"userLogins"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing organization's teams
   */

  readonly teamsResourcePath: () => Field<"teamsResourcePath">;

  /**
   * @description The HTTP URL listing organization's teams
   */

  readonly teamsUrl: () => Field<"teamsUrl">;

  /**
   * @description The organization's Twitter username.
   */

  readonly twitterUsername: () => Field<"twitterUsername">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this organization.
   */

  readonly url: () => Field<"url">;

  /**
   * @description Organization is adminable by the viewer.
   */

  readonly viewerCanAdminister: () => Field<"viewerCanAdminister">;

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */

  readonly viewerCanChangePinnedItems: () => Field<"viewerCanChangePinnedItems">;

  /**
   * @description Can the current viewer create new projects on this owner.
   */

  readonly viewerCanCreateProjects: () => Field<"viewerCanCreateProjects">;

  /**
   * @description Viewer can create repositories on this organization
   */

  readonly viewerCanCreateRepositories: () => Field<"viewerCanCreateRepositories">;

  /**
   * @description Viewer can create teams on this organization.
   */

  readonly viewerCanCreateTeams: () => Field<"viewerCanCreateTeams">;

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */

  readonly viewerCanSponsor: () => Field<"viewerCanSponsor">;

  /**
   * @description Viewer is an active member of this organization.
   */

  readonly viewerIsAMember: () => Field<"viewerIsAMember">;

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */

  readonly viewerIsSponsoring: () => Field<"viewerIsSponsoring">;

  /**
   * @description The organization's public profile URL.
   */

  readonly websiteUrl: () => Field<"websiteUrl">;
}

export const isOrganization = (
  object: Record<string, any>
): object is Partial<IOrganization> => {
  return object.__typename === "Organization";
};

export const Organization: OrganizationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */
  anyPinnableItems: (variables) => new Field("anyPinnableItems"),

  /**
   * @description Audit log entries of the organization
   */

  auditLog: (variables, select) =>
    new Field(
      "auditLog",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(OrganizationAuditEntryConnection))
    ),

  /**
   * @description A URL pointing to the organization's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The organization's public profile description.
   */
  description: () => new Field("description"),

  /**
   * @description The organization's public profile description rendered to HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),

  /**
   * @description The organization's public email.
   */
  email: () => new Field("email"),

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */
  hasSponsorsListing: () => new Field("hasSponsorsListing"),
  id: () => new Field("id"),

  /**
   * @description The interaction ability settings for this organization.
   */

  interactionAbility: (select) =>
    new Field(
      "interactionAbility",
      undefined as never,
      new SelectionSet(select(RepositoryInteractionAbility))
    ),

  /**
   * @description The setting value for whether the organization has an IP allow list enabled.
   */
  ipAllowListEnabledSetting: () => new Field("ipAllowListEnabledSetting"),

  /**
   * @description The IP addresses that are allowed to access resources owned by the organization.
   */

  ipAllowListEntries: (variables, select) =>
    new Field(
      "ipAllowListEntries",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IpAllowListEntryConnection))
    ),

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */
  isSponsoringViewer: () => new Field("isSponsoringViewer"),

  /**
   * @description Whether the organization has verified its profile email and website, always false on Enterprise.
   */
  isVerified: () => new Field("isVerified"),

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: (select) =>
    new Field(
      "itemShowcase",
      undefined as never,
      new SelectionSet(select(ProfileItemShowcase))
    ),

  /**
   * @description The organization's public profile location.
   */
  location: () => new Field("location"),

  /**
   * @description The organization's login name.
   */
  login: () => new Field("login"),

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: (variables, select) =>
    new Field(
      "memberStatuses",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(UserStatusConnection))
    ),

  /**
   * @description A list of users who are members of this organization.
   */

  membersWithRole: (variables, select) =>
    new Field(
      "membersWithRole",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(OrganizationMemberConnection))
    ),

  /**
   * @description The organization's public profile name.
   */
  name: () => new Field("name"),

  /**
   * @description The HTTP path creating a new team
   */
  newTeamResourcePath: () => new Field("newTeamResourcePath"),

  /**
   * @description The HTTP URL creating a new team
   */
  newTeamUrl: () => new Field("newTeamUrl"),

  /**
   * @description The billing email for the organization.
   */
  organizationBillingEmail: () => new Field("organizationBillingEmail"),

  /**
   * @description A list of packages under the owner.
   */

  packages: (variables, select) =>
    new Field(
      "packages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("names", variables.names),
        new Argument("orderBy", variables.orderBy),
        new Argument("packageType", variables.packageType, PackageType),
        new Argument("repositoryId", variables.repositoryId),
      ],
      new SelectionSet(select(PackageConnection))
    ),

  /**
   * @description A list of users who have been invited to join this organization.
   */

  pendingMembers: (variables, select) =>
    new Field(
      "pendingMembers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: (variables, select) =>
    new Field(
      "pinnableItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: (variables, select) =>
    new Field(
      "pinnedItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */
  pinnedItemsRemaining: () => new Field("pinnedItemsRemaining"),

  /**
   * @description Find project by number.
   */

  project: (variables, select) =>
    new Field(
      "project",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Project))
    ),

  /**
   * @description A list of projects under the owner.
   */

  projects: (variables, select) =>
    new Field(
      "projects",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("search", variables.search),
        new Argument("states", variables.states, ProjectState),
      ],
      new SelectionSet(select(ProjectConnection))
    ),

  /**
   * @description The HTTP path listing organization's projects
   */
  projectsResourcePath: () => new Field("projectsResourcePath"),

  /**
   * @description The HTTP URL listing organization's projects
   */
  projectsUrl: () => new Field("projectsUrl"),

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isFork", variables.isFork),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description Find Repository.
   */

  repository: (variables, select) =>
    new Field(
      "repository",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Repository))
    ),

  /**
     * @description When true the organization requires all members, billing managers, and outside
collaborators to enable two-factor authentication.
     */
  requiresTwoFactorAuthentication: () =>
    new Field("requiresTwoFactorAuthentication"),

  /**
   * @description The HTTP path for this organization.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The Organization's SAML identity providers
   */

  samlIdentityProvider: (select) =>
    new Field(
      "samlIdentityProvider",
      undefined as never,
      new SelectionSet(select(OrganizationIdentityProvider))
    ),

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: (select) =>
    new Field(
      "sponsorsListing",
      undefined as never,
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: (variables, select) =>
    new Field(
      "sponsorshipsAsMaintainer",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("includePrivate", variables.includePrivate),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: (variables, select) =>
    new Field(
      "sponsorshipsAsSponsor",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description Find an organization's team by its slug.
   */

  team: (variables, select) =>
    new Field(
      "team",
      [new Argument("slug", variables.slug)],
      new SelectionSet(select(Team))
    ),

  /**
   * @description A list of teams in this organization.
   */

  teams: (variables, select) =>
    new Field(
      "teams",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("ldapMapped", variables.ldapMapped),
        new Argument("orderBy", variables.orderBy),
        new Argument("privacy", variables.privacy, TeamPrivacy),
        new Argument("query", variables.query),
        new Argument("role", variables.role, TeamRole),
        new Argument("rootTeamsOnly", variables.rootTeamsOnly),
        new Argument("userLogins", variables.userLogins),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description The HTTP path listing organization's teams
   */
  teamsResourcePath: () => new Field("teamsResourcePath"),

  /**
   * @description The HTTP URL listing organization's teams
   */
  teamsUrl: () => new Field("teamsUrl"),

  /**
   * @description The organization's Twitter username.
   */
  twitterUsername: () => new Field("twitterUsername"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this organization.
   */
  url: () => new Field("url"),

  /**
   * @description Organization is adminable by the viewer.
   */
  viewerCanAdminister: () => new Field("viewerCanAdminister"),

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */
  viewerCanChangePinnedItems: () => new Field("viewerCanChangePinnedItems"),

  /**
   * @description Can the current viewer create new projects on this owner.
   */
  viewerCanCreateProjects: () => new Field("viewerCanCreateProjects"),

  /**
   * @description Viewer can create repositories on this organization
   */
  viewerCanCreateRepositories: () => new Field("viewerCanCreateRepositories"),

  /**
   * @description Viewer can create teams on this organization.
   */
  viewerCanCreateTeams: () => new Field("viewerCanCreateTeams"),

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */
  viewerCanSponsor: () => new Field("viewerCanSponsor"),

  /**
   * @description Viewer is an active member of this organization.
   */
  viewerIsAMember: () => new Field("viewerIsAMember"),

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */
  viewerIsSponsoring: () => new Field("viewerIsSponsoring"),

  /**
   * @description The organization's public profile URL.
   */
  websiteUrl: () => new Field("websiteUrl"),
};

export interface IOrganizationAuditEntryConnection {
  readonly __typename: "OrganizationAuditEntryConnection";
  readonly edges: ReadonlyArray<IOrganizationAuditEntryEdge> | null;
  readonly nodes: ReadonlyArray<IOrganizationAuditEntry> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface OrganizationAuditEntryConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: OrganizationAuditEntryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: OrganizationAuditEntrySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const OrganizationAuditEntryConnection: OrganizationAuditEntryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(OrganizationAuditEntryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(OrganizationAuditEntry))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IOrganizationAuditEntryData {
  readonly __typename: string;
  readonly organization: IOrganization | null;
  readonly organizationName: string | null;
  readonly organizationResourcePath: unknown | null;
  readonly organizationUrl: unknown | null;
}

interface OrganizationAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "OauthApplicationCreateAuditEntry"
      | "OrgAddBillingManagerAuditEntry"
      | "OrgAddMemberAuditEntry"
      | "OrgBlockUserAuditEntry"
      | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
      | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
      | "OrgCreateAuditEntry"
      | "OrgDisableOauthAppRestrictionsAuditEntry"
      | "OrgDisableSamlAuditEntry"
      | "OrgDisableTwoFactorRequirementAuditEntry"
      | "OrgEnableOauthAppRestrictionsAuditEntry"
      | "OrgEnableSamlAuditEntry"
      | "OrgEnableTwoFactorRequirementAuditEntry"
      | "OrgInviteMemberAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
      | "OrgRemoveBillingManagerAuditEntry"
      | "OrgRemoveMemberAuditEntry"
      | "OrgRemoveOutsideCollaboratorAuditEntry"
      | "OrgRestoreMemberAuditEntry"
      | "OrgRestoreMemberMembershipOrganizationAuditEntryData"
      | "OrgUnblockUserAuditEntry"
      | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
      | "OrgUpdateMemberAuditEntry"
      | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
      | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgAddBillingManagerAuditEntry"
        ? OrgAddBillingManagerAuditEntrySelector
        : F extends "OrgAddMemberAuditEntry"
        ? OrgAddMemberAuditEntrySelector
        : F extends "OrgBlockUserAuditEntry"
        ? OrgBlockUserAuditEntrySelector
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? OrgConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? OrgConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgCreateAuditEntry"
        ? OrgCreateAuditEntrySelector
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? OrgDisableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgDisableSamlAuditEntry"
        ? OrgDisableSamlAuditEntrySelector
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? OrgDisableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? OrgEnableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgEnableSamlAuditEntry"
        ? OrgEnableSamlAuditEntrySelector
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? OrgEnableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgInviteMemberAuditEntry"
        ? OrgInviteMemberAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? OrgRemoveBillingManagerAuditEntrySelector
        : F extends "OrgRemoveMemberAuditEntry"
        ? OrgRemoveMemberAuditEntrySelector
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? OrgRemoveOutsideCollaboratorAuditEntrySelector
        : F extends "OrgRestoreMemberAuditEntry"
        ? OrgRestoreMemberAuditEntrySelector
        : F extends "OrgRestoreMemberMembershipOrganizationAuditEntryData"
        ? OrgRestoreMemberMembershipOrganizationAuditEntryDataSelector
        : F extends "OrgUnblockUserAuditEntry"
        ? OrgUnblockUserAuditEntrySelector
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? OrgUpdateDefaultRepositoryPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberAuditEntry"
        ? OrgUpdateMemberAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const OrganizationAuditEntryData: OrganizationAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  on: (type, select) => {
    switch (type) {
      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgAddBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgAddBillingManagerAuditEntry as any))
        );
      }

      case "OrgAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddMemberAuditEntry") as any,
          new SelectionSet(select(OrgAddMemberAuditEntry as any))
        );
      }

      case "OrgBlockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgBlockUserAuditEntry") as any,
          new SelectionSet(select(OrgBlockUserAuditEntry as any))
        );
      }

      case "OrgConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgCreateAuditEntry") as any,
          new SelectionSet(select(OrgCreateAuditEntry as any))
        );
      }

      case "OrgDisableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgDisableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableSamlAuditEntry") as any,
          new SelectionSet(select(OrgDisableSamlAuditEntry as any))
        );
      }

      case "OrgDisableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgEnableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgEnableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableSamlAuditEntry") as any,
          new SelectionSet(select(OrgEnableSamlAuditEntry as any))
        );
      }

      case "OrgEnableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgInviteMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteMemberAuditEntry") as any,
          new SelectionSet(select(OrgInviteMemberAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      case "OrgRemoveBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgRemoveBillingManagerAuditEntry as any))
        );
      }

      case "OrgRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveMemberAuditEntry") as any,
          new SelectionSet(select(OrgRemoveMemberAuditEntry as any))
        );
      }

      case "OrgRemoveOutsideCollaboratorAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveOutsideCollaboratorAuditEntry") as any,
          new SelectionSet(
            select(OrgRemoveOutsideCollaboratorAuditEntry as any)
          )
        );
      }

      case "OrgRestoreMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberAuditEntry") as any,
          new SelectionSet(select(OrgRestoreMemberAuditEntry as any))
        );
      }

      case "OrgRestoreMemberMembershipOrganizationAuditEntryData": {
        return new InlineFragment(
          new NamedType(
            "OrgRestoreMemberMembershipOrganizationAuditEntryData"
          ) as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipOrganizationAuditEntryData as any)
          )
        );
      }

      case "OrgUnblockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUnblockUserAuditEntry") as any,
          new SelectionSet(select(OrgUnblockUserAuditEntry as any))
        );
      }

      case "OrgUpdateDefaultRepositoryPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateDefaultRepositoryPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateDefaultRepositoryPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUpdateMemberAuditEntry") as any,
          new SelectionSet(select(OrgUpdateMemberAuditEntry as any))
        );
      }

      case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateMemberRepositoryCreationPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(
              OrgUpdateMemberRepositoryInvitationPermissionAuditEntry as any
            )
          )
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "OrganizationAuditEntryData",
        });
    }
  },
};

export interface IOrganizationAuditEntryEdge {
  readonly __typename: "OrganizationAuditEntryEdge";
  readonly cursor: string;
  readonly node: IOrganizationAuditEntry | null;
}

interface OrganizationAuditEntryEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: OrganizationAuditEntrySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const OrganizationAuditEntryEdge: OrganizationAuditEntryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(OrganizationAuditEntry))
    ),
};

export interface IOrganizationConnection {
  readonly __typename: "OrganizationConnection";
  readonly edges: ReadonlyArray<IOrganizationEdge> | null;
  readonly nodes: ReadonlyArray<IOrganization> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface OrganizationConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: OrganizationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const OrganizationConnection: OrganizationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(OrganizationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IOrganizationEdge {
  readonly __typename: "OrganizationEdge";
  readonly cursor: string;
  readonly node: IOrganization | null;
}

interface OrganizationEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const OrganizationEdge: OrganizationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(Organization))
    ),
};

export interface IOrganizationIdentityProvider extends INode {
  readonly __typename: "OrganizationIdentityProvider";
  readonly digestMethod: unknown | null;
  readonly externalIdentities: IExternalIdentityConnection;
  readonly idpCertificate: unknown | null;
  readonly issuer: string | null;
  readonly organization: IOrganization | null;
  readonly signatureMethod: unknown | null;
  readonly ssoUrl: unknown | null;
}

interface OrganizationIdentityProviderSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The digest algorithm used to sign SAML requests for the Identity Provider.
   */

  readonly digestMethod: () => Field<"digestMethod">;

  /**
   * @description External Identities provisioned by this Identity Provider
   */

  readonly externalIdentities: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ExternalIdentityConnectionSelector) => T
  ) => Field<
    "externalIdentities",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description The x509 certificate used by the Identity Provder to sign assertions and responses.
   */

  readonly idpCertificate: () => Field<"idpCertificate">;

  /**
   * @description The Issuer Entity ID for the SAML Identity Provider
   */

  readonly issuer: () => Field<"issuer">;

  /**
   * @description Organization this Identity Provider belongs to
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The signature algorithm used to sign SAML requests for the Identity Provider.
   */

  readonly signatureMethod: () => Field<"signatureMethod">;

  /**
   * @description The URL endpoint for the Identity Provider's SAML SSO.
   */

  readonly ssoUrl: () => Field<"ssoUrl">;
}

export const isOrganizationIdentityProvider = (
  object: Record<string, any>
): object is Partial<IOrganizationIdentityProvider> => {
  return object.__typename === "OrganizationIdentityProvider";
};

export const OrganizationIdentityProvider: OrganizationIdentityProviderSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The digest algorithm used to sign SAML requests for the Identity Provider.
   */
  digestMethod: () => new Field("digestMethod"),

  /**
   * @description External Identities provisioned by this Identity Provider
   */

  externalIdentities: (variables, select) =>
    new Field(
      "externalIdentities",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ExternalIdentityConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The x509 certificate used by the Identity Provder to sign assertions and responses.
   */
  idpCertificate: () => new Field("idpCertificate"),

  /**
   * @description The Issuer Entity ID for the SAML Identity Provider
   */
  issuer: () => new Field("issuer"),

  /**
   * @description Organization this Identity Provider belongs to
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The signature algorithm used to sign SAML requests for the Identity Provider.
   */
  signatureMethod: () => new Field("signatureMethod"),

  /**
   * @description The URL endpoint for the Identity Provider's SAML SSO.
   */
  ssoUrl: () => new Field("ssoUrl"),
};

export interface IOrganizationInvitation extends INode {
  readonly __typename: "OrganizationInvitation";
  readonly createdAt: unknown;
  readonly email: string | null;
  readonly invitationType: OrganizationInvitationType;
  readonly invitee: IUser | null;
  readonly inviter: IUser;
  readonly organization: IOrganization;
  readonly role: OrganizationInvitationRole;
}

interface OrganizationInvitationSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The email address of the user invited to the organization.
   */

  readonly email: () => Field<"email">;

  readonly id: () => Field<"id">;

  /**
   * @description The type of invitation that was sent (e.g. email, user).
   */

  readonly invitationType: () => Field<"invitationType">;

  /**
   * @description The user who was invited to the organization.
   */

  readonly invitee: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"invitee", never, SelectionSet<T>>;

  /**
   * @description The user who created the invitation.
   */

  readonly inviter: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"inviter", never, SelectionSet<T>>;

  /**
   * @description The organization the invite is for
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The user's pending role in the organization (e.g. member, owner).
   */

  readonly role: () => Field<"role">;
}

export const isOrganizationInvitation = (
  object: Record<string, any>
): object is Partial<IOrganizationInvitation> => {
  return object.__typename === "OrganizationInvitation";
};

export const OrganizationInvitation: OrganizationInvitationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The email address of the user invited to the organization.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description The type of invitation that was sent (e.g. email, user).
   */
  invitationType: () => new Field("invitationType"),

  /**
   * @description The user who was invited to the organization.
   */

  invitee: (select) =>
    new Field("invitee", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The user who created the invitation.
   */

  inviter: (select) =>
    new Field("inviter", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The organization the invite is for
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The user's pending role in the organization (e.g. member, owner).
   */
  role: () => new Field("role"),
};

export interface IOrganizationInvitationConnection {
  readonly __typename: "OrganizationInvitationConnection";
  readonly edges: ReadonlyArray<IOrganizationInvitationEdge> | null;
  readonly nodes: ReadonlyArray<IOrganizationInvitation> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface OrganizationInvitationConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const OrganizationInvitationConnection: OrganizationInvitationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(OrganizationInvitationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IOrganizationInvitationEdge {
  readonly __typename: "OrganizationInvitationEdge";
  readonly cursor: string;
  readonly node: IOrganizationInvitation | null;
}

interface OrganizationInvitationEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const OrganizationInvitationEdge: OrganizationInvitationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),
};

export interface IOrganizationMemberConnection {
  readonly __typename: "OrganizationMemberConnection";
  readonly edges: ReadonlyArray<IOrganizationMemberEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface OrganizationMemberConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: OrganizationMemberEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const OrganizationMemberConnection: OrganizationMemberConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(OrganizationMemberEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IOrganizationMemberEdge {
  readonly __typename: "OrganizationMemberEdge";
  readonly cursor: string;
  readonly hasTwoFactorEnabled: boolean | null;
  readonly node: IUser | null;
  readonly role: OrganizationMemberRole | null;
}

interface OrganizationMemberEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer.
   */

  readonly hasTwoFactorEnabled: () => Field<"hasTwoFactorEnabled">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The role this user has in the organization.
   */

  readonly role: () => Field<"role">;
}

export const OrganizationMemberEdge: OrganizationMemberEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer.
   */
  hasTwoFactorEnabled: () => new Field("hasTwoFactorEnabled"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The role this user has in the organization.
   */
  role: () => new Field("role"),
};

export interface IOrganizationTeamsHovercardContext extends IHovercardContext {
  readonly __typename: "OrganizationTeamsHovercardContext";
  readonly relevantTeams: ITeamConnection;
  readonly teamsResourcePath: unknown;
  readonly teamsUrl: unknown;
  readonly totalTeamCount: number;
}

interface OrganizationTeamsHovercardContextSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  readonly message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  readonly octicon: () => Field<"octicon">;

  /**
   * @description Teams in this organization the user is a member of that are relevant
   */

  readonly relevantTeams: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "relevantTeams",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The path for the full team list for this user
   */

  readonly teamsResourcePath: () => Field<"teamsResourcePath">;

  /**
   * @description The URL for the full team list for this user
   */

  readonly teamsUrl: () => Field<"teamsUrl">;

  /**
   * @description The total number of teams the user is on in the organization
   */

  readonly totalTeamCount: () => Field<"totalTeamCount">;
}

export const isOrganizationTeamsHovercardContext = (
  object: Record<string, any>
): object is Partial<IOrganizationTeamsHovercardContext> => {
  return object.__typename === "OrganizationTeamsHovercardContext";
};

export const OrganizationTeamsHovercardContext: OrganizationTeamsHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  /**
   * @description Teams in this organization the user is a member of that are relevant
   */

  relevantTeams: (variables, select) =>
    new Field(
      "relevantTeams",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description The path for the full team list for this user
   */
  teamsResourcePath: () => new Field("teamsResourcePath"),

  /**
   * @description The URL for the full team list for this user
   */
  teamsUrl: () => new Field("teamsUrl"),

  /**
   * @description The total number of teams the user is on in the organization
   */
  totalTeamCount: () => new Field("totalTeamCount"),
};

export interface IOrganizationsHovercardContext extends IHovercardContext {
  readonly __typename: "OrganizationsHovercardContext";
  readonly relevantOrganizations: IOrganizationConnection;
  readonly totalOrganizationCount: number;
}

interface OrganizationsHovercardContextSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  readonly message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  readonly octicon: () => Field<"octicon">;

  /**
   * @description Organizations this user is a member of that are relevant
   */

  readonly relevantOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "relevantOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The total number of organizations this user is in
   */

  readonly totalOrganizationCount: () => Field<"totalOrganizationCount">;
}

export const isOrganizationsHovercardContext = (
  object: Record<string, any>
): object is Partial<IOrganizationsHovercardContext> => {
  return object.__typename === "OrganizationsHovercardContext";
};

export const OrganizationsHovercardContext: OrganizationsHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  /**
   * @description Organizations this user is a member of that are relevant
   */

  relevantOrganizations: (variables, select) =>
    new Field(
      "relevantOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The total number of organizations this user is in
   */
  totalOrganizationCount: () => new Field("totalOrganizationCount"),
};

export interface IPackage extends INode {
  readonly __typename: "Package";
  readonly latestVersion: IPackageVersion | null;
  readonly name: string;
  readonly packageType: PackageType;
  readonly repository: IRepository | null;
  readonly statistics: IPackageStatistics | null;
  readonly version: IPackageVersion | null;
  readonly versions: IPackageVersionConnection;
}

interface PackageSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description Find the latest version for the package.
   */

  readonly latestVersion: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"latestVersion", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the package.
   */

  readonly name: () => Field<"name">;

  /**
   * @description Identifies the type of the package.
   */

  readonly packageType: () => Field<"packageType">;

  /**
   * @description The repository this package belongs to.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description Statistics about package activity.
   */

  readonly statistics: <T extends Array<Selection>>(
    select: (t: PackageStatisticsSelector) => T
  ) => Field<"statistics", never, SelectionSet<T>>;

  /**
   * @description Find package version by version string.
   */

  readonly version: <T extends Array<Selection>>(
    variables: { version?: Variable<"version"> | string },
    select: (t: PackageVersionSelector) => T
  ) => Field<
    "version",
    [Argument<"version", Variable<"version"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description list of versions for this package
   */

  readonly versions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | PackageVersionOrder;
    },
    select: (t: PackageVersionConnectionSelector) => T
  ) => Field<
    "versions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | PackageVersionOrder>
    ],
    SelectionSet<T>
  >;
}

export const isPackage = (
  object: Record<string, any>
): object is Partial<IPackage> => {
  return object.__typename === "Package";
};

export const Package: PackageSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Find the latest version for the package.
   */

  latestVersion: (select) =>
    new Field(
      "latestVersion",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),

  /**
   * @description Identifies the name of the package.
   */
  name: () => new Field("name"),

  /**
   * @description Identifies the type of the package.
   */
  packageType: () => new Field("packageType"),

  /**
   * @description The repository this package belongs to.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Statistics about package activity.
   */

  statistics: (select) =>
    new Field(
      "statistics",
      undefined as never,
      new SelectionSet(select(PackageStatistics))
    ),

  /**
   * @description Find package version by version string.
   */

  version: (variables, select) =>
    new Field(
      "version",
      [new Argument("version", variables.version)],
      new SelectionSet(select(PackageVersion))
    ),

  /**
   * @description list of versions for this package
   */

  versions: (variables, select) =>
    new Field(
      "versions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(PackageVersionConnection))
    ),
};

export interface IPackageConnection {
  readonly __typename: "PackageConnection";
  readonly edges: ReadonlyArray<IPackageEdge> | null;
  readonly nodes: ReadonlyArray<IPackage> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PackageConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PackageEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PackageSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PackageConnection: PackageConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PackageEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Package))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPackageEdge {
  readonly __typename: "PackageEdge";
  readonly cursor: string;
  readonly node: IPackage | null;
}

interface PackageEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PackageSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PackageEdge: PackageEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Package))),
};

export interface IPackageFile extends INode {
  readonly __typename: "PackageFile";
  readonly md5: string | null;
  readonly name: string;
  readonly packageVersion: IPackageVersion | null;
  readonly sha1: string | null;
  readonly sha256: string | null;
  readonly size: number | null;
  readonly updatedAt: unknown;
  readonly url: unknown | null;
}

interface PackageFileSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description MD5 hash of the file.
   */

  readonly md5: () => Field<"md5">;

  /**
   * @description Name of the file.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The package version this file belongs to.
   */

  readonly packageVersion: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"packageVersion", never, SelectionSet<T>>;

  /**
   * @description SHA1 hash of the file.
   */

  readonly sha1: () => Field<"sha1">;

  /**
   * @description SHA256 hash of the file.
   */

  readonly sha256: () => Field<"sha256">;

  /**
   * @description Size of the file in bytes.
   */

  readonly size: () => Field<"size">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description URL to download the asset.
   */

  readonly url: () => Field<"url">;
}

export const isPackageFile = (
  object: Record<string, any>
): object is Partial<IPackageFile> => {
  return object.__typename === "PackageFile";
};

export const PackageFile: PackageFileSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description MD5 hash of the file.
   */
  md5: () => new Field("md5"),

  /**
   * @description Name of the file.
   */
  name: () => new Field("name"),

  /**
   * @description The package version this file belongs to.
   */

  packageVersion: (select) =>
    new Field(
      "packageVersion",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),

  /**
   * @description SHA1 hash of the file.
   */
  sha1: () => new Field("sha1"),

  /**
   * @description SHA256 hash of the file.
   */
  sha256: () => new Field("sha256"),

  /**
   * @description Size of the file in bytes.
   */
  size: () => new Field("size"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description URL to download the asset.
   */
  url: () => new Field("url"),
};

export interface IPackageFileConnection {
  readonly __typename: "PackageFileConnection";
  readonly edges: ReadonlyArray<IPackageFileEdge> | null;
  readonly nodes: ReadonlyArray<IPackageFile> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PackageFileConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PackageFileEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PackageFileSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PackageFileConnection: PackageFileConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PackageFileEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PackageFile))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPackageFileEdge {
  readonly __typename: "PackageFileEdge";
  readonly cursor: string;
  readonly node: IPackageFile | null;
}

interface PackageFileEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PackageFileSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PackageFileEdge: PackageFileEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PackageFile))
    ),
};

export interface IPackageOwner {
  readonly __typename: string;
  readonly id: string;
  readonly packages: IPackageConnection;
}

interface PackageOwnerSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description A list of packages under the owner.
   */

  readonly packages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      names?: Variable<"names"> | string;
      orderBy?: Variable<"orderBy"> | PackageOrder;
      packageType?: Variable<"packageType"> | PackageType;
      repositoryId?: Variable<"repositoryId"> | string;
    },
    select: (t: PackageConnectionSelector) => T
  ) => Field<
    "packages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"names", Variable<"names"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | PackageOrder>,
      Argument<"packageType", Variable<"packageType"> | PackageType>,
      Argument<"repositoryId", Variable<"repositoryId"> | string>
    ],
    SelectionSet<T>
  >;

  readonly on: <
    T extends Array<Selection>,
    F extends "Organization" | "Repository" | "User"
  >(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const PackageOwner: PackageOwnerSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description A list of packages under the owner.
   */

  packages: (variables, select) =>
    new Field(
      "packages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("names", variables.names),
        new Argument("orderBy", variables.orderBy),
        new Argument("packageType", variables.packageType, PackageType),
        new Argument("repositoryId", variables.repositoryId),
      ],
      new SelectionSet(select(PackageConnection))
    ),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "PackageOwner",
        });
    }
  },
};

export interface IPackageStatistics {
  readonly __typename: "PackageStatistics";
  readonly downloadsTotalCount: number;
}

interface PackageStatisticsSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Number of times the package was downloaded since it was created.
   */

  readonly downloadsTotalCount: () => Field<"downloadsTotalCount">;
}

export const PackageStatistics: PackageStatisticsSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Number of times the package was downloaded since it was created.
   */
  downloadsTotalCount: () => new Field("downloadsTotalCount"),
};

export interface IPackageTag extends INode {
  readonly __typename: "PackageTag";
  readonly name: string;
  readonly version: IPackageVersion | null;
}

interface PackageTagSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the tag name of the version.
   */

  readonly name: () => Field<"name">;

  /**
   * @description Version that the tag is associated with.
   */

  readonly version: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"version", never, SelectionSet<T>>;
}

export const isPackageTag = (
  object: Record<string, any>
): object is Partial<IPackageTag> => {
  return object.__typename === "PackageTag";
};

export const PackageTag: PackageTagSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Identifies the tag name of the version.
   */
  name: () => new Field("name"),

  /**
   * @description Version that the tag is associated with.
   */

  version: (select) =>
    new Field(
      "version",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),
};

export interface IPackageVersion extends INode {
  readonly __typename: "PackageVersion";
  readonly files: IPackageFileConnection;
  readonly package: IPackage | null;
  readonly platform: string | null;
  readonly preRelease: boolean;
  readonly readme: string | null;
  readonly release: IRelease | null;
  readonly statistics: IPackageVersionStatistics | null;
  readonly summary: string | null;
  readonly version: string;
}

interface PackageVersionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description List of files associated with this package version
   */

  readonly files: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | PackageFileOrder;
    },
    select: (t: PackageFileConnectionSelector) => T
  ) => Field<
    "files",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | PackageFileOrder>
    ],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description The package associated with this version.
   */

  readonly package: <T extends Array<Selection>>(
    select: (t: PackageSelector) => T
  ) => Field<"package", never, SelectionSet<T>>;

  /**
   * @description The platform this version was built for.
   */

  readonly platform: () => Field<"platform">;

  /**
   * @description Whether or not this version is a pre-release.
   */

  readonly preRelease: () => Field<"preRelease">;

  /**
   * @description The README of this package version.
   */

  readonly readme: () => Field<"readme">;

  /**
   * @description The release associated with this package version.
   */

  readonly release: <T extends Array<Selection>>(
    select: (t: ReleaseSelector) => T
  ) => Field<"release", never, SelectionSet<T>>;

  /**
   * @description Statistics about package activity.
   */

  readonly statistics: <T extends Array<Selection>>(
    select: (t: PackageVersionStatisticsSelector) => T
  ) => Field<"statistics", never, SelectionSet<T>>;

  /**
   * @description The package version summary.
   */

  readonly summary: () => Field<"summary">;

  /**
   * @description The version string.
   */

  readonly version: () => Field<"version">;
}

export const isPackageVersion = (
  object: Record<string, any>
): object is Partial<IPackageVersion> => {
  return object.__typename === "PackageVersion";
};

export const PackageVersion: PackageVersionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description List of files associated with this package version
   */

  files: (variables, select) =>
    new Field(
      "files",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(PackageFileConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The package associated with this version.
   */

  package: (select) =>
    new Field("package", undefined as never, new SelectionSet(select(Package))),

  /**
   * @description The platform this version was built for.
   */
  platform: () => new Field("platform"),

  /**
   * @description Whether or not this version is a pre-release.
   */
  preRelease: () => new Field("preRelease"),

  /**
   * @description The README of this package version.
   */
  readme: () => new Field("readme"),

  /**
   * @description The release associated with this package version.
   */

  release: (select) =>
    new Field("release", undefined as never, new SelectionSet(select(Release))),

  /**
   * @description Statistics about package activity.
   */

  statistics: (select) =>
    new Field(
      "statistics",
      undefined as never,
      new SelectionSet(select(PackageVersionStatistics))
    ),

  /**
   * @description The package version summary.
   */
  summary: () => new Field("summary"),

  /**
   * @description The version string.
   */
  version: () => new Field("version"),
};

export interface IPackageVersionConnection {
  readonly __typename: "PackageVersionConnection";
  readonly edges: ReadonlyArray<IPackageVersionEdge> | null;
  readonly nodes: ReadonlyArray<IPackageVersion> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PackageVersionConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PackageVersionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PackageVersionConnection: PackageVersionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PackageVersionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPackageVersionEdge {
  readonly __typename: "PackageVersionEdge";
  readonly cursor: string;
  readonly node: IPackageVersion | null;
}

interface PackageVersionEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PackageVersionEdge: PackageVersionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),
};

export interface IPackageVersionStatistics {
  readonly __typename: "PackageVersionStatistics";
  readonly downloadsTotalCount: number;
}

interface PackageVersionStatisticsSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Number of times the package was downloaded since it was created.
   */

  readonly downloadsTotalCount: () => Field<"downloadsTotalCount">;
}

export const PackageVersionStatistics: PackageVersionStatisticsSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Number of times the package was downloaded since it was created.
   */
  downloadsTotalCount: () => new Field("downloadsTotalCount"),
};

export interface IPageInfo {
  readonly __typename: "PageInfo";
  readonly endCursor: string | null;
  readonly hasNextPage: boolean;
  readonly hasPreviousPage: boolean;
  readonly startCursor: string | null;
}

interface PageInfoSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description When paginating forwards, the cursor to continue.
   */

  readonly endCursor: () => Field<"endCursor">;

  /**
   * @description When paginating forwards, are there more items?
   */

  readonly hasNextPage: () => Field<"hasNextPage">;

  /**
   * @description When paginating backwards, are there more items?
   */

  readonly hasPreviousPage: () => Field<"hasPreviousPage">;

  /**
   * @description When paginating backwards, the cursor to continue.
   */

  readonly startCursor: () => Field<"startCursor">;
}

export const PageInfo: PageInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description When paginating forwards, the cursor to continue.
   */
  endCursor: () => new Field("endCursor"),

  /**
   * @description When paginating forwards, are there more items?
   */
  hasNextPage: () => new Field("hasNextPage"),

  /**
   * @description When paginating backwards, are there more items?
   */
  hasPreviousPage: () => new Field("hasPreviousPage"),

  /**
   * @description When paginating backwards, the cursor to continue.
   */
  startCursor: () => new Field("startCursor"),
};

export interface IPermissionSource {
  readonly __typename: "PermissionSource";
  readonly organization: IOrganization;
  readonly permission: DefaultRepositoryPermissionField;
  readonly source: IPermissionGranter;
}

interface PermissionSourceSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The organization the repository belongs to.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The level of access this source has granted to the user.
   */

  readonly permission: () => Field<"permission">;

  /**
   * @description The source of this permission.
   */

  readonly source: <T extends Array<Selection>>(
    select: (t: PermissionGranterSelector) => T
  ) => Field<"source", never, SelectionSet<T>>;
}

export const PermissionSource: PermissionSourceSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The organization the repository belongs to.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The level of access this source has granted to the user.
   */
  permission: () => new Field("permission"),

  /**
   * @description The source of this permission.
   */

  source: (select) =>
    new Field(
      "source",
      undefined as never,
      new SelectionSet(select(PermissionGranter))
    ),
};

export interface IPinnableItemConnection {
  readonly __typename: "PinnableItemConnection";
  readonly edges: ReadonlyArray<IPinnableItemEdge> | null;
  readonly nodes: ReadonlyArray<IPinnableItem> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PinnableItemConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PinnableItemEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PinnableItemSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PinnableItemConnection: PinnableItemConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PinnableItemEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PinnableItem))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPinnableItemEdge {
  readonly __typename: "PinnableItemEdge";
  readonly cursor: string;
  readonly node: IPinnableItem | null;
}

interface PinnableItemEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PinnableItemSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PinnableItemEdge: PinnableItemEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PinnableItem))
    ),
};

export interface IPinnedEvent extends INode {
  readonly __typename: "PinnedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly issue: IIssue;
}

interface PinnedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the issue associated with the event.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const isPinnedEvent = (
  object: Record<string, any>
): object is Partial<IPinnedEvent> => {
  return object.__typename === "PinnedEvent";
};

export const PinnedEvent: PinnedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IPrivateRepositoryForkingDisableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "PrivateRepositoryForkingDisableAuditEntry";
}

interface PrivateRepositoryForkingDisableAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isPrivateRepositoryForkingDisableAuditEntry = (
  object: Record<string, any>
): object is Partial<IPrivateRepositoryForkingDisableAuditEntry> => {
  return object.__typename === "PrivateRepositoryForkingDisableAuditEntry";
};

export const PrivateRepositoryForkingDisableAuditEntry: PrivateRepositoryForkingDisableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IPrivateRepositoryForkingEnableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "PrivateRepositoryForkingEnableAuditEntry";
}

interface PrivateRepositoryForkingEnableAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isPrivateRepositoryForkingEnableAuditEntry = (
  object: Record<string, any>
): object is Partial<IPrivateRepositoryForkingEnableAuditEntry> => {
  return object.__typename === "PrivateRepositoryForkingEnableAuditEntry";
};

export const PrivateRepositoryForkingEnableAuditEntry: PrivateRepositoryForkingEnableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IProfileItemShowcase {
  readonly __typename: "ProfileItemShowcase";
  readonly hasPinnedItems: boolean;
  readonly items: IPinnableItemConnection;
}

interface ProfileItemShowcaseSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Whether or not the owner has pinned any repositories or gists.
   */

  readonly hasPinnedItems: () => Field<"hasPinnedItems">;

  /**
     * @description The repositories and gists in the showcase. If the profile owner has any
pinned items, those will be returned. Otherwise, the profile owner's popular
repositories will be returned.
     */

  readonly items: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "items",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;
}

export const ProfileItemShowcase: ProfileItemShowcaseSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Whether or not the owner has pinned any repositories or gists.
   */
  hasPinnedItems: () => new Field("hasPinnedItems"),

  /**
     * @description The repositories and gists in the showcase. If the profile owner has any
pinned items, those will be returned. Otherwise, the profile owner's popular
repositories will be returned.
     */

  items: (variables, select) =>
    new Field(
      "items",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),
};

export interface IProfileOwner {
  readonly __typename: string;
  readonly anyPinnableItems: boolean;
  readonly email: string | null;
  readonly id: string;
  readonly itemShowcase: IProfileItemShowcase;
  readonly location: string | null;
  readonly login: string;
  readonly name: string | null;
  readonly pinnableItems: IPinnableItemConnection;
  readonly pinnedItems: IPinnableItemConnection;
  readonly pinnedItemsRemaining: number;
  readonly viewerCanChangePinnedItems: boolean;
  readonly websiteUrl: unknown | null;
}

interface ProfileOwnerSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */

  readonly anyPinnableItems: (variables: {
    type?: Variable<"type"> | PinnableItemType;
  }) => Field<
    "anyPinnableItems",
    [Argument<"type", Variable<"type"> | PinnableItemType>]
  >;

  /**
   * @description The public profile email.
   */

  readonly email: () => Field<"email">;

  readonly id: () => Field<"id">;

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  readonly itemShowcase: <T extends Array<Selection>>(
    select: (t: ProfileItemShowcaseSelector) => T
  ) => Field<"itemShowcase", never, SelectionSet<T>>;

  /**
   * @description The public profile location.
   */

  readonly location: () => Field<"location">;

  /**
   * @description The username used to login.
   */

  readonly login: () => Field<"login">;

  /**
   * @description The public profile name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  readonly pinnableItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnableItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  readonly pinnedItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnedItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */

  readonly pinnedItemsRemaining: () => Field<"pinnedItemsRemaining">;

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */

  readonly viewerCanChangePinnedItems: () => Field<"viewerCanChangePinnedItems">;

  /**
   * @description The public profile website URL.
   */

  readonly websiteUrl: () => Field<"websiteUrl">;

  readonly on: <T extends Array<Selection>, F extends "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const ProfileOwner: ProfileOwnerSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */
  anyPinnableItems: (variables) => new Field("anyPinnableItems"),

  /**
   * @description The public profile email.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: (select) =>
    new Field(
      "itemShowcase",
      undefined as never,
      new SelectionSet(select(ProfileItemShowcase))
    ),

  /**
   * @description The public profile location.
   */
  location: () => new Field("location"),

  /**
   * @description The username used to login.
   */
  login: () => new Field("login"),

  /**
   * @description The public profile name.
   */
  name: () => new Field("name"),

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: (variables, select) =>
    new Field(
      "pinnableItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: (variables, select) =>
    new Field(
      "pinnedItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */
  pinnedItemsRemaining: () => new Field("pinnedItemsRemaining"),

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */
  viewerCanChangePinnedItems: () => new Field("viewerCanChangePinnedItems"),

  /**
   * @description The public profile website URL.
   */
  websiteUrl: () => new Field("websiteUrl"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "ProfileOwner",
        });
    }
  },
};

export interface IProject extends IClosable, INode, IUpdatable {
  readonly __typename: "Project";
  readonly body: string | null;
  readonly bodyHTML: unknown;
  readonly columns: IProjectColumnConnection;
  readonly createdAt: unknown;
  readonly creator: IActor | null;
  readonly databaseId: number | null;
  readonly name: string;
  readonly number: number;
  readonly owner: IProjectOwner;
  readonly pendingCards: IProjectCardConnection;
  readonly progress: IProjectProgress;
  readonly resourcePath: unknown;
  readonly state: ProjectState;
  readonly updatedAt: unknown;
  readonly url: unknown;
}

interface ProjectSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The project's description body.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The projects description body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */

  readonly closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  readonly closedAt: () => Field<"closedAt">;

  /**
   * @description List of columns in the project
   */

  readonly columns: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectColumnConnectionSelector) => T
  ) => Field<
    "columns",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The actor who originally created the project.
   */

  readonly creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description The project's name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The project's number.
   */

  readonly number: () => Field<"number">;

  /**
   * @description The project's owner. Currently limited to repositories, organizations, and users.
   */

  readonly owner: <T extends Array<Selection>>(
    select: (t: ProjectOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description List of pending cards in this project
   */

  readonly pendingCards: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      archivedStates?: Variable<"archivedStates"> | ProjectCardArchivedState;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectCardConnectionSelector) => T
  ) => Field<
    "pendingCards",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<
        "archivedStates",
        Variable<"archivedStates"> | ProjectCardArchivedState
      >,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Project progress details.
   */

  readonly progress: <T extends Array<Selection>>(
    select: (t: ProjectProgressSelector) => T
  ) => Field<"progress", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this project
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Whether the project is open or closed.
   */

  readonly state: () => Field<"state">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this project
   */

  readonly url: () => Field<"url">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;
}

export const isProject = (
  object: Record<string, any>
): object is Partial<IProject> => {
  return object.__typename === "Project";
};

export const Project: ProjectSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The project's description body.
   */
  body: () => new Field("body"),

  /**
   * @description The projects description body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  /**
   * @description List of columns in the project
   */

  columns: (variables, select) =>
    new Field(
      "columns",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectColumnConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The actor who originally created the project.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The project's name.
   */
  name: () => new Field("name"),

  /**
   * @description The project's number.
   */
  number: () => new Field("number"),

  /**
   * @description The project's owner. Currently limited to repositories, organizations, and users.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(ProjectOwner))
    ),

  /**
   * @description List of pending cards in this project
   */

  pendingCards: (variables, select) =>
    new Field(
      "pendingCards",
      [
        new Argument("after", variables.after),
        new Argument(
          "archivedStates",
          variables.archivedStates,
          ProjectCardArchivedState
        ),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectCardConnection))
    ),

  /**
   * @description Project progress details.
   */

  progress: (select) =>
    new Field(
      "progress",
      undefined as never,
      new SelectionSet(select(ProjectProgress))
    ),

  /**
   * @description The HTTP path for this project
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Whether the project is open or closed.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this project
   */
  url: () => new Field("url"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),
};

export interface IProjectCard extends INode {
  readonly __typename: "ProjectCard";
  readonly column: IProjectColumn | null;
  readonly content: IProjectCardItem | null;
  readonly createdAt: unknown;
  readonly creator: IActor | null;
  readonly databaseId: number | null;
  readonly isArchived: boolean;
  readonly note: string | null;
  readonly project: IProject;
  readonly resourcePath: unknown;
  readonly state: ProjectCardState | null;
  readonly updatedAt: unknown;
  readonly url: unknown;
}

interface ProjectCardSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description The project column this card is associated under. A card may only belong to one
project column at a time. The column field will be null if the card is created
in a pending state and has yet to be associated with a column. Once cards are
associated with a column, they will not become pending in the future.
     */

  readonly column: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"column", never, SelectionSet<T>>;

  /**
   * @description The card content item
   */

  readonly content: <T extends Array<Selection>>(
    select: (t: ProjectCardItemSelector) => T
  ) => Field<"content", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The actor who created this card
   */

  readonly creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the card is archived
   */

  readonly isArchived: () => Field<"isArchived">;

  /**
   * @description The card note
   */

  readonly note: () => Field<"note">;

  /**
   * @description The project that contains this card.
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this card
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The state of ProjectCard
   */

  readonly state: () => Field<"state">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this card
   */

  readonly url: () => Field<"url">;
}

export const isProjectCard = (
  object: Record<string, any>
): object is Partial<IProjectCard> => {
  return object.__typename === "ProjectCard";
};

export const ProjectCard: ProjectCardSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description The project column this card is associated under. A card may only belong to one
project column at a time. The column field will be null if the card is created
in a pending state and has yet to be associated with a column. Once cards are
associated with a column, they will not become pending in the future.
     */

  column: (select) =>
    new Field(
      "column",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),

  /**
   * @description The card content item
   */

  content: (select) =>
    new Field(
      "content",
      undefined as never,
      new SelectionSet(select(ProjectCardItem))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The actor who created this card
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description Whether the card is archived
   */
  isArchived: () => new Field("isArchived"),

  /**
   * @description The card note
   */
  note: () => new Field("note"),

  /**
   * @description The project that contains this card.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description The HTTP path for this card
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The state of ProjectCard
   */
  state: () => new Field("state"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this card
   */
  url: () => new Field("url"),
};

export interface IProjectCardConnection {
  readonly __typename: "ProjectCardConnection";
  readonly edges: ReadonlyArray<IProjectCardEdge> | null;
  readonly nodes: ReadonlyArray<IProjectCard> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ProjectCardConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ProjectCardEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ProjectCardSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ProjectCardConnection: ProjectCardConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ProjectCardEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ProjectCard))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IProjectCardEdge {
  readonly __typename: "ProjectCardEdge";
  readonly cursor: string;
  readonly node: IProjectCard | null;
}

interface ProjectCardEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ProjectCardSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ProjectCardEdge: ProjectCardEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ProjectCard))
    ),
};

export interface IProjectColumn extends INode {
  readonly __typename: "ProjectColumn";
  readonly cards: IProjectCardConnection;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly name: string;
  readonly project: IProject;
  readonly purpose: ProjectColumnPurpose | null;
  readonly resourcePath: unknown;
  readonly updatedAt: unknown;
  readonly url: unknown;
}

interface ProjectColumnSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description List of cards in the column
   */

  readonly cards: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      archivedStates?: Variable<"archivedStates"> | ProjectCardArchivedState;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectCardConnectionSelector) => T
  ) => Field<
    "cards",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<
        "archivedStates",
        Variable<"archivedStates"> | ProjectCardArchivedState
      >,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description The project column's name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The project that contains this column.
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;

  /**
   * @description The semantic purpose of the column
   */

  readonly purpose: () => Field<"purpose">;

  /**
   * @description The HTTP path for this project column
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this project column
   */

  readonly url: () => Field<"url">;
}

export const isProjectColumn = (
  object: Record<string, any>
): object is Partial<IProjectColumn> => {
  return object.__typename === "ProjectColumn";
};

export const ProjectColumn: ProjectColumnSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description List of cards in the column
   */

  cards: (variables, select) =>
    new Field(
      "cards",
      [
        new Argument("after", variables.after),
        new Argument(
          "archivedStates",
          variables.archivedStates,
          ProjectCardArchivedState
        ),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectCardConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The project column's name.
   */
  name: () => new Field("name"),

  /**
   * @description The project that contains this column.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description The semantic purpose of the column
   */
  purpose: () => new Field("purpose"),

  /**
   * @description The HTTP path for this project column
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this project column
   */
  url: () => new Field("url"),
};

export interface IProjectColumnConnection {
  readonly __typename: "ProjectColumnConnection";
  readonly edges: ReadonlyArray<IProjectColumnEdge> | null;
  readonly nodes: ReadonlyArray<IProjectColumn> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ProjectColumnConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ProjectColumnEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ProjectColumnConnection: ProjectColumnConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ProjectColumnEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IProjectColumnEdge {
  readonly __typename: "ProjectColumnEdge";
  readonly cursor: string;
  readonly node: IProjectColumn | null;
}

interface ProjectColumnEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ProjectColumnEdge: ProjectColumnEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),
};

export interface IProjectConnection {
  readonly __typename: "ProjectConnection";
  readonly edges: ReadonlyArray<IProjectEdge> | null;
  readonly nodes: ReadonlyArray<IProject> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ProjectConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ProjectEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ProjectConnection: ProjectConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ProjectEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IProjectEdge {
  readonly __typename: "ProjectEdge";
  readonly cursor: string;
  readonly node: IProject | null;
}

interface ProjectEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ProjectEdge: ProjectEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Project))),
};

export interface IProjectOwner {
  readonly __typename: string;
  readonly id: string;
  readonly project: IProject | null;
  readonly projects: IProjectConnection;
  readonly projectsResourcePath: unknown;
  readonly projectsUrl: unknown;
  readonly viewerCanCreateProjects: boolean;
}

interface ProjectOwnerSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description Find project by number.
   */

  readonly project: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: ProjectSelector) => T
  ) => Field<
    "project",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of projects under the owner.
   */

  readonly projects: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ProjectOrder;
      search?: Variable<"search"> | string;
      states?: Variable<"states"> | ProjectState;
    },
    select: (t: ProjectConnectionSelector) => T
  ) => Field<
    "projects",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ProjectOrder>,
      Argument<"search", Variable<"search"> | string>,
      Argument<"states", Variable<"states"> | ProjectState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing owners projects
   */

  readonly projectsResourcePath: () => Field<"projectsResourcePath">;

  /**
   * @description The HTTP URL listing owners projects
   */

  readonly projectsUrl: () => Field<"projectsUrl">;

  /**
   * @description Can the current viewer create new projects on this owner.
   */

  readonly viewerCanCreateProjects: () => Field<"viewerCanCreateProjects">;

  readonly on: <
    T extends Array<Selection>,
    F extends "Organization" | "Repository" | "User"
  >(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const ProjectOwner: ProjectOwnerSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Find project by number.
   */

  project: (variables, select) =>
    new Field(
      "project",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Project))
    ),

  /**
   * @description A list of projects under the owner.
   */

  projects: (variables, select) =>
    new Field(
      "projects",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("search", variables.search),
        new Argument("states", variables.states, ProjectState),
      ],
      new SelectionSet(select(ProjectConnection))
    ),

  /**
   * @description The HTTP path listing owners projects
   */
  projectsResourcePath: () => new Field("projectsResourcePath"),

  /**
   * @description The HTTP URL listing owners projects
   */
  projectsUrl: () => new Field("projectsUrl"),

  /**
   * @description Can the current viewer create new projects on this owner.
   */
  viewerCanCreateProjects: () => new Field("viewerCanCreateProjects"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "ProjectOwner",
        });
    }
  },
};

export interface IProjectProgress {
  readonly __typename: "ProjectProgress";
  readonly doneCount: number;
  readonly donePercentage: number;
  readonly enabled: boolean;
  readonly inProgressCount: number;
  readonly inProgressPercentage: number;
  readonly todoCount: number;
  readonly todoPercentage: number;
}

interface ProjectProgressSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The number of done cards.
   */

  readonly doneCount: () => Field<"doneCount">;

  /**
   * @description The percentage of done cards.
   */

  readonly donePercentage: () => Field<"donePercentage">;

  /**
   * @description Whether progress tracking is enabled and cards with purpose exist for this project
   */

  readonly enabled: () => Field<"enabled">;

  /**
   * @description The number of in-progress cards.
   */

  readonly inProgressCount: () => Field<"inProgressCount">;

  /**
   * @description The percentage of in-progress cards.
   */

  readonly inProgressPercentage: () => Field<"inProgressPercentage">;

  /**
   * @description The number of to do cards.
   */

  readonly todoCount: () => Field<"todoCount">;

  /**
   * @description The percentage of to do cards.
   */

  readonly todoPercentage: () => Field<"todoPercentage">;
}

export const ProjectProgress: ProjectProgressSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The number of done cards.
   */
  doneCount: () => new Field("doneCount"),

  /**
   * @description The percentage of done cards.
   */
  donePercentage: () => new Field("donePercentage"),

  /**
   * @description Whether progress tracking is enabled and cards with purpose exist for this project
   */
  enabled: () => new Field("enabled"),

  /**
   * @description The number of in-progress cards.
   */
  inProgressCount: () => new Field("inProgressCount"),

  /**
   * @description The percentage of in-progress cards.
   */
  inProgressPercentage: () => new Field("inProgressPercentage"),

  /**
   * @description The number of to do cards.
   */
  todoCount: () => new Field("todoCount"),

  /**
   * @description The percentage of to do cards.
   */
  todoPercentage: () => new Field("todoPercentage"),
};

export interface IPublicKey extends INode {
  readonly __typename: "PublicKey";
  readonly accessedAt: unknown | null;
  readonly createdAt: unknown | null;
  readonly fingerprint: string;
  readonly isReadOnly: boolean | null;
  readonly key: string;
  readonly updatedAt: unknown | null;
}

interface PublicKeySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The last time this authorization was used to perform an action. Values will be null for keys not owned by the user.
   */

  readonly accessedAt: () => Field<"accessedAt">;

  /**
     * @description Identifies the date and time when the key was created. Keys created before
March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
     */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The fingerprint for this PublicKey.
   */

  readonly fingerprint: () => Field<"fingerprint">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user.
   */

  readonly isReadOnly: () => Field<"isReadOnly">;

  /**
   * @description The public key string.
   */

  readonly key: () => Field<"key">;

  /**
     * @description Identifies the date and time when the key was updated. Keys created before
March 5th, 2014 may have inaccurate values. Values will be null for keys not
owned by the user.
     */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const isPublicKey = (
  object: Record<string, any>
): object is Partial<IPublicKey> => {
  return object.__typename === "PublicKey";
};

export const PublicKey: PublicKeySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The last time this authorization was used to perform an action. Values will be null for keys not owned by the user.
   */
  accessedAt: () => new Field("accessedAt"),

  /**
     * @description Identifies the date and time when the key was created. Keys created before
March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
     */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The fingerprint for this PublicKey.
   */
  fingerprint: () => new Field("fingerprint"),
  id: () => new Field("id"),

  /**
   * @description Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user.
   */
  isReadOnly: () => new Field("isReadOnly"),

  /**
   * @description The public key string.
   */
  key: () => new Field("key"),

  /**
     * @description Identifies the date and time when the key was updated. Keys created before
March 5th, 2014 may have inaccurate values. Values will be null for keys not
owned by the user.
     */
  updatedAt: () => new Field("updatedAt"),
};

export interface IPublicKeyConnection {
  readonly __typename: "PublicKeyConnection";
  readonly edges: ReadonlyArray<IPublicKeyEdge> | null;
  readonly nodes: ReadonlyArray<IPublicKey> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PublicKeyConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PublicKeyEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PublicKeySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PublicKeyConnection: PublicKeyConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PublicKeyEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(PublicKey))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPublicKeyEdge {
  readonly __typename: "PublicKeyEdge";
  readonly cursor: string;
  readonly node: IPublicKey | null;
}

interface PublicKeyEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PublicKeySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PublicKeyEdge: PublicKeyEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(PublicKey))),
};

export interface IPullRequest
  extends IAssignable,
    IClosable,
    IComment,
    ILabelable,
    ILockable,
    INode,
    IReactable,
    IRepositoryNode,
    ISubscribable,
    IUniformResourceLocatable,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "PullRequest";
  readonly additions: number;
  readonly baseRef: IRef | null;
  readonly baseRefName: string;
  readonly baseRefOid: unknown;
  readonly baseRepository: IRepository | null;
  readonly changedFiles: number;
  readonly checksResourcePath: unknown;
  readonly checksUrl: unknown;
  readonly comments: IIssueCommentConnection;
  readonly commits: IPullRequestCommitConnection;
  readonly deletions: number;
  readonly files: IPullRequestChangedFileConnection | null;
  readonly headRef: IRef | null;
  readonly headRefName: string;
  readonly headRefOid: unknown;
  readonly headRepository: IRepository | null;
  readonly headRepositoryOwner: IRepositoryOwner | null;
  readonly hovercard: IHovercard;
  readonly isCrossRepository: boolean;
  readonly isDraft: boolean;
  readonly isReadByViewer: boolean | null;
  readonly latestOpinionatedReviews: IPullRequestReviewConnection | null;
  readonly latestReviews: IPullRequestReviewConnection | null;
  readonly maintainerCanModify: boolean;
  readonly mergeCommit: ICommit | null;
  readonly mergeable: MergeableState;
  readonly merged: boolean;
  readonly mergedAt: unknown | null;
  readonly mergedBy: IActor | null;
  readonly milestone: IMilestone | null;
  readonly number: number;
  readonly participants: IUserConnection;
  readonly permalink: unknown;
  readonly potentialMergeCommit: ICommit | null;
  readonly projectCards: IProjectCardConnection;
  readonly revertResourcePath: unknown;
  readonly revertUrl: unknown;
  readonly reviewDecision: PullRequestReviewDecision | null;
  readonly reviewRequests: IReviewRequestConnection | null;
  readonly reviewThreads: IPullRequestReviewThreadConnection;
  readonly reviews: IPullRequestReviewConnection | null;
  readonly state: PullRequestState;
  readonly suggestedReviewers: ReadonlyArray<ISuggestedReviewer>;
  readonly timeline: IPullRequestTimelineConnection;
  readonly timelineItems: IPullRequestTimelineItemsConnection;
  readonly title: string;
  readonly viewerCanApplySuggestion: boolean;
  readonly viewerCanDeleteHeadRef: boolean;
  readonly viewerMergeBodyText: string;
  readonly viewerMergeHeadlineText: string;
}

interface PullRequestSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Reason that the conversation was locked.
   */

  readonly activeLockReason: () => Field<"activeLockReason">;

  /**
   * @description The number of additions in this pull request.
   */

  readonly additions: () => Field<"additions">;

  /**
   * @description A list of Users assigned to this object.
   */

  readonly assignees: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "assignees",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Identifies the base Ref associated with the pull request.
   */

  readonly baseRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"baseRef", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted.
   */

  readonly baseRefName: () => Field<"baseRefName">;

  /**
   * @description Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted.
   */

  readonly baseRefOid: () => Field<"baseRefOid">;

  /**
   * @description The repository associated with this pull request's base Ref.
   */

  readonly baseRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"baseRepository", never, SelectionSet<T>>;

  /**
   * @description The body as Markdown.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description The number of changed files in this pull request.
   */

  readonly changedFiles: () => Field<"changedFiles">;

  /**
   * @description The HTTP path for the checks of this pull request.
   */

  readonly checksResourcePath: () => Field<"checksResourcePath">;

  /**
   * @description The HTTP URL for the checks of this pull request.
   */

  readonly checksUrl: () => Field<"checksUrl">;

  /**
   * @description `true` if the pull request is closed
   */

  readonly closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  readonly closedAt: () => Field<"closedAt">;

  /**
   * @description A list of comments associated with the pull request.
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueCommentOrder;
    },
    select: (t: IssueCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueCommentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of commits present in this pull request's head branch not present in the base branch.
   */

  readonly commits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestCommitConnectionSelector) => T
  ) => Field<
    "commits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The number of deletions in this pull request.
   */

  readonly deletions: () => Field<"deletions">;

  /**
   * @description The actor who edited this pull request's body.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  /**
   * @description Lists the files changed within this pull request.
   */

  readonly files: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestChangedFileConnectionSelector) => T
  ) => Field<
    "files",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the head Ref associated with the pull request.
   */

  readonly headRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"headRef", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted.
   */

  readonly headRefName: () => Field<"headRefName">;

  /**
   * @description Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted.
   */

  readonly headRefOid: () => Field<"headRefOid">;

  /**
   * @description The repository associated with this pull request's head Ref.
   */

  readonly headRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"headRepository", never, SelectionSet<T>>;

  /**
   * @description The owner of the repository associated with this pull request's head Ref.
   */

  readonly headRepositoryOwner: <T extends Array<Selection>>(
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<"headRepositoryOwner", never, SelectionSet<T>>;

  /**
   * @description The hovercard information for this issue
   */

  readonly hovercard: <T extends Array<Selection>>(
    variables: {
      includeNotificationContexts?:
        | Variable<"includeNotificationContexts">
        | boolean;
    },
    select: (t: HovercardSelector) => T
  ) => Field<
    "hovercard",
    [
      Argument<
        "includeNotificationContexts",
        Variable<"includeNotificationContexts"> | boolean
      >
    ],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description The head and base repositories are different.
   */

  readonly isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Identifies if the pull request is a draft.
   */

  readonly isDraft: () => Field<"isDraft">;

  /**
   * @description Is this pull request read by the viewer
   */

  readonly isReadByViewer: () => Field<"isReadByViewer">;

  /**
   * @description A list of labels associated with the object.
   */

  readonly labels: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LabelOrder;
    },
    select: (t: LabelConnectionSelector) => T
  ) => Field<
    "labels",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LabelOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description A list of latest reviews per user associated with the pull request.
   */

  readonly latestOpinionatedReviews: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      writersOnly?: Variable<"writersOnly"> | boolean;
    },
    select: (t: PullRequestReviewConnectionSelector) => T
  ) => Field<
    "latestOpinionatedReviews",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"writersOnly", Variable<"writersOnly"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of latest reviews per user associated with the pull request that are not also pending review.
   */

  readonly latestReviews: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestReviewConnectionSelector) => T
  ) => Field<
    "latestReviews",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description `true` if the pull request is locked
   */

  readonly locked: () => Field<"locked">;

  /**
   * @description Indicates whether maintainers can modify the pull request.
   */

  readonly maintainerCanModify: () => Field<"maintainerCanModify">;

  /**
   * @description The commit that was created when this pull request was merged.
   */

  readonly mergeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"mergeCommit", never, SelectionSet<T>>;

  /**
   * @description Whether or not the pull request can be merged based on the existence of merge conflicts.
   */

  readonly mergeable: () => Field<"mergeable">;

  /**
   * @description Whether or not the pull request was merged.
   */

  readonly merged: () => Field<"merged">;

  /**
   * @description The date and time that the pull request was merged.
   */

  readonly mergedAt: () => Field<"mergedAt">;

  /**
   * @description The actor who merged the pull request.
   */

  readonly mergedBy: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"mergedBy", never, SelectionSet<T>>;

  /**
   * @description Identifies the milestone associated with the pull request.
   */

  readonly milestone: <T extends Array<Selection>>(
    select: (t: MilestoneSelector) => T
  ) => Field<"milestone", never, SelectionSet<T>>;

  /**
   * @description Identifies the pull request number.
   */

  readonly number: () => Field<"number">;

  /**
   * @description A list of Users that are participating in the Pull Request conversation.
   */

  readonly participants: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "participants",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The permalink to the pull request.
   */

  readonly permalink: () => Field<"permalink">;

  /**
     * @description The commit that GitHub automatically generated to test if this pull request
could be merged. This field will not return a value if the pull request is
merged, or if the test merge commit is still being generated. See the
`mergeable` field for more details on the mergeability of the pull request.
     */

  readonly potentialMergeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"potentialMergeCommit", never, SelectionSet<T>>;

  /**
   * @description List of project cards associated with this pull request.
   */

  readonly projectCards: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      archivedStates?: Variable<"archivedStates"> | ProjectCardArchivedState;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectCardConnectionSelector) => T
  ) => Field<
    "projectCards",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<
        "archivedStates",
        Variable<"archivedStates"> | ProjectCardArchivedState
      >,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this pull request.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP path for reverting this pull request.
   */

  readonly revertResourcePath: () => Field<"revertResourcePath">;

  /**
   * @description The HTTP URL for reverting this pull request.
   */

  readonly revertUrl: () => Field<"revertUrl">;

  /**
   * @description The current status of this pull request with respect to code review.
   */

  readonly reviewDecision: () => Field<"reviewDecision">;

  /**
   * @description A list of review requests associated with the pull request.
   */

  readonly reviewRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ReviewRequestConnectionSelector) => T
  ) => Field<
    "reviewRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The list of all review threads for this pull request.
   */

  readonly reviewThreads: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestReviewThreadConnectionSelector) => T
  ) => Field<
    "reviewThreads",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of reviews associated with the pull request.
   */

  readonly reviews: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      author?: Variable<"author"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      states?: Variable<"states"> | PullRequestReviewState;
    },
    select: (t: PullRequestReviewConnectionSelector) => T
  ) => Field<
    "reviews",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"author", Variable<"author"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"states", Variable<"states"> | PullRequestReviewState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the state of the pull request.
   */

  readonly state: () => Field<"state">;

  /**
   * @description A list of reviewer suggestions based on commit history and past review comments.
   */

  readonly suggestedReviewers: <T extends Array<Selection>>(
    select: (t: SuggestedReviewerSelector) => T
  ) => Field<"suggestedReviewers", never, SelectionSet<T>>;

  /**
   * @description A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */

  readonly timeline: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      since?: Variable<"since"> | unknown;
    },
    select: (t: PullRequestTimelineConnectionSelector) => T
  ) => Field<
    "timeline",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"since", Variable<"since"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of events, comments, commits, etc. associated with the pull request.
   */

  readonly timelineItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      itemTypes?: Variable<"itemTypes"> | PullRequestTimelineItemsItemType;
      last?: Variable<"last"> | number;
      since?: Variable<"since"> | unknown;
      skip?: Variable<"skip"> | number;
    },
    select: (t: PullRequestTimelineItemsConnectionSelector) => T
  ) => Field<
    "timelineItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<
        "itemTypes",
        Variable<"itemTypes"> | PullRequestTimelineItemsItemType
      >,
      Argument<"last", Variable<"last"> | number>,
      Argument<"since", Variable<"since"> | unknown>,
      Argument<"skip", Variable<"skip"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the pull request title.
   */

  readonly title: () => Field<"title">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this pull request.
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not the viewer can apply suggestion.
   */

  readonly viewerCanApplySuggestion: () => Field<"viewerCanApplySuggestion">;

  /**
   * @description Check if the viewer can restore the deleted head ref.
   */

  readonly viewerCanDeleteHeadRef: () => Field<"viewerCanDeleteHeadRef">;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  readonly viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;

  /**
   * @description The merge body text for the viewer and method.
   */

  readonly viewerMergeBodyText: (variables: {
    mergeType?: Variable<"mergeType"> | PullRequestMergeMethod;
  }) => Field<
    "viewerMergeBodyText",
    [Argument<"mergeType", Variable<"mergeType"> | PullRequestMergeMethod>]
  >;

  /**
   * @description The merge headline text for the viewer and method.
   */

  readonly viewerMergeHeadlineText: (variables: {
    mergeType?: Variable<"mergeType"> | PullRequestMergeMethod;
  }) => Field<
    "viewerMergeHeadlineText",
    [Argument<"mergeType", Variable<"mergeType"> | PullRequestMergeMethod>]
  >;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  readonly viewerSubscription: () => Field<"viewerSubscription">;
}

export const isPullRequest = (
  object: Record<string, any>
): object is Partial<IPullRequest> => {
  return object.__typename === "PullRequest";
};

export const PullRequest: PullRequestSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Reason that the conversation was locked.
   */
  activeLockReason: () => new Field("activeLockReason"),

  /**
   * @description The number of additions in this pull request.
   */
  additions: () => new Field("additions"),

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: (variables, select) =>
    new Field(
      "assignees",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Identifies the base Ref associated with the pull request.
   */

  baseRef: (select) =>
    new Field("baseRef", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted.
   */
  baseRefName: () => new Field("baseRefName"),

  /**
   * @description Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted.
   */
  baseRefOid: () => new Field("baseRefOid"),

  /**
   * @description The repository associated with this pull request's base Ref.
   */

  baseRepository: (select) =>
    new Field(
      "baseRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description The number of changed files in this pull request.
   */
  changedFiles: () => new Field("changedFiles"),

  /**
   * @description The HTTP path for the checks of this pull request.
   */
  checksResourcePath: () => new Field("checksResourcePath"),

  /**
   * @description The HTTP URL for the checks of this pull request.
   */
  checksUrl: () => new Field("checksUrl"),

  /**
   * @description `true` if the pull request is closed
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  /**
   * @description A list of comments associated with the pull request.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IssueCommentConnection))
    ),

  /**
   * @description A list of commits present in this pull request's head branch not present in the base branch.
   */

  commits: (variables, select) =>
    new Field(
      "commits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestCommitConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The number of deletions in this pull request.
   */
  deletions: () => new Field("deletions"),

  /**
   * @description The actor who edited this pull request's body.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Lists the files changed within this pull request.
   */

  files: (variables, select) =>
    new Field(
      "files",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestChangedFileConnection))
    ),

  /**
   * @description Identifies the head Ref associated with the pull request.
   */

  headRef: (select) =>
    new Field("headRef", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted.
   */
  headRefName: () => new Field("headRefName"),

  /**
   * @description Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted.
   */
  headRefOid: () => new Field("headRefOid"),

  /**
   * @description The repository associated with this pull request's head Ref.
   */

  headRepository: (select) =>
    new Field(
      "headRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The owner of the repository associated with this pull request's head Ref.
   */

  headRepositoryOwner: (select) =>
    new Field(
      "headRepositoryOwner",
      undefined as never,
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description The hovercard information for this issue
   */

  hovercard: (variables, select) =>
    new Field(
      "hovercard",
      [
        new Argument(
          "includeNotificationContexts",
          variables.includeNotificationContexts
        ),
      ],
      new SelectionSet(select(Hovercard))
    ),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description The head and base repositories are different.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Identifies if the pull request is a draft.
   */
  isDraft: () => new Field("isDraft"),

  /**
   * @description Is this pull request read by the viewer
   */
  isReadByViewer: () => new Field("isReadByViewer"),

  /**
   * @description A list of labels associated with the object.
   */

  labels: (variables, select) =>
    new Field(
      "labels",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(LabelConnection))
    ),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description A list of latest reviews per user associated with the pull request.
   */

  latestOpinionatedReviews: (variables, select) =>
    new Field(
      "latestOpinionatedReviews",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("writersOnly", variables.writersOnly),
      ],
      new SelectionSet(select(PullRequestReviewConnection))
    ),

  /**
   * @description A list of latest reviews per user associated with the pull request that are not also pending review.
   */

  latestReviews: (variables, select) =>
    new Field(
      "latestReviews",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestReviewConnection))
    ),

  /**
   * @description `true` if the pull request is locked
   */
  locked: () => new Field("locked"),

  /**
   * @description Indicates whether maintainers can modify the pull request.
   */
  maintainerCanModify: () => new Field("maintainerCanModify"),

  /**
   * @description The commit that was created when this pull request was merged.
   */

  mergeCommit: (select) =>
    new Field(
      "mergeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Whether or not the pull request can be merged based on the existence of merge conflicts.
   */
  mergeable: () => new Field("mergeable"),

  /**
   * @description Whether or not the pull request was merged.
   */
  merged: () => new Field("merged"),

  /**
   * @description The date and time that the pull request was merged.
   */
  mergedAt: () => new Field("mergedAt"),

  /**
   * @description The actor who merged the pull request.
   */

  mergedBy: (select) =>
    new Field("mergedBy", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the milestone associated with the pull request.
   */

  milestone: (select) =>
    new Field(
      "milestone",
      undefined as never,
      new SelectionSet(select(Milestone))
    ),

  /**
   * @description Identifies the pull request number.
   */
  number: () => new Field("number"),

  /**
   * @description A list of Users that are participating in the Pull Request conversation.
   */

  participants: (variables, select) =>
    new Field(
      "participants",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description The permalink to the pull request.
   */
  permalink: () => new Field("permalink"),

  /**
     * @description The commit that GitHub automatically generated to test if this pull request
could be merged. This field will not return a value if the pull request is
merged, or if the test merge commit is still being generated. See the
`mergeable` field for more details on the mergeability of the pull request.
     */

  potentialMergeCommit: (select) =>
    new Field(
      "potentialMergeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description List of project cards associated with this pull request.
   */

  projectCards: (variables, select) =>
    new Field(
      "projectCards",
      [
        new Argument("after", variables.after),
        new Argument(
          "archivedStates",
          variables.archivedStates,
          ProjectCardArchivedState
        ),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectCardConnection))
    ),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this pull request.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP path for reverting this pull request.
   */
  revertResourcePath: () => new Field("revertResourcePath"),

  /**
   * @description The HTTP URL for reverting this pull request.
   */
  revertUrl: () => new Field("revertUrl"),

  /**
   * @description The current status of this pull request with respect to code review.
   */
  reviewDecision: () => new Field("reviewDecision"),

  /**
   * @description A list of review requests associated with the pull request.
   */

  reviewRequests: (variables, select) =>
    new Field(
      "reviewRequests",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ReviewRequestConnection))
    ),

  /**
   * @description The list of all review threads for this pull request.
   */

  reviewThreads: (variables, select) =>
    new Field(
      "reviewThreads",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestReviewThreadConnection))
    ),

  /**
   * @description A list of reviews associated with the pull request.
   */

  reviews: (variables, select) =>
    new Field(
      "reviews",
      [
        new Argument("after", variables.after),
        new Argument("author", variables.author),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("states", variables.states, PullRequestReviewState),
      ],
      new SelectionSet(select(PullRequestReviewConnection))
    ),

  /**
   * @description Identifies the state of the pull request.
   */
  state: () => new Field("state"),

  /**
   * @description A list of reviewer suggestions based on commit history and past review comments.
   */

  suggestedReviewers: (select) =>
    new Field(
      "suggestedReviewers",
      undefined as never,
      new SelectionSet(select(SuggestedReviewer))
    ),

  /**
   * @description A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */

  timeline: (variables, select) =>
    new Field(
      "timeline",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("since", variables.since),
      ],
      new SelectionSet(select(PullRequestTimelineConnection))
    ),

  /**
   * @description A list of events, comments, commits, etc. associated with the pull request.
   */

  timelineItems: (variables, select) =>
    new Field(
      "timelineItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument(
          "itemTypes",
          variables.itemTypes,
          PullRequestTimelineItemsItemType
        ),
        new Argument("last", variables.last),
        new Argument("since", variables.since),
        new Argument("skip", variables.skip),
      ],
      new SelectionSet(select(PullRequestTimelineItemsConnection))
    ),

  /**
   * @description Identifies the pull request title.
   */
  title: () => new Field("title"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this pull request.
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Whether or not the viewer can apply suggestion.
   */
  viewerCanApplySuggestion: () => new Field("viewerCanApplySuggestion"),

  /**
   * @description Check if the viewer can restore the deleted head ref.
   */
  viewerCanDeleteHeadRef: () => new Field("viewerCanDeleteHeadRef"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),

  /**
   * @description The merge body text for the viewer and method.
   */
  viewerMergeBodyText: (variables) => new Field("viewerMergeBodyText"),

  /**
   * @description The merge headline text for the viewer and method.
   */
  viewerMergeHeadlineText: (variables) => new Field("viewerMergeHeadlineText"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),
};

export interface IPullRequestChangedFile {
  readonly __typename: "PullRequestChangedFile";
  readonly additions: number;
  readonly deletions: number;
  readonly path: string;
  readonly viewerViewedState: FileViewedState;
}

interface PullRequestChangedFileSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The number of additions to the file.
   */

  readonly additions: () => Field<"additions">;

  /**
   * @description The number of deletions to the file.
   */

  readonly deletions: () => Field<"deletions">;

  /**
   * @description The path of the file.
   */

  readonly path: () => Field<"path">;

  /**
   * @description The state of the file for the viewer.
   */

  readonly viewerViewedState: () => Field<"viewerViewedState">;
}

export const PullRequestChangedFile: PullRequestChangedFileSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The number of additions to the file.
   */
  additions: () => new Field("additions"),

  /**
   * @description The number of deletions to the file.
   */
  deletions: () => new Field("deletions"),

  /**
   * @description The path of the file.
   */
  path: () => new Field("path"),

  /**
   * @description The state of the file for the viewer.
   */
  viewerViewedState: () => new Field("viewerViewedState"),
};

export interface IPullRequestChangedFileConnection {
  readonly __typename: "PullRequestChangedFileConnection";
  readonly edges: ReadonlyArray<IPullRequestChangedFileEdge> | null;
  readonly nodes: ReadonlyArray<IPullRequestChangedFile> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PullRequestChangedFileConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PullRequestChangedFileEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PullRequestChangedFileSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PullRequestChangedFileConnection: PullRequestChangedFileConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestChangedFileEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestChangedFile))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestChangedFileEdge {
  readonly __typename: "PullRequestChangedFileEdge";
  readonly cursor: string;
  readonly node: IPullRequestChangedFile | null;
}

interface PullRequestChangedFileEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PullRequestChangedFileSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestChangedFileEdge: PullRequestChangedFileEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestChangedFile))
    ),
};

export interface IPullRequestCommit extends INode, IUniformResourceLocatable {
  readonly __typename: "PullRequestCommit";
  readonly commit: ICommit;
  readonly pullRequest: IPullRequest;
}

interface PullRequestCommitSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The Git commit object
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The pull request this commit belongs to
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this pull request commit
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this pull request commit
   */

  readonly url: () => Field<"url">;
}

export const isPullRequestCommit = (
  object: Record<string, any>
): object is Partial<IPullRequestCommit> => {
  return object.__typename === "PullRequestCommit";
};

export const PullRequestCommit: PullRequestCommitSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The Git commit object
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  id: () => new Field("id"),

  /**
   * @description The pull request this commit belongs to
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this pull request commit
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this pull request commit
   */
  url: () => new Field("url"),
};

export interface IPullRequestCommitCommentThread
  extends INode,
    IRepositoryNode {
  readonly __typename: "PullRequestCommitCommentThread";
  readonly comments: ICommitCommentConnection;
  readonly commit: ICommit;
  readonly path: string | null;
  readonly position: number | null;
  readonly pullRequest: IPullRequest;
}

interface PullRequestCommitCommentThreadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The comments that exist in this thread.
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The commit the comments were made on.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The file the comments were made on.
   */

  readonly path: () => Field<"path">;

  /**
   * @description The position in the diff for the commit that the comment was made on.
   */

  readonly position: () => Field<"position">;

  /**
   * @description The pull request this commit comment thread belongs to
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isPullRequestCommitCommentThread = (
  object: Record<string, any>
): object is Partial<IPullRequestCommitCommentThread> => {
  return object.__typename === "PullRequestCommitCommentThread";
};

export const PullRequestCommitCommentThread: PullRequestCommitCommentThreadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The comments that exist in this thread.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description The commit the comments were made on.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  id: () => new Field("id"),

  /**
   * @description The file the comments were made on.
   */
  path: () => new Field("path"),

  /**
   * @description The position in the diff for the commit that the comment was made on.
   */
  position: () => new Field("position"),

  /**
   * @description The pull request this commit comment thread belongs to
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IPullRequestCommitConnection {
  readonly __typename: "PullRequestCommitConnection";
  readonly edges: ReadonlyArray<IPullRequestCommitEdge> | null;
  readonly nodes: ReadonlyArray<IPullRequestCommit> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PullRequestCommitConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PullRequestCommitEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PullRequestCommitSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PullRequestCommitConnection: PullRequestCommitConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestCommitEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestCommit))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestCommitEdge {
  readonly __typename: "PullRequestCommitEdge";
  readonly cursor: string;
  readonly node: IPullRequestCommit | null;
}

interface PullRequestCommitEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PullRequestCommitSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestCommitEdge: PullRequestCommitEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestCommit))
    ),
};

export interface IPullRequestConnection {
  readonly __typename: "PullRequestConnection";
  readonly edges: ReadonlyArray<IPullRequestEdge> | null;
  readonly nodes: ReadonlyArray<IPullRequest> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PullRequestConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PullRequestEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PullRequestConnection: PullRequestConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestContributionsByRepository {
  readonly __typename: "PullRequestContributionsByRepository";
  readonly contributions: ICreatedPullRequestContributionConnection;
  readonly repository: IRepository;
}

interface PullRequestContributionsByRepositorySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The pull request contributions.
   */

  readonly contributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedPullRequestContributionConnectionSelector) => T
  ) => Field<
    "contributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository in which the pull requests were opened.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const PullRequestContributionsByRepository: PullRequestContributionsByRepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The pull request contributions.
   */

  contributions: (variables, select) =>
    new Field(
      "contributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedPullRequestContributionConnection))
    ),

  /**
   * @description The repository in which the pull requests were opened.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IPullRequestEdge {
  readonly __typename: "PullRequestEdge";
  readonly cursor: string;
  readonly node: IPullRequest | null;
}

interface PullRequestEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestEdge: PullRequestEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IPullRequestReview
  extends IComment,
    IDeletable,
    INode,
    IReactable,
    IRepositoryNode,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "PullRequestReview";
  readonly authorCanPushToRepository: boolean;
  readonly comments: IPullRequestReviewCommentConnection;
  readonly commit: ICommit | null;
  readonly onBehalfOf: ITeamConnection;
  readonly pullRequest: IPullRequest;
  readonly resourcePath: unknown;
  readonly state: PullRequestReviewState;
  readonly submittedAt: unknown | null;
  readonly url: unknown;
}

interface PullRequestReviewSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Indicates whether the author of this review has push access to the repository.
   */

  readonly authorCanPushToRepository: () => Field<"authorCanPushToRepository">;

  /**
   * @description Identifies the pull request review body.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body of this review rendered as plain text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description A list of review comments for the current pull request review.
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestReviewCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the commit associated with this pull request review.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description A list of teams that this review was made on behalf of.
   */

  readonly onBehalfOf: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "onBehalfOf",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description Identifies the pull request associated with this pull request review.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path permalink for this PullRequestReview.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the current state of the pull request review.
   */

  readonly state: () => Field<"state">;

  /**
   * @description Identifies when the Pull Request Review was submitted
   */

  readonly submittedAt: () => Field<"submittedAt">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL permalink for this PullRequestReview.
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  readonly viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isPullRequestReview = (
  object: Record<string, any>
): object is Partial<IPullRequestReview> => {
  return object.__typename === "PullRequestReview";
};

export const PullRequestReview: PullRequestReviewSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Indicates whether the author of this review has push access to the repository.
   */
  authorCanPushToRepository: () => new Field("authorCanPushToRepository"),

  /**
   * @description Identifies the pull request review body.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body of this review rendered as plain text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description A list of review comments for the current pull request review.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestReviewCommentConnection))
    ),

  /**
   * @description Identifies the commit associated with this pull request review.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description A list of teams that this review was made on behalf of.
   */

  onBehalfOf: (variables, select) =>
    new Field(
      "onBehalfOf",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description Identifies the pull request associated with this pull request review.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path permalink for this PullRequestReview.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the current state of the pull request review.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies when the Pull Request Review was submitted
   */
  submittedAt: () => new Field("submittedAt"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL permalink for this PullRequestReview.
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface IPullRequestReviewComment
  extends IComment,
    IDeletable,
    IMinimizable,
    INode,
    IReactable,
    IRepositoryNode,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "PullRequestReviewComment";
  readonly commit: ICommit | null;
  readonly diffHunk: string;
  readonly draftedAt: unknown;
  readonly originalCommit: ICommit | null;
  readonly originalPosition: number;
  readonly outdated: boolean;
  readonly path: string;
  readonly position: number | null;
  readonly pullRequest: IPullRequest;
  readonly pullRequestReview: IPullRequestReview | null;
  readonly replyTo: IPullRequestReviewComment | null;
  readonly resourcePath: unknown;
  readonly state: PullRequestReviewCommentState;
  readonly url: unknown;
}

interface PullRequestReviewCommentSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The comment body of this review comment.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The comment body of this review comment rendered as plain text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the commit associated with the comment.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies when the comment was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The diff hunk to which the comment applies.
   */

  readonly diffHunk: () => Field<"diffHunk">;

  /**
   * @description Identifies when the comment was created in a draft state.
   */

  readonly draftedAt: () => Field<"draftedAt">;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  readonly isMinimized: () => Field<"isMinimized">;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Returns why the comment was minimized.
   */

  readonly minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Identifies the original commit associated with the comment.
   */

  readonly originalCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"originalCommit", never, SelectionSet<T>>;

  /**
   * @description The original line index in the diff to which the comment applies.
   */

  readonly originalPosition: () => Field<"originalPosition">;

  /**
   * @description Identifies when the comment body is outdated
   */

  readonly outdated: () => Field<"outdated">;

  /**
   * @description The path to which the comment applies.
   */

  readonly path: () => Field<"path">;

  /**
   * @description The line index in the diff to which the comment applies.
   */

  readonly position: () => Field<"position">;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description The pull request associated with this review comment.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The pull request review associated with this review comment.
   */

  readonly pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The comment this is a reply to.
   */

  readonly replyTo: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"replyTo", never, SelectionSet<T>>;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path permalink for this review comment.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the state of the comment.
   */

  readonly state: () => Field<"state">;

  /**
   * @description Identifies when the comment was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL permalink for this review comment.
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  readonly viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  readonly viewerCanMinimize: () => Field<"viewerCanMinimize">;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isPullRequestReviewComment = (
  object: Record<string, any>
): object is Partial<IPullRequestReviewComment> => {
  return object.__typename === "PullRequestReviewComment";
};

export const PullRequestReviewComment: PullRequestReviewCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The comment body of this review comment.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The comment body of this review comment rendered as plain text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the commit associated with the comment.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies when the comment was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The diff hunk to which the comment applies.
   */
  diffHunk: () => new Field("diffHunk"),

  /**
   * @description Identifies when the comment was created in a draft state.
   */
  draftedAt: () => new Field("draftedAt"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Identifies the original commit associated with the comment.
   */

  originalCommit: (select) =>
    new Field(
      "originalCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description The original line index in the diff to which the comment applies.
   */
  originalPosition: () => new Field("originalPosition"),

  /**
   * @description Identifies when the comment body is outdated
   */
  outdated: () => new Field("outdated"),

  /**
   * @description The path to which the comment applies.
   */
  path: () => new Field("path"),

  /**
   * @description The line index in the diff to which the comment applies.
   */
  position: () => new Field("position"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description The pull request associated with this review comment.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The pull request review associated with this review comment.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The comment this is a reply to.
   */

  replyTo: (select) =>
    new Field(
      "replyTo",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path permalink for this review comment.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the state of the comment.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies when the comment was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL permalink for this review comment.
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface IPullRequestReviewCommentConnection {
  readonly __typename: "PullRequestReviewCommentConnection";
  readonly edges: ReadonlyArray<IPullRequestReviewCommentEdge> | null;
  readonly nodes: ReadonlyArray<IPullRequestReviewComment> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PullRequestReviewCommentConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PullRequestReviewCommentConnection: PullRequestReviewCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestReviewCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestReviewCommentEdge {
  readonly __typename: "PullRequestReviewCommentEdge";
  readonly cursor: string;
  readonly node: IPullRequestReviewComment | null;
}

interface PullRequestReviewCommentEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestReviewCommentEdge: PullRequestReviewCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),
};

export interface IPullRequestReviewConnection {
  readonly __typename: "PullRequestReviewConnection";
  readonly edges: ReadonlyArray<IPullRequestReviewEdge> | null;
  readonly nodes: ReadonlyArray<IPullRequestReview> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PullRequestReviewConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PullRequestReviewEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PullRequestReviewConnection: PullRequestReviewConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestReviewEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestReviewContributionsByRepository {
  readonly __typename: "PullRequestReviewContributionsByRepository";
  readonly contributions: ICreatedPullRequestReviewContributionConnection;
  readonly repository: IRepository;
}

interface PullRequestReviewContributionsByRepositorySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The pull request review contributions.
   */

  readonly contributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedPullRequestReviewContributionConnectionSelector) => T
  ) => Field<
    "contributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository in which the pull request reviews were made.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const PullRequestReviewContributionsByRepository: PullRequestReviewContributionsByRepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The pull request review contributions.
   */

  contributions: (variables, select) =>
    new Field(
      "contributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedPullRequestReviewContributionConnection))
    ),

  /**
   * @description The repository in which the pull request reviews were made.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IPullRequestReviewEdge {
  readonly __typename: "PullRequestReviewEdge";
  readonly cursor: string;
  readonly node: IPullRequestReview | null;
}

interface PullRequestReviewEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestReviewEdge: PullRequestReviewEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IPullRequestReviewThread extends INode {
  readonly __typename: "PullRequestReviewThread";
  readonly comments: IPullRequestReviewCommentConnection;
  readonly diffSide: DiffSide;
  readonly isCollapsed: boolean;
  readonly isOutdated: boolean;
  readonly isResolved: boolean;
  readonly line: number | null;
  readonly originalLine: number | null;
  readonly originalStartLine: number | null;
  readonly path: string;
  readonly pullRequest: IPullRequest;
  readonly repository: IRepository;
  readonly resolvedBy: IUser | null;
  readonly startDiffSide: DiffSide | null;
  readonly startLine: number | null;
  readonly viewerCanReply: boolean;
  readonly viewerCanResolve: boolean;
  readonly viewerCanUnresolve: boolean;
}

interface PullRequestReviewThreadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of pull request comments associated with the thread.
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      skip?: Variable<"skip"> | number;
    },
    select: (t: PullRequestReviewCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"skip", Variable<"skip"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The side of the diff on which this thread was placed.
   */

  readonly diffSide: () => Field<"diffSide">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether or not the thread has been collapsed (outdated or resolved)
   */

  readonly isCollapsed: () => Field<"isCollapsed">;

  /**
   * @description Indicates whether this thread was outdated by newer changes.
   */

  readonly isOutdated: () => Field<"isOutdated">;

  /**
   * @description Whether this thread has been resolved
   */

  readonly isResolved: () => Field<"isResolved">;

  /**
   * @description The line in the file to which this thread refers
   */

  readonly line: () => Field<"line">;

  /**
   * @description The original line in the file to which this thread refers.
   */

  readonly originalLine: () => Field<"originalLine">;

  /**
   * @description The original start line in the file to which this thread refers (multi-line only).
   */

  readonly originalStartLine: () => Field<"originalStartLine">;

  /**
   * @description Identifies the file path of this thread.
   */

  readonly path: () => Field<"path">;

  /**
   * @description Identifies the pull request associated with this thread.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the repository associated with this thread.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The user who resolved this thread
   */

  readonly resolvedBy: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"resolvedBy", never, SelectionSet<T>>;

  /**
   * @description The side of the diff that the first line of the thread starts on (multi-line only)
   */

  readonly startDiffSide: () => Field<"startDiffSide">;

  /**
   * @description The start line in the file to which this thread refers (multi-line only)
   */

  readonly startLine: () => Field<"startLine">;

  /**
   * @description Indicates whether the current viewer can reply to this thread.
   */

  readonly viewerCanReply: () => Field<"viewerCanReply">;

  /**
   * @description Whether or not the viewer can resolve this thread
   */

  readonly viewerCanResolve: () => Field<"viewerCanResolve">;

  /**
   * @description Whether or not the viewer can unresolve this thread
   */

  readonly viewerCanUnresolve: () => Field<"viewerCanUnresolve">;
}

export const isPullRequestReviewThread = (
  object: Record<string, any>
): object is Partial<IPullRequestReviewThread> => {
  return object.__typename === "PullRequestReviewThread";
};

export const PullRequestReviewThread: PullRequestReviewThreadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of pull request comments associated with the thread.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("skip", variables.skip),
      ],
      new SelectionSet(select(PullRequestReviewCommentConnection))
    ),

  /**
   * @description The side of the diff on which this thread was placed.
   */
  diffSide: () => new Field("diffSide"),
  id: () => new Field("id"),

  /**
   * @description Whether or not the thread has been collapsed (outdated or resolved)
   */
  isCollapsed: () => new Field("isCollapsed"),

  /**
   * @description Indicates whether this thread was outdated by newer changes.
   */
  isOutdated: () => new Field("isOutdated"),

  /**
   * @description Whether this thread has been resolved
   */
  isResolved: () => new Field("isResolved"),

  /**
   * @description The line in the file to which this thread refers
   */
  line: () => new Field("line"),

  /**
   * @description The original line in the file to which this thread refers.
   */
  originalLine: () => new Field("originalLine"),

  /**
   * @description The original start line in the file to which this thread refers (multi-line only).
   */
  originalStartLine: () => new Field("originalStartLine"),

  /**
   * @description Identifies the file path of this thread.
   */
  path: () => new Field("path"),

  /**
   * @description Identifies the pull request associated with this thread.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the repository associated with this thread.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The user who resolved this thread
   */

  resolvedBy: (select) =>
    new Field("resolvedBy", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The side of the diff that the first line of the thread starts on (multi-line only)
   */
  startDiffSide: () => new Field("startDiffSide"),

  /**
   * @description The start line in the file to which this thread refers (multi-line only)
   */
  startLine: () => new Field("startLine"),

  /**
   * @description Indicates whether the current viewer can reply to this thread.
   */
  viewerCanReply: () => new Field("viewerCanReply"),

  /**
   * @description Whether or not the viewer can resolve this thread
   */
  viewerCanResolve: () => new Field("viewerCanResolve"),

  /**
   * @description Whether or not the viewer can unresolve this thread
   */
  viewerCanUnresolve: () => new Field("viewerCanUnresolve"),
};

export interface IPullRequestReviewThreadConnection {
  readonly __typename: "PullRequestReviewThreadConnection";
  readonly edges: ReadonlyArray<IPullRequestReviewThreadEdge> | null;
  readonly nodes: ReadonlyArray<IPullRequestReviewThread> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PullRequestReviewThreadConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PullRequestReviewThreadConnection: PullRequestReviewThreadConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThreadEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestReviewThreadEdge {
  readonly __typename: "PullRequestReviewThreadEdge";
  readonly cursor: string;
  readonly node: IPullRequestReviewThread | null;
}

interface PullRequestReviewThreadEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestReviewThreadEdge: PullRequestReviewThreadEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),
};

export interface IPullRequestRevisionMarker {
  readonly __typename: "PullRequestRevisionMarker";
  readonly createdAt: unknown;
  readonly lastSeenCommit: ICommit;
  readonly pullRequest: IPullRequest;
}

interface PullRequestRevisionMarkerSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The last commit the viewer has seen.
   */

  readonly lastSeenCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"lastSeenCommit", never, SelectionSet<T>>;

  /**
   * @description The pull request to which the marker belongs.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const PullRequestRevisionMarker: PullRequestRevisionMarkerSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The last commit the viewer has seen.
   */

  lastSeenCommit: (select) =>
    new Field(
      "lastSeenCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description The pull request to which the marker belongs.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IPullRequestTimelineConnection {
  readonly __typename: "PullRequestTimelineConnection";
  readonly edges: ReadonlyArray<IPullRequestTimelineItemEdge> | null;
  readonly nodes: ReadonlyArray<IPullRequestTimelineItem> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PullRequestTimelineConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PullRequestTimelineConnection: PullRequestTimelineConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItemEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItem))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestTimelineItemEdge {
  readonly __typename: "PullRequestTimelineItemEdge";
  readonly cursor: string;
  readonly node: IPullRequestTimelineItem | null;
}

interface PullRequestTimelineItemEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestTimelineItemEdge: PullRequestTimelineItemEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItem))
    ),
};

export interface IPullRequestTimelineItemsConnection {
  readonly __typename: "PullRequestTimelineItemsConnection";
  readonly edges: ReadonlyArray<IPullRequestTimelineItemsEdge> | null;
  readonly filteredCount: number;
  readonly nodes: ReadonlyArray<IPullRequestTimelineItems> | null;
  readonly pageCount: number;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
  readonly updatedAt: unknown;
}

interface PullRequestTimelineItemsConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemsEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description Identifies the count of items after applying `before` and `after` filters.
   */

  readonly filteredCount: () => Field<"filteredCount">;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemsSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
   */

  readonly pageCount: () => Field<"pageCount">;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;

  /**
   * @description Identifies the date and time when the timeline was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const PullRequestTimelineItemsConnection: PullRequestTimelineItemsConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItemsEdge))
    ),

  /**
   * @description Identifies the count of items after applying `before` and `after` filters.
   */
  filteredCount: () => new Field("filteredCount"),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItems))
    ),

  /**
   * @description Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
   */
  pageCount: () => new Field("pageCount"),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description Identifies the date and time when the timeline was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IPullRequestTimelineItemsEdge {
  readonly __typename: "PullRequestTimelineItemsEdge";
  readonly cursor: string;
  readonly node: IPullRequestTimelineItems | null;
}

interface PullRequestTimelineItemsEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemsSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestTimelineItemsEdge: PullRequestTimelineItemsEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItems))
    ),
};

export interface IPush extends INode {
  readonly __typename: "Push";
  readonly nextSha: unknown | null;
  readonly permalink: unknown;
  readonly previousSha: unknown | null;
  readonly pusher: IUser;
  readonly repository: IRepository;
}

interface PushSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description The SHA after the push
   */

  readonly nextSha: () => Field<"nextSha">;

  /**
   * @description The permalink for this push.
   */

  readonly permalink: () => Field<"permalink">;

  /**
   * @description The SHA before the push
   */

  readonly previousSha: () => Field<"previousSha">;

  /**
   * @description The user who pushed
   */

  readonly pusher: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"pusher", never, SelectionSet<T>>;

  /**
   * @description The repository that was pushed to
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isPush = (
  object: Record<string, any>
): object is Partial<IPush> => {
  return object.__typename === "Push";
};

export const Push: PushSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description The SHA after the push
   */
  nextSha: () => new Field("nextSha"),

  /**
   * @description The permalink for this push.
   */
  permalink: () => new Field("permalink"),

  /**
   * @description The SHA before the push
   */
  previousSha: () => new Field("previousSha"),

  /**
   * @description The user who pushed
   */

  pusher: (select) =>
    new Field("pusher", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The repository that was pushed to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IPushAllowance extends INode {
  readonly __typename: "PushAllowance";
  readonly actor: IPushAllowanceActor | null;
  readonly branchProtectionRule: IBranchProtectionRule | null;
}

interface PushAllowanceSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor that can push.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: PushAllowanceActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the branch protection rule associated with the allowed user or team.
   */

  readonly branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;
}

export const isPushAllowance = (
  object: Record<string, any>
): object is Partial<IPushAllowance> => {
  return object.__typename === "PushAllowance";
};

export const PushAllowance: PushAllowanceSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor that can push.
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(PushAllowanceActor))
    ),

  /**
   * @description Identifies the branch protection rule associated with the allowed user or team.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  id: () => new Field("id"),
};

export interface IPushAllowanceConnection {
  readonly __typename: "PushAllowanceConnection";
  readonly edges: ReadonlyArray<IPushAllowanceEdge> | null;
  readonly nodes: ReadonlyArray<IPushAllowance> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface PushAllowanceConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: PushAllowanceEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: PushAllowanceSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const PushAllowanceConnection: PushAllowanceConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PushAllowanceEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PushAllowance))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPushAllowanceEdge {
  readonly __typename: "PushAllowanceEdge";
  readonly cursor: string;
  readonly node: IPushAllowance | null;
}

interface PushAllowanceEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: PushAllowanceSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PushAllowanceEdge: PushAllowanceEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PushAllowance))
    ),
};

export interface IQuery {
  readonly __typename: "Query";
  readonly codeOfConduct: ICodeOfConduct | null;
  readonly codesOfConduct: ReadonlyArray<ICodeOfConduct> | null;
  readonly enterprise: IEnterprise | null;
  readonly enterpriseAdministratorInvitation: IEnterpriseAdministratorInvitation | null;
  readonly enterpriseAdministratorInvitationByToken: IEnterpriseAdministratorInvitation | null;
  readonly license: ILicense | null;
  readonly licenses: ReadonlyArray<ILicense>;
  readonly marketplaceCategories: ReadonlyArray<IMarketplaceCategory>;
  readonly marketplaceCategory: IMarketplaceCategory | null;
  readonly marketplaceListing: IMarketplaceListing | null;
  readonly marketplaceListings: IMarketplaceListingConnection;
  readonly meta: IGitHubMetadata;
  readonly node: INode | null;
  readonly nodes: ReadonlyArray<INode>;
  readonly organization: IOrganization | null;
  readonly rateLimit: IRateLimit | null;
  readonly relay: IQuery;
  readonly repository: IRepository | null;
  readonly repositoryOwner: IRepositoryOwner | null;
  readonly resource: IUniformResourceLocatable | null;
  readonly search: ISearchResultItemConnection;
  readonly securityAdvisories: ISecurityAdvisoryConnection;
  readonly securityAdvisory: ISecurityAdvisory | null;
  readonly securityVulnerabilities: ISecurityVulnerabilityConnection;
  readonly sponsorsListing: ISponsorsListing | null;
  readonly topic: ITopic | null;
  readonly user: IUser | null;
  readonly viewer: IUser;
}

interface QuerySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Look up a code of conduct by its key
   */

  readonly codeOfConduct: <T extends Array<Selection>>(
    variables: { key?: Variable<"key"> | string },
    select: (t: CodeOfConductSelector) => T
  ) => Field<
    "codeOfConduct",
    [Argument<"key", Variable<"key"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Look up a code of conduct by its key
   */

  readonly codesOfConduct: <T extends Array<Selection>>(
    select: (t: CodeOfConductSelector) => T
  ) => Field<"codesOfConduct", never, SelectionSet<T>>;

  /**
   * @description Look up an enterprise by URL slug.
   */

  readonly enterprise: <T extends Array<Selection>>(
    variables: {
      invitationToken?: Variable<"invitationToken"> | string;
      slug?: Variable<"slug"> | string;
    },
    select: (t: EnterpriseSelector) => T
  ) => Field<
    "enterprise",
    [
      Argument<"invitationToken", Variable<"invitationToken"> | string>,
      Argument<"slug", Variable<"slug"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a pending enterprise administrator invitation by invitee, enterprise and role.
   */

  readonly enterpriseAdministratorInvitation: <T extends Array<Selection>>(
    variables: {
      enterpriseSlug?: Variable<"enterpriseSlug"> | string;
      role?: Variable<"role"> | EnterpriseAdministratorRole;
      userLogin?: Variable<"userLogin"> | string;
    },
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<
    "enterpriseAdministratorInvitation",
    [
      Argument<"enterpriseSlug", Variable<"enterpriseSlug"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseAdministratorRole>,
      Argument<"userLogin", Variable<"userLogin"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a pending enterprise administrator invitation by invitation token.
   */

  readonly enterpriseAdministratorInvitationByToken: <
    T extends Array<Selection>
  >(
    variables: { invitationToken?: Variable<"invitationToken"> | string },
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<
    "enterpriseAdministratorInvitationByToken",
    [Argument<"invitationToken", Variable<"invitationToken"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Look up an open source license by its key
   */

  readonly license: <T extends Array<Selection>>(
    variables: { key?: Variable<"key"> | string },
    select: (t: LicenseSelector) => T
  ) => Field<
    "license",
    [Argument<"key", Variable<"key"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Return a list of known open source licenses
   */

  readonly licenses: <T extends Array<Selection>>(
    select: (t: LicenseSelector) => T
  ) => Field<"licenses", never, SelectionSet<T>>;

  /**
   * @description Get alphabetically sorted list of Marketplace categories
   */

  readonly marketplaceCategories: <T extends Array<Selection>>(
    variables: {
      excludeEmpty?: Variable<"excludeEmpty"> | boolean;
      excludeSubcategories?: Variable<"excludeSubcategories"> | boolean;
      includeCategories?: Variable<"includeCategories"> | string;
    },
    select: (t: MarketplaceCategorySelector) => T
  ) => Field<
    "marketplaceCategories",
    [
      Argument<"excludeEmpty", Variable<"excludeEmpty"> | boolean>,
      Argument<
        "excludeSubcategories",
        Variable<"excludeSubcategories"> | boolean
      >,
      Argument<"includeCategories", Variable<"includeCategories"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a Marketplace category by its slug.
   */

  readonly marketplaceCategory: <T extends Array<Selection>>(
    variables: {
      slug?: Variable<"slug"> | string;
      useTopicAliases?: Variable<"useTopicAliases"> | boolean;
    },
    select: (t: MarketplaceCategorySelector) => T
  ) => Field<
    "marketplaceCategory",
    [
      Argument<"slug", Variable<"slug"> | string>,
      Argument<"useTopicAliases", Variable<"useTopicAliases"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a single Marketplace listing
   */

  readonly marketplaceListing: <T extends Array<Selection>>(
    variables: { slug?: Variable<"slug"> | string },
    select: (t: MarketplaceListingSelector) => T
  ) => Field<
    "marketplaceListing",
    [Argument<"slug", Variable<"slug"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Look up Marketplace listings
   */

  readonly marketplaceListings: <T extends Array<Selection>>(
    variables: {
      adminId?: Variable<"adminId"> | string;
      after?: Variable<"after"> | string;
      allStates?: Variable<"allStates"> | boolean;
      before?: Variable<"before"> | string;
      categorySlug?: Variable<"categorySlug"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      organizationId?: Variable<"organizationId"> | string;
      primaryCategoryOnly?: Variable<"primaryCategoryOnly"> | boolean;
      slugs?: Variable<"slugs"> | string;
      useTopicAliases?: Variable<"useTopicAliases"> | boolean;
      viewerCanAdmin?: Variable<"viewerCanAdmin"> | boolean;
      withFreeTrialsOnly?: Variable<"withFreeTrialsOnly"> | boolean;
    },
    select: (t: MarketplaceListingConnectionSelector) => T
  ) => Field<
    "marketplaceListings",
    [
      Argument<"adminId", Variable<"adminId"> | string>,
      Argument<"after", Variable<"after"> | string>,
      Argument<"allStates", Variable<"allStates"> | boolean>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"categorySlug", Variable<"categorySlug"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"organizationId", Variable<"organizationId"> | string>,
      Argument<
        "primaryCategoryOnly",
        Variable<"primaryCategoryOnly"> | boolean
      >,
      Argument<"slugs", Variable<"slugs"> | string>,
      Argument<"useTopicAliases", Variable<"useTopicAliases"> | boolean>,
      Argument<"viewerCanAdmin", Variable<"viewerCanAdmin"> | boolean>,
      Argument<"withFreeTrialsOnly", Variable<"withFreeTrialsOnly"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Return information about the GitHub instance
   */

  readonly meta: <T extends Array<Selection>>(
    select: (t: GitHubMetadataSelector) => T
  ) => Field<"meta", never, SelectionSet<T>>;

  /**
   * @description Fetches an object given its ID.
   */

  readonly node: <T extends Array<Selection>>(
    variables: { id?: Variable<"id"> | string },
    select: (t: NodeSelector) => T
  ) => Field<
    "node",
    [Argument<"id", Variable<"id"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Lookup nodes by a list of IDs.
   */

  readonly nodes: <T extends Array<Selection>>(
    variables: { ids?: Variable<"ids"> | string },
    select: (t: NodeSelector) => T
  ) => Field<
    "nodes",
    [Argument<"ids", Variable<"ids"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Lookup a organization by login.
   */

  readonly organization: <T extends Array<Selection>>(
    variables: { login?: Variable<"login"> | string },
    select: (t: OrganizationSelector) => T
  ) => Field<
    "organization",
    [Argument<"login", Variable<"login"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The client's rate limit information.
   */

  readonly rateLimit: <T extends Array<Selection>>(
    variables: { dryRun?: Variable<"dryRun"> | boolean },
    select: (t: RateLimitSelector) => T
  ) => Field<
    "rateLimit",
    [Argument<"dryRun", Variable<"dryRun"> | boolean>],
    SelectionSet<T>
  >;

  /**
   * @description Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object
   */

  readonly relay: <T extends Array<Selection>>(
    select: (t: QuerySelector) => T
  ) => Field<"relay", never, SelectionSet<T>>;

  /**
   * @description Lookup a given repository by the owner and repository name.
   */

  readonly repository: <T extends Array<Selection>>(
    variables: {
      name?: Variable<"name"> | string;
      owner?: Variable<"owner"> | string;
    },
    select: (t: RepositorySelector) => T
  ) => Field<
    "repository",
    [
      Argument<"name", Variable<"name"> | string>,
      Argument<"owner", Variable<"owner"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Lookup a repository owner (ie. either a User or an Organization) by login.
   */

  readonly repositoryOwner: <T extends Array<Selection>>(
    variables: { login?: Variable<"login"> | string },
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<
    "repositoryOwner",
    [Argument<"login", Variable<"login"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Lookup resource by a URL.
   */

  readonly resource: <T extends Array<Selection>>(
    variables: { url?: Variable<"url"> | unknown },
    select: (t: UniformResourceLocatableSelector) => T
  ) => Field<
    "resource",
    [Argument<"url", Variable<"url"> | unknown>],
    SelectionSet<T>
  >;

  /**
   * @description Perform a search across resources.
   */

  readonly search: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
      type?: Variable<"type"> | SearchType;
    },
    select: (t: SearchResultItemConnectionSelector) => T
  ) => Field<
    "search",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"type", Variable<"type"> | SearchType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description GitHub Security Advisories
   */

  readonly securityAdvisories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      identifier?: Variable<"identifier"> | SecurityAdvisoryIdentifierFilter;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SecurityAdvisoryOrder;
      publishedSince?: Variable<"publishedSince"> | unknown;
      updatedSince?: Variable<"updatedSince"> | unknown;
    },
    select: (t: SecurityAdvisoryConnectionSelector) => T
  ) => Field<
    "securityAdvisories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<
        "identifier",
        Variable<"identifier"> | SecurityAdvisoryIdentifierFilter
      >,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SecurityAdvisoryOrder>,
      Argument<"publishedSince", Variable<"publishedSince"> | unknown>,
      Argument<"updatedSince", Variable<"updatedSince"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Fetch a Security Advisory by its GHSA ID
   */

  readonly securityAdvisory: <T extends Array<Selection>>(
    variables: { ghsaId?: Variable<"ghsaId"> | string },
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<
    "securityAdvisory",
    [Argument<"ghsaId", Variable<"ghsaId"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Software Vulnerabilities documented by GitHub Security Advisories
   */

  readonly securityVulnerabilities: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      ecosystem?: Variable<"ecosystem"> | SecurityAdvisoryEcosystem;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SecurityVulnerabilityOrder;
      package?: Variable<"package"> | string;
      severities?: Variable<"severities"> | SecurityAdvisorySeverity;
    },
    select: (t: SecurityVulnerabilityConnectionSelector) => T
  ) => Field<
    "securityVulnerabilities",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"ecosystem", Variable<"ecosystem"> | SecurityAdvisoryEcosystem>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SecurityVulnerabilityOrder>,
      Argument<"package", Variable<"package"> | string>,
      Argument<"severities", Variable<"severities"> | SecurityAdvisorySeverity>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a single Sponsors Listing
   * @deprecated `Query.sponsorsListing` will be removed. Use `Sponsorable.sponsorsListing` instead. Removal on 2020-04-01 UTC.
   */

  readonly sponsorsListing: <T extends Array<Selection>>(
    variables: { slug?: Variable<"slug"> | string },
    select: (t: SponsorsListingSelector) => T
  ) => Field<
    "sponsorsListing",
    [Argument<"slug", Variable<"slug"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Look up a topic by name.
   */

  readonly topic: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: TopicSelector) => T
  ) => Field<
    "topic",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Lookup a user by login.
   */

  readonly user: <T extends Array<Selection>>(
    variables: { login?: Variable<"login"> | string },
    select: (t: UserSelector) => T
  ) => Field<
    "user",
    [Argument<"login", Variable<"login"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The currently authenticated user.
   */

  readonly viewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"viewer", never, SelectionSet<T>>;
}

export const Query: QuerySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Look up a code of conduct by its key
   */

  codeOfConduct: (variables, select) =>
    new Field(
      "codeOfConduct",
      [new Argument("key", variables.key)],
      new SelectionSet(select(CodeOfConduct))
    ),

  /**
   * @description Look up a code of conduct by its key
   */

  codesOfConduct: (select) =>
    new Field(
      "codesOfConduct",
      undefined as never,
      new SelectionSet(select(CodeOfConduct))
    ),

  /**
   * @description Look up an enterprise by URL slug.
   */

  enterprise: (variables, select) =>
    new Field(
      "enterprise",
      [
        new Argument("invitationToken", variables.invitationToken),
        new Argument("slug", variables.slug),
      ],
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description Look up a pending enterprise administrator invitation by invitee, enterprise and role.
   */

  enterpriseAdministratorInvitation: (variables, select) =>
    new Field(
      "enterpriseAdministratorInvitation",
      [
        new Argument("enterpriseSlug", variables.enterpriseSlug),
        new Argument("role", variables.role, EnterpriseAdministratorRole),
        new Argument("userLogin", variables.userLogin),
      ],
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description Look up a pending enterprise administrator invitation by invitation token.
   */

  enterpriseAdministratorInvitationByToken: (variables, select) =>
    new Field(
      "enterpriseAdministratorInvitationByToken",
      [new Argument("invitationToken", variables.invitationToken)],
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description Look up an open source license by its key
   */

  license: (variables, select) =>
    new Field(
      "license",
      [new Argument("key", variables.key)],
      new SelectionSet(select(License))
    ),

  /**
   * @description Return a list of known open source licenses
   */

  licenses: (select) =>
    new Field(
      "licenses",
      undefined as never,
      new SelectionSet(select(License))
    ),

  /**
   * @description Get alphabetically sorted list of Marketplace categories
   */

  marketplaceCategories: (variables, select) =>
    new Field(
      "marketplaceCategories",
      [
        new Argument("excludeEmpty", variables.excludeEmpty),
        new Argument("excludeSubcategories", variables.excludeSubcategories),
        new Argument("includeCategories", variables.includeCategories),
      ],
      new SelectionSet(select(MarketplaceCategory))
    ),

  /**
   * @description Look up a Marketplace category by its slug.
   */

  marketplaceCategory: (variables, select) =>
    new Field(
      "marketplaceCategory",
      [
        new Argument("slug", variables.slug),
        new Argument("useTopicAliases", variables.useTopicAliases),
      ],
      new SelectionSet(select(MarketplaceCategory))
    ),

  /**
   * @description Look up a single Marketplace listing
   */

  marketplaceListing: (variables, select) =>
    new Field(
      "marketplaceListing",
      [new Argument("slug", variables.slug)],
      new SelectionSet(select(MarketplaceListing))
    ),

  /**
   * @description Look up Marketplace listings
   */

  marketplaceListings: (variables, select) =>
    new Field(
      "marketplaceListings",
      [
        new Argument("adminId", variables.adminId),
        new Argument("after", variables.after),
        new Argument("allStates", variables.allStates),
        new Argument("before", variables.before),
        new Argument("categorySlug", variables.categorySlug),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("organizationId", variables.organizationId),
        new Argument("primaryCategoryOnly", variables.primaryCategoryOnly),
        new Argument("slugs", variables.slugs),
        new Argument("useTopicAliases", variables.useTopicAliases),
        new Argument("viewerCanAdmin", variables.viewerCanAdmin),
        new Argument("withFreeTrialsOnly", variables.withFreeTrialsOnly),
      ],
      new SelectionSet(select(MarketplaceListingConnection))
    ),

  /**
   * @description Return information about the GitHub instance
   */

  meta: (select) =>
    new Field(
      "meta",
      undefined as never,
      new SelectionSet(select(GitHubMetadata))
    ),

  /**
   * @description Fetches an object given its ID.
   */

  node: (variables, select) =>
    new Field(
      "node",
      [new Argument("id", variables.id)],
      new SelectionSet(select(Node))
    ),

  /**
   * @description Lookup nodes by a list of IDs.
   */

  nodes: (variables, select) =>
    new Field(
      "nodes",
      [new Argument("ids", variables.ids)],
      new SelectionSet(select(Node))
    ),

  /**
   * @description Lookup a organization by login.
   */

  organization: (variables, select) =>
    new Field(
      "organization",
      [new Argument("login", variables.login)],
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The client's rate limit information.
   */

  rateLimit: (variables, select) =>
    new Field(
      "rateLimit",
      [new Argument("dryRun", variables.dryRun)],
      new SelectionSet(select(RateLimit))
    ),

  /**
   * @description Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object
   */

  relay: (select) =>
    new Field("relay", undefined as never, new SelectionSet(select(Query))),

  /**
   * @description Lookup a given repository by the owner and repository name.
   */

  repository: (variables, select) =>
    new Field(
      "repository",
      [
        new Argument("name", variables.name),
        new Argument("owner", variables.owner),
      ],
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Lookup a repository owner (ie. either a User or an Organization) by login.
   */

  repositoryOwner: (variables, select) =>
    new Field(
      "repositoryOwner",
      [new Argument("login", variables.login)],
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description Lookup resource by a URL.
   */

  resource: (variables, select) =>
    new Field(
      "resource",
      [new Argument("url", variables.url)],
      new SelectionSet(select(UniformResourceLocatable))
    ),

  /**
   * @description Perform a search across resources.
   */

  search: (variables, select) =>
    new Field(
      "search",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
        new Argument("type", variables.type, SearchType),
      ],
      new SelectionSet(select(SearchResultItemConnection))
    ),

  /**
   * @description GitHub Security Advisories
   */

  securityAdvisories: (variables, select) =>
    new Field(
      "securityAdvisories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("identifier", variables.identifier),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("publishedSince", variables.publishedSince),
        new Argument("updatedSince", variables.updatedSince),
      ],
      new SelectionSet(select(SecurityAdvisoryConnection))
    ),

  /**
   * @description Fetch a Security Advisory by its GHSA ID
   */

  securityAdvisory: (variables, select) =>
    new Field(
      "securityAdvisory",
      [new Argument("ghsaId", variables.ghsaId)],
      new SelectionSet(select(SecurityAdvisory))
    ),

  /**
   * @description Software Vulnerabilities documented by GitHub Security Advisories
   */

  securityVulnerabilities: (variables, select) =>
    new Field(
      "securityVulnerabilities",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument(
          "ecosystem",
          variables.ecosystem,
          SecurityAdvisoryEcosystem
        ),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("package", variables.package),
        new Argument(
          "severities",
          variables.severities,
          SecurityAdvisorySeverity
        ),
      ],
      new SelectionSet(select(SecurityVulnerabilityConnection))
    ),

  /**
   * @description Look up a single Sponsors Listing
   * @deprecated `Query.sponsorsListing` will be removed. Use `Sponsorable.sponsorsListing` instead. Removal on 2020-04-01 UTC.
   */

  sponsorsListing: (variables, select) =>
    new Field(
      "sponsorsListing",
      [new Argument("slug", variables.slug)],
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description Look up a topic by name.
   */

  topic: (variables, select) =>
    new Field(
      "topic",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Topic))
    ),

  /**
   * @description Lookup a user by login.
   */

  user: (variables, select) =>
    new Field(
      "user",
      [new Argument("login", variables.login)],
      new SelectionSet(select(User))
    ),

  /**
   * @description The currently authenticated user.
   */

  viewer: (select) =>
    new Field("viewer", undefined as never, new SelectionSet(select(User))),
};

export interface IRateLimit {
  readonly __typename: "RateLimit";
  readonly cost: number;
  readonly limit: number;
  readonly nodeCount: number;
  readonly remaining: number;
  readonly resetAt: unknown;
  readonly used: number;
}

interface RateLimitSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The point cost for the current query counting against the rate limit.
   */

  readonly cost: () => Field<"cost">;

  /**
   * @description The maximum number of points the client is permitted to consume in a 60 minute window.
   */

  readonly limit: () => Field<"limit">;

  /**
   * @description The maximum number of nodes this query may return
   */

  readonly nodeCount: () => Field<"nodeCount">;

  /**
   * @description The number of points remaining in the current rate limit window.
   */

  readonly remaining: () => Field<"remaining">;

  /**
   * @description The time at which the current rate limit window resets in UTC epoch seconds.
   */

  readonly resetAt: () => Field<"resetAt">;

  /**
   * @description The number of points used in the current rate limit window.
   */

  readonly used: () => Field<"used">;
}

export const RateLimit: RateLimitSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The point cost for the current query counting against the rate limit.
   */
  cost: () => new Field("cost"),

  /**
   * @description The maximum number of points the client is permitted to consume in a 60 minute window.
   */
  limit: () => new Field("limit"),

  /**
   * @description The maximum number of nodes this query may return
   */
  nodeCount: () => new Field("nodeCount"),

  /**
   * @description The number of points remaining in the current rate limit window.
   */
  remaining: () => new Field("remaining"),

  /**
   * @description The time at which the current rate limit window resets in UTC epoch seconds.
   */
  resetAt: () => new Field("resetAt"),

  /**
   * @description The number of points used in the current rate limit window.
   */
  used: () => new Field("used"),
};

export interface IReactable {
  readonly __typename: string;
  readonly databaseId: number | null;
  readonly id: string;
  readonly reactionGroups: ReadonlyArray<IReactionGroup> | null;
  readonly reactions: IReactionConnection;
  readonly viewerCanReact: boolean;
}

interface ReactableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "Issue"
      | "IssueComment"
      | "PullRequest"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Reactable: ReactableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Reactable",
        });
    }
  },
};

export interface IReactingUserConnection {
  readonly __typename: "ReactingUserConnection";
  readonly edges: ReadonlyArray<IReactingUserEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ReactingUserConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ReactingUserEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ReactingUserConnection: ReactingUserConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReactingUserEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReactingUserEdge {
  readonly __typename: "ReactingUserEdge";
  readonly cursor: string;
  readonly node: IUser;
  readonly reactedAt: unknown;
}

interface ReactingUserEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The moment when the user made the reaction.
   */

  readonly reactedAt: () => Field<"reactedAt">;
}

export const ReactingUserEdge: ReactingUserEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The moment when the user made the reaction.
   */
  reactedAt: () => new Field("reactedAt"),
};

export interface IReaction extends INode {
  readonly __typename: "Reaction";
  readonly content: ReactionContent;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly reactable: IReactable;
  readonly user: IUser | null;
}

interface ReactionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the emoji reaction.
   */

  readonly content: () => Field<"content">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description The reactable piece of content
   */

  readonly reactable: <T extends Array<Selection>>(
    select: (t: ReactableSelector) => T
  ) => Field<"reactable", never, SelectionSet<T>>;

  /**
   * @description Identifies the user who created this reaction.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isReaction = (
  object: Record<string, any>
): object is Partial<IReaction> => {
  return object.__typename === "Reaction";
};

export const Reaction: ReactionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the emoji reaction.
   */
  content: () => new Field("content"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The reactable piece of content
   */

  reactable: (select) =>
    new Field(
      "reactable",
      undefined as never,
      new SelectionSet(select(Reactable))
    ),

  /**
   * @description Identifies the user who created this reaction.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IReactionConnection {
  readonly __typename: "ReactionConnection";
  readonly edges: ReadonlyArray<IReactionEdge> | null;
  readonly nodes: ReadonlyArray<IReaction> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
  readonly viewerHasReacted: boolean;
}

interface ReactionConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ReactionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ReactionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;

  /**
   * @description Whether or not the authenticated user has left a reaction on the subject.
   */

  readonly viewerHasReacted: () => Field<"viewerHasReacted">;
}

export const ReactionConnection: ReactionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReactionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Reaction))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description Whether or not the authenticated user has left a reaction on the subject.
   */
  viewerHasReacted: () => new Field("viewerHasReacted"),
};

export interface IReactionEdge {
  readonly __typename: "ReactionEdge";
  readonly cursor: string;
  readonly node: IReaction | null;
}

interface ReactionEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ReactionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReactionEdge: ReactionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Reaction))),
};

export interface IReactionGroup {
  readonly __typename: "ReactionGroup";
  readonly content: ReactionContent;
  readonly createdAt: unknown | null;
  readonly subject: IReactable;
  readonly users: IReactingUserConnection;
  readonly viewerHasReacted: boolean;
}

interface ReactionGroupSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the emoji reaction.
   */

  readonly content: () => Field<"content">;

  /**
   * @description Identifies when the reaction was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The subject that was reacted to.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: ReactableSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;

  /**
   * @description Users who have reacted to the reaction subject with the emotion represented by this reaction group
   */

  readonly users: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ReactingUserConnectionSelector) => T
  ) => Field<
    "users",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not the authenticated user has left a reaction on the subject.
   */

  readonly viewerHasReacted: () => Field<"viewerHasReacted">;
}

export const ReactionGroup: ReactionGroupSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the emoji reaction.
   */
  content: () => new Field("content"),

  /**
   * @description Identifies when the reaction was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The subject that was reacted to.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(Reactable))
    ),

  /**
   * @description Users who have reacted to the reaction subject with the emotion represented by this reaction group
   */

  users: (variables, select) =>
    new Field(
      "users",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ReactingUserConnection))
    ),

  /**
   * @description Whether or not the authenticated user has left a reaction on the subject.
   */
  viewerHasReacted: () => new Field("viewerHasReacted"),
};

export interface IReadyForReviewEvent extends INode, IUniformResourceLocatable {
  readonly __typename: "ReadyForReviewEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly pullRequest: IPullRequest;
}

interface ReadyForReviewEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this ready for review event.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this ready for review event.
   */

  readonly url: () => Field<"url">;
}

export const isReadyForReviewEvent = (
  object: Record<string, any>
): object is Partial<IReadyForReviewEvent> => {
  return object.__typename === "ReadyForReviewEvent";
};

export const ReadyForReviewEvent: ReadyForReviewEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this ready for review event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this ready for review event.
   */
  url: () => new Field("url"),
};

export interface IRef extends INode {
  readonly __typename: "Ref";
  readonly associatedPullRequests: IPullRequestConnection;
  readonly branchProtectionRule: IBranchProtectionRule | null;
  readonly name: string;
  readonly prefix: string;
  readonly refUpdateRule: IRefUpdateRule | null;
  readonly repository: IRepository;
  readonly target: IGitObject | null;
}

interface RefSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of pull requests with this ref as the head ref.
   */

  readonly associatedPullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "associatedPullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Branch protection rules for this ref
   */

  readonly branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The ref name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The ref's prefix, such as `refs/heads/` or `refs/tags/`.
   */

  readonly prefix: () => Field<"prefix">;

  /**
   * @description Branch protection rules that are viewable by non-admins
   */

  readonly refUpdateRule: <T extends Array<Selection>>(
    select: (t: RefUpdateRuleSelector) => T
  ) => Field<"refUpdateRule", never, SelectionSet<T>>;

  /**
   * @description The repository the ref belongs to.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The object the ref points to. Returns null when object does not exist.
   */

  readonly target: <T extends Array<Selection>>(
    select: (t: GitObjectSelector) => T
  ) => Field<"target", never, SelectionSet<T>>;
}

export const isRef = (object: Record<string, any>): object is Partial<IRef> => {
  return object.__typename === "Ref";
};

export const Ref: RefSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of pull requests with this ref as the head ref.
   */

  associatedPullRequests: (variables, select) =>
    new Field(
      "associatedPullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description Branch protection rules for this ref
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  id: () => new Field("id"),

  /**
   * @description The ref name.
   */
  name: () => new Field("name"),

  /**
   * @description The ref's prefix, such as `refs/heads/` or `refs/tags/`.
   */
  prefix: () => new Field("prefix"),

  /**
   * @description Branch protection rules that are viewable by non-admins
   */

  refUpdateRule: (select) =>
    new Field(
      "refUpdateRule",
      undefined as never,
      new SelectionSet(select(RefUpdateRule))
    ),

  /**
   * @description The repository the ref belongs to.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The object the ref points to. Returns null when object does not exist.
   */

  target: (select) =>
    new Field(
      "target",
      undefined as never,
      new SelectionSet(select(GitObject))
    ),
};

export interface IRefConnection {
  readonly __typename: "RefConnection";
  readonly edges: ReadonlyArray<IRefEdge> | null;
  readonly nodes: ReadonlyArray<IRef> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface RefConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: RefEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const RefConnection: RefConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(RefEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRefEdge {
  readonly __typename: "RefEdge";
  readonly cursor: string;
  readonly node: IRef | null;
}

interface RefEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RefEdge: RefEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Ref))),
};

export interface IRefUpdateRule {
  readonly __typename: "RefUpdateRule";
  readonly allowsDeletions: boolean;
  readonly allowsForcePushes: boolean;
  readonly pattern: string;
  readonly requiredApprovingReviewCount: number | null;
  readonly requiredStatusCheckContexts: ReadonlyArray<string> | null;
  readonly requiresLinearHistory: boolean;
  readonly requiresSignatures: boolean;
  readonly viewerCanPush: boolean;
}

interface RefUpdateRuleSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Can this branch be deleted.
   */

  readonly allowsDeletions: () => Field<"allowsDeletions">;

  /**
   * @description Are force pushes allowed on this branch.
   */

  readonly allowsForcePushes: () => Field<"allowsForcePushes">;

  /**
   * @description Identifies the protection rule pattern.
   */

  readonly pattern: () => Field<"pattern">;

  /**
   * @description Number of approving reviews required to update matching branches.
   */

  readonly requiredApprovingReviewCount: () => Field<"requiredApprovingReviewCount">;

  /**
   * @description List of required status check contexts that must pass for commits to be accepted to matching branches.
   */

  readonly requiredStatusCheckContexts: () => Field<"requiredStatusCheckContexts">;

  /**
   * @description Are merge commits prohibited from being pushed to this branch.
   */

  readonly requiresLinearHistory: () => Field<"requiresLinearHistory">;

  /**
   * @description Are commits required to be signed.
   */

  readonly requiresSignatures: () => Field<"requiresSignatures">;

  /**
   * @description Can the viewer push to the branch
   */

  readonly viewerCanPush: () => Field<"viewerCanPush">;
}

export const RefUpdateRule: RefUpdateRuleSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Can this branch be deleted.
   */
  allowsDeletions: () => new Field("allowsDeletions"),

  /**
   * @description Are force pushes allowed on this branch.
   */
  allowsForcePushes: () => new Field("allowsForcePushes"),

  /**
   * @description Identifies the protection rule pattern.
   */
  pattern: () => new Field("pattern"),

  /**
   * @description Number of approving reviews required to update matching branches.
   */
  requiredApprovingReviewCount: () => new Field("requiredApprovingReviewCount"),

  /**
   * @description List of required status check contexts that must pass for commits to be accepted to matching branches.
   */
  requiredStatusCheckContexts: () => new Field("requiredStatusCheckContexts"),

  /**
   * @description Are merge commits prohibited from being pushed to this branch.
   */
  requiresLinearHistory: () => new Field("requiresLinearHistory"),

  /**
   * @description Are commits required to be signed.
   */
  requiresSignatures: () => new Field("requiresSignatures"),

  /**
   * @description Can the viewer push to the branch
   */
  viewerCanPush: () => new Field("viewerCanPush"),
};

export interface IReferencedEvent extends INode {
  readonly __typename: "ReferencedEvent";
  readonly actor: IActor | null;
  readonly commit: ICommit | null;
  readonly commitRepository: IRepository;
  readonly createdAt: unknown;
  readonly isCrossRepository: boolean;
  readonly isDirectReference: boolean;
  readonly subject: IReferencedSubject;
}

interface ReferencedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the commit associated with the 'referenced' event.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the repository associated with the 'referenced' event.
   */

  readonly commitRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"commitRepository", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Reference originated in a different repository.
   */

  readonly isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference.
   */

  readonly isDirectReference: () => Field<"isDirectReference">;

  /**
   * @description Object referenced by event.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isReferencedEvent = (
  object: Record<string, any>
): object is Partial<IReferencedEvent> => {
  return object.__typename === "ReferencedEvent";
};

export const ReferencedEvent: ReferencedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the commit associated with the 'referenced' event.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the repository associated with the 'referenced' event.
   */

  commitRepository: (select) =>
    new Field(
      "commitRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reference originated in a different repository.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference.
   */
  isDirectReference: () => new Field("isDirectReference"),

  /**
   * @description Object referenced by event.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),
};

export interface IRegenerateEnterpriseIdentityProviderRecoveryCodesPayload {
  readonly __typename: "RegenerateEnterpriseIdentityProviderRecoveryCodesPayload";
  readonly clientMutationId: string | null;
  readonly identityProvider: IEnterpriseIdentityProvider | null;
}

interface RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The identity provider for the enterprise.
   */

  readonly identityProvider: <T extends Array<Selection>>(
    select: (t: EnterpriseIdentityProviderSelector) => T
  ) => Field<"identityProvider", never, SelectionSet<T>>;
}

export const RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The identity provider for the enterprise.
   */

  identityProvider: (select) =>
    new Field(
      "identityProvider",
      undefined as never,
      new SelectionSet(select(EnterpriseIdentityProvider))
    ),
};

export interface IRelease extends INode, IUniformResourceLocatable {
  readonly __typename: "Release";
  readonly author: IUser | null;
  readonly createdAt: unknown;
  readonly description: string | null;
  readonly descriptionHTML: unknown | null;
  readonly isDraft: boolean;
  readonly isPrerelease: boolean;
  readonly name: string | null;
  readonly publishedAt: unknown | null;
  readonly releaseAssets: IReleaseAssetConnection;
  readonly shortDescriptionHTML: unknown | null;
  readonly tag: IRef | null;
  readonly tagName: string;
  readonly updatedAt: unknown;
}

interface ReleaseSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The author of the release
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The description of the release.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The description of this release rendered to HTML.
   */

  readonly descriptionHTML: () => Field<"descriptionHTML">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether or not the release is a draft
   */

  readonly isDraft: () => Field<"isDraft">;

  /**
   * @description Whether or not the release is a prerelease
   */

  readonly isPrerelease: () => Field<"isPrerelease">;

  /**
   * @description The title of the release.
   */

  readonly name: () => Field<"name">;

  /**
   * @description Identifies the date and time when the release was created.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description List of releases assets which are dependent on this release.
   */

  readonly releaseAssets: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      name?: Variable<"name"> | string;
    },
    select: (t: ReleaseAssetConnectionSelector) => T
  ) => Field<
    "releaseAssets",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"name", Variable<"name"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this issue
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description A description of the release, rendered to HTML without any links in it.
   */

  readonly shortDescriptionHTML: (variables: {
    limit?: Variable<"limit"> | number;
  }) => Field<
    "shortDescriptionHTML",
    [Argument<"limit", Variable<"limit"> | number>]
  >;

  /**
   * @description The Git tag the release points to
   */

  readonly tag: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"tag", never, SelectionSet<T>>;

  /**
   * @description The name of the release's Git tag
   */

  readonly tagName: () => Field<"tagName">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this issue
   */

  readonly url: () => Field<"url">;
}

export const isRelease = (
  object: Record<string, any>
): object is Partial<IRelease> => {
  return object.__typename === "Release";
};

export const Release: ReleaseSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The author of the release
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The description of the release.
   */
  description: () => new Field("description"),

  /**
   * @description The description of this release rendered to HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),
  id: () => new Field("id"),

  /**
   * @description Whether or not the release is a draft
   */
  isDraft: () => new Field("isDraft"),

  /**
   * @description Whether or not the release is a prerelease
   */
  isPrerelease: () => new Field("isPrerelease"),

  /**
   * @description The title of the release.
   */
  name: () => new Field("name"),

  /**
   * @description Identifies the date and time when the release was created.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description List of releases assets which are dependent on this release.
   */

  releaseAssets: (variables, select) =>
    new Field(
      "releaseAssets",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("name", variables.name),
      ],
      new SelectionSet(select(ReleaseAssetConnection))
    ),

  /**
   * @description The HTTP path for this issue
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description A description of the release, rendered to HTML without any links in it.
   */
  shortDescriptionHTML: (variables) => new Field("shortDescriptionHTML"),

  /**
   * @description The Git tag the release points to
   */

  tag: (select) =>
    new Field("tag", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description The name of the release's Git tag
   */
  tagName: () => new Field("tagName"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this issue
   */
  url: () => new Field("url"),
};

export interface IReleaseAsset extends INode {
  readonly __typename: "ReleaseAsset";
  readonly contentType: string;
  readonly createdAt: unknown;
  readonly downloadCount: number;
  readonly downloadUrl: unknown;
  readonly name: string;
  readonly release: IRelease | null;
  readonly size: number;
  readonly updatedAt: unknown;
  readonly uploadedBy: IUser;
  readonly url: unknown;
}

interface ReleaseAssetSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The asset's content-type
   */

  readonly contentType: () => Field<"contentType">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The number of times this asset was downloaded
   */

  readonly downloadCount: () => Field<"downloadCount">;

  /**
   * @description Identifies the URL where you can download the release asset via the browser.
   */

  readonly downloadUrl: () => Field<"downloadUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the title of the release asset.
   */

  readonly name: () => Field<"name">;

  /**
   * @description Release that the asset is associated with
   */

  readonly release: <T extends Array<Selection>>(
    select: (t: ReleaseSelector) => T
  ) => Field<"release", never, SelectionSet<T>>;

  /**
   * @description The size (in bytes) of the asset
   */

  readonly size: () => Field<"size">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The user that performed the upload
   */

  readonly uploadedBy: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"uploadedBy", never, SelectionSet<T>>;

  /**
   * @description Identifies the URL of the release asset.
   */

  readonly url: () => Field<"url">;
}

export const isReleaseAsset = (
  object: Record<string, any>
): object is Partial<IReleaseAsset> => {
  return object.__typename === "ReleaseAsset";
};

export const ReleaseAsset: ReleaseAssetSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The asset's content-type
   */
  contentType: () => new Field("contentType"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The number of times this asset was downloaded
   */
  downloadCount: () => new Field("downloadCount"),

  /**
   * @description Identifies the URL where you can download the release asset via the browser.
   */
  downloadUrl: () => new Field("downloadUrl"),
  id: () => new Field("id"),

  /**
   * @description Identifies the title of the release asset.
   */
  name: () => new Field("name"),

  /**
   * @description Release that the asset is associated with
   */

  release: (select) =>
    new Field("release", undefined as never, new SelectionSet(select(Release))),

  /**
   * @description The size (in bytes) of the asset
   */
  size: () => new Field("size"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The user that performed the upload
   */

  uploadedBy: (select) =>
    new Field("uploadedBy", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Identifies the URL of the release asset.
   */
  url: () => new Field("url"),
};

export interface IReleaseAssetConnection {
  readonly __typename: "ReleaseAssetConnection";
  readonly edges: ReadonlyArray<IReleaseAssetEdge> | null;
  readonly nodes: ReadonlyArray<IReleaseAsset> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ReleaseAssetConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ReleaseAssetEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ReleaseAssetSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ReleaseAssetConnection: ReleaseAssetConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReleaseAssetEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ReleaseAsset))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReleaseAssetEdge {
  readonly __typename: "ReleaseAssetEdge";
  readonly cursor: string;
  readonly node: IReleaseAsset | null;
}

interface ReleaseAssetEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ReleaseAssetSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReleaseAssetEdge: ReleaseAssetEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ReleaseAsset))
    ),
};

export interface IReleaseConnection {
  readonly __typename: "ReleaseConnection";
  readonly edges: ReadonlyArray<IReleaseEdge> | null;
  readonly nodes: ReadonlyArray<IRelease> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ReleaseConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ReleaseEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ReleaseSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ReleaseConnection: ReleaseConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReleaseEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Release))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReleaseEdge {
  readonly __typename: "ReleaseEdge";
  readonly cursor: string;
  readonly node: IRelease | null;
}

interface ReleaseEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ReleaseSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReleaseEdge: ReleaseEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Release))),
};

export interface IRemoveAssigneesFromAssignablePayload {
  readonly __typename: "RemoveAssigneesFromAssignablePayload";
  readonly assignable: IAssignable | null;
  readonly clientMutationId: string | null;
}

interface RemoveAssigneesFromAssignablePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The item that was unassigned.
   */

  readonly assignable: <T extends Array<Selection>>(
    select: (t: AssignableSelector) => T
  ) => Field<"assignable", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const RemoveAssigneesFromAssignablePayload: RemoveAssigneesFromAssignablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The item that was unassigned.
   */

  assignable: (select) =>
    new Field(
      "assignable",
      undefined as never,
      new SelectionSet(select(Assignable))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IRemoveEnterpriseAdminPayload {
  readonly __typename: "RemoveEnterpriseAdminPayload";
  readonly admin: IUser | null;
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
  readonly viewer: IUser | null;
}

interface RemoveEnterpriseAdminPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The user who was removed as an administrator.
   */

  readonly admin: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"admin", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated enterprise.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of removing an administrator.
   */

  readonly message: () => Field<"message">;

  /**
   * @description The viewer performing the mutation.
   */

  readonly viewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"viewer", never, SelectionSet<T>>;
}

export const RemoveEnterpriseAdminPayload: RemoveEnterpriseAdminPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The user who was removed as an administrator.
   */

  admin: (select) =>
    new Field("admin", undefined as never, new SelectionSet(select(User))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated enterprise.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of removing an administrator.
   */
  message: () => new Field("message"),

  /**
   * @description The viewer performing the mutation.
   */

  viewer: (select) =>
    new Field("viewer", undefined as never, new SelectionSet(select(User))),
};

export interface IRemoveEnterpriseIdentityProviderPayload {
  readonly __typename: "RemoveEnterpriseIdentityProviderPayload";
  readonly clientMutationId: string | null;
  readonly identityProvider: IEnterpriseIdentityProvider | null;
}

interface RemoveEnterpriseIdentityProviderPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The identity provider that was removed from the enterprise.
   */

  readonly identityProvider: <T extends Array<Selection>>(
    select: (t: EnterpriseIdentityProviderSelector) => T
  ) => Field<"identityProvider", never, SelectionSet<T>>;
}

export const RemoveEnterpriseIdentityProviderPayload: RemoveEnterpriseIdentityProviderPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The identity provider that was removed from the enterprise.
   */

  identityProvider: (select) =>
    new Field(
      "identityProvider",
      undefined as never,
      new SelectionSet(select(EnterpriseIdentityProvider))
    ),
};

export interface IRemoveEnterpriseOrganizationPayload {
  readonly __typename: "RemoveEnterpriseOrganizationPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly organization: IOrganization | null;
  readonly viewer: IUser | null;
}

interface RemoveEnterpriseOrganizationPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated enterprise.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description The organization that was removed from the enterprise.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The viewer performing the mutation.
   */

  readonly viewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"viewer", never, SelectionSet<T>>;
}

export const RemoveEnterpriseOrganizationPayload: RemoveEnterpriseOrganizationPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated enterprise.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description The organization that was removed from the enterprise.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The viewer performing the mutation.
   */

  viewer: (select) =>
    new Field("viewer", undefined as never, new SelectionSet(select(User))),
};

export interface IRemoveLabelsFromLabelablePayload {
  readonly __typename: "RemoveLabelsFromLabelablePayload";
  readonly clientMutationId: string | null;
  readonly labelable: ILabelable | null;
}

interface RemoveLabelsFromLabelablePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The Labelable the labels were removed from.
   */

  readonly labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const RemoveLabelsFromLabelablePayload: RemoveLabelsFromLabelablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The Labelable the labels were removed from.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface IRemoveOutsideCollaboratorPayload {
  readonly __typename: "RemoveOutsideCollaboratorPayload";
  readonly clientMutationId: string | null;
  readonly removedUser: IUser | null;
}

interface RemoveOutsideCollaboratorPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The user that was removed as an outside collaborator.
   */

  readonly removedUser: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"removedUser", never, SelectionSet<T>>;
}

export const RemoveOutsideCollaboratorPayload: RemoveOutsideCollaboratorPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The user that was removed as an outside collaborator.
   */

  removedUser: (select) =>
    new Field(
      "removedUser",
      undefined as never,
      new SelectionSet(select(User))
    ),
};

export interface IRemoveReactionPayload {
  readonly __typename: "RemoveReactionPayload";
  readonly clientMutationId: string | null;
  readonly reaction: IReaction | null;
  readonly subject: IReactable | null;
}

interface RemoveReactionPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The reaction object.
   */

  readonly reaction: <T extends Array<Selection>>(
    select: (t: ReactionSelector) => T
  ) => Field<"reaction", never, SelectionSet<T>>;

  /**
   * @description The reactable subject.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: ReactableSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const RemoveReactionPayload: RemoveReactionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The reaction object.
   */

  reaction: (select) =>
    new Field(
      "reaction",
      undefined as never,
      new SelectionSet(select(Reaction))
    ),

  /**
   * @description The reactable subject.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(Reactable))
    ),
};

export interface IRemoveStarPayload {
  readonly __typename: "RemoveStarPayload";
  readonly clientMutationId: string | null;
  readonly starrable: IStarrable | null;
}

interface RemoveStarPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The starrable.
   */

  readonly starrable: <T extends Array<Selection>>(
    select: (t: StarrableSelector) => T
  ) => Field<"starrable", never, SelectionSet<T>>;
}

export const RemoveStarPayload: RemoveStarPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The starrable.
   */

  starrable: (select) =>
    new Field(
      "starrable",
      undefined as never,
      new SelectionSet(select(Starrable))
    ),
};

export interface IRemovedFromProjectEvent extends INode {
  readonly __typename: "RemovedFromProjectEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
}

interface RemovedFromProjectEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;
}

export const isRemovedFromProjectEvent = (
  object: Record<string, any>
): object is Partial<IRemovedFromProjectEvent> => {
  return object.__typename === "RemovedFromProjectEvent";
};

export const RemovedFromProjectEvent: RemovedFromProjectEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface IRenamedTitleEvent extends INode {
  readonly __typename: "RenamedTitleEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly currentTitle: string;
  readonly previousTitle: string;
  readonly subject: IRenamedTitleSubject;
}

interface RenamedTitleEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the current title of the issue or pull request.
   */

  readonly currentTitle: () => Field<"currentTitle">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the previous title of the issue or pull request.
   */

  readonly previousTitle: () => Field<"previousTitle">;

  /**
   * @description Subject that was renamed.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: RenamedTitleSubjectSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isRenamedTitleEvent = (
  object: Record<string, any>
): object is Partial<IRenamedTitleEvent> => {
  return object.__typename === "RenamedTitleEvent";
};

export const RenamedTitleEvent: RenamedTitleEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the current title of the issue or pull request.
   */
  currentTitle: () => new Field("currentTitle"),
  id: () => new Field("id"),

  /**
   * @description Identifies the previous title of the issue or pull request.
   */
  previousTitle: () => new Field("previousTitle"),

  /**
   * @description Subject that was renamed.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(RenamedTitleSubject))
    ),
};

export interface IReopenIssuePayload {
  readonly __typename: "ReopenIssuePayload";
  readonly clientMutationId: string | null;
  readonly issue: IIssue | null;
}

interface ReopenIssuePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue that was opened.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const ReopenIssuePayload: ReopenIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue that was opened.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IReopenPullRequestPayload {
  readonly __typename: "ReopenPullRequestPayload";
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
}

interface ReopenPullRequestPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that was reopened.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const ReopenPullRequestPayload: ReopenPullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that was reopened.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IReopenedEvent extends INode {
  readonly __typename: "ReopenedEvent";
  readonly actor: IActor | null;
  readonly closable: IClosable;
  readonly createdAt: unknown;
}

interface ReopenedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Object that was reopened.
   */

  readonly closable: <T extends Array<Selection>>(
    select: (t: ClosableSelector) => T
  ) => Field<"closable", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;
}

export const isReopenedEvent = (
  object: Record<string, any>
): object is Partial<IReopenedEvent> => {
  return object.__typename === "ReopenedEvent";
};

export const ReopenedEvent: ReopenedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Object that was reopened.
   */

  closable: (select) =>
    new Field(
      "closable",
      undefined as never,
      new SelectionSet(select(Closable))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),
};

export interface IRepoAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoAccessAuditEntry";
  readonly visibility: RepoAccessAuditEntryVisibility | null;
}

interface RepoAccessAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  readonly visibility: () => Field<"visibility">;
}

export const isRepoAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoAccessAuditEntry> => {
  return object.__typename === "RepoAccessAuditEntry";
};

export const RepoAccessAuditEntry: RepoAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoAddMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoAddMemberAuditEntry";
  readonly visibility: RepoAddMemberAuditEntryVisibility | null;
}

interface RepoAddMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  readonly visibility: () => Field<"visibility">;
}

export const isRepoAddMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoAddMemberAuditEntry> => {
  return object.__typename === "RepoAddMemberAuditEntry";
};

export const RepoAddMemberAuditEntry: RepoAddMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoAddTopicAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData,
    ITopicAuditEntryData {
  readonly __typename: "RepoAddTopicAuditEntry";
}

interface RepoAddTopicAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The name of the topic added to the repository
   */

  readonly topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;

  /**
   * @description The name of the topic added to the repository
   */

  readonly topicName: () => Field<"topicName">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoAddTopicAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoAddTopicAuditEntry> => {
  return object.__typename === "RepoAddTopicAuditEntry";
};

export const RepoAddTopicAuditEntry: RepoAddTopicAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The name of the topic added to the repository
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),

  /**
   * @description The name of the topic added to the repository
   */
  topicName: () => new Field("topicName"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoArchivedAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoArchivedAuditEntry";
  readonly visibility: RepoArchivedAuditEntryVisibility | null;
}

interface RepoArchivedAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  readonly visibility: () => Field<"visibility">;
}

export const isRepoArchivedAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoArchivedAuditEntry> => {
  return object.__typename === "RepoArchivedAuditEntry";
};

export const RepoArchivedAuditEntry: RepoArchivedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoChangeMergeSettingAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoChangeMergeSettingAuditEntry";
  readonly isEnabled: boolean | null;
  readonly mergeType: RepoChangeMergeSettingAuditEntryMergeType | null;
}

interface RepoChangeMergeSettingAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the change was to enable (true) or disable (false) the merge type
   */

  readonly isEnabled: () => Field<"isEnabled">;

  /**
   * @description The merge method affected by the change
   */

  readonly mergeType: () => Field<"mergeType">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoChangeMergeSettingAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoChangeMergeSettingAuditEntry> => {
  return object.__typename === "RepoChangeMergeSettingAuditEntry";
};

export const RepoChangeMergeSettingAuditEntry: RepoChangeMergeSettingAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the change was to enable (true) or disable (false) the merge type
   */
  isEnabled: () => new Field("isEnabled"),

  /**
   * @description The merge method affected by the change
   */
  mergeType: () => new Field("mergeType"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigDisableAnonymousGitAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigDisableAnonymousGitAccessAuditEntry";
}

interface RepoConfigDisableAnonymousGitAccessAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigDisableAnonymousGitAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigDisableAnonymousGitAccessAuditEntry> => {
  return object.__typename === "RepoConfigDisableAnonymousGitAccessAuditEntry";
};

export const RepoConfigDisableAnonymousGitAccessAuditEntry: RepoConfigDisableAnonymousGitAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigDisableCollaboratorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigDisableCollaboratorsOnlyAuditEntry";
}

interface RepoConfigDisableCollaboratorsOnlyAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigDisableCollaboratorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigDisableCollaboratorsOnlyAuditEntry> => {
  return object.__typename === "RepoConfigDisableCollaboratorsOnlyAuditEntry";
};

export const RepoConfigDisableCollaboratorsOnlyAuditEntry: RepoConfigDisableCollaboratorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigDisableContributorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigDisableContributorsOnlyAuditEntry";
}

interface RepoConfigDisableContributorsOnlyAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigDisableContributorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigDisableContributorsOnlyAuditEntry> => {
  return object.__typename === "RepoConfigDisableContributorsOnlyAuditEntry";
};

export const RepoConfigDisableContributorsOnlyAuditEntry: RepoConfigDisableContributorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigDisableSockpuppetDisallowedAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigDisableSockpuppetDisallowedAuditEntry";
}

interface RepoConfigDisableSockpuppetDisallowedAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigDisableSockpuppetDisallowedAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigDisableSockpuppetDisallowedAuditEntry> => {
  return (
    object.__typename === "RepoConfigDisableSockpuppetDisallowedAuditEntry"
  );
};

export const RepoConfigDisableSockpuppetDisallowedAuditEntry: RepoConfigDisableSockpuppetDisallowedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigEnableAnonymousGitAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigEnableAnonymousGitAccessAuditEntry";
}

interface RepoConfigEnableAnonymousGitAccessAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigEnableAnonymousGitAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigEnableAnonymousGitAccessAuditEntry> => {
  return object.__typename === "RepoConfigEnableAnonymousGitAccessAuditEntry";
};

export const RepoConfigEnableAnonymousGitAccessAuditEntry: RepoConfigEnableAnonymousGitAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigEnableCollaboratorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigEnableCollaboratorsOnlyAuditEntry";
}

interface RepoConfigEnableCollaboratorsOnlyAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigEnableCollaboratorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigEnableCollaboratorsOnlyAuditEntry> => {
  return object.__typename === "RepoConfigEnableCollaboratorsOnlyAuditEntry";
};

export const RepoConfigEnableCollaboratorsOnlyAuditEntry: RepoConfigEnableCollaboratorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigEnableContributorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigEnableContributorsOnlyAuditEntry";
}

interface RepoConfigEnableContributorsOnlyAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigEnableContributorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigEnableContributorsOnlyAuditEntry> => {
  return object.__typename === "RepoConfigEnableContributorsOnlyAuditEntry";
};

export const RepoConfigEnableContributorsOnlyAuditEntry: RepoConfigEnableContributorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigEnableSockpuppetDisallowedAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigEnableSockpuppetDisallowedAuditEntry";
}

interface RepoConfigEnableSockpuppetDisallowedAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigEnableSockpuppetDisallowedAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigEnableSockpuppetDisallowedAuditEntry> => {
  return object.__typename === "RepoConfigEnableSockpuppetDisallowedAuditEntry";
};

export const RepoConfigEnableSockpuppetDisallowedAuditEntry: RepoConfigEnableSockpuppetDisallowedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigLockAnonymousGitAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigLockAnonymousGitAccessAuditEntry";
}

interface RepoConfigLockAnonymousGitAccessAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigLockAnonymousGitAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigLockAnonymousGitAccessAuditEntry> => {
  return object.__typename === "RepoConfigLockAnonymousGitAccessAuditEntry";
};

export const RepoConfigLockAnonymousGitAccessAuditEntry: RepoConfigLockAnonymousGitAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigUnlockAnonymousGitAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoConfigUnlockAnonymousGitAccessAuditEntry";
}

interface RepoConfigUnlockAnonymousGitAccessAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoConfigUnlockAnonymousGitAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigUnlockAnonymousGitAccessAuditEntry> => {
  return object.__typename === "RepoConfigUnlockAnonymousGitAccessAuditEntry";
};

export const RepoConfigUnlockAnonymousGitAccessAuditEntry: RepoConfigUnlockAnonymousGitAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoCreateAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoCreateAuditEntry";
  readonly forkParentName: string | null;
  readonly forkSourceName: string | null;
  readonly visibility: RepoCreateAuditEntryVisibility | null;
}

interface RepoCreateAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The name of the parent repository for this forked repository.
   */

  readonly forkParentName: () => Field<"forkParentName">;

  /**
   * @description The name of the root repository for this netork.
   */

  readonly forkSourceName: () => Field<"forkSourceName">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  readonly visibility: () => Field<"visibility">;
}

export const isRepoCreateAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoCreateAuditEntry> => {
  return object.__typename === "RepoCreateAuditEntry";
};

export const RepoCreateAuditEntry: RepoCreateAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The name of the parent repository for this forked repository.
   */
  forkParentName: () => new Field("forkParentName"),

  /**
   * @description The name of the root repository for this netork.
   */
  forkSourceName: () => new Field("forkSourceName"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoDestroyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoDestroyAuditEntry";
  readonly visibility: RepoDestroyAuditEntryVisibility | null;
}

interface RepoDestroyAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  readonly visibility: () => Field<"visibility">;
}

export const isRepoDestroyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoDestroyAuditEntry> => {
  return object.__typename === "RepoDestroyAuditEntry";
};

export const RepoDestroyAuditEntry: RepoDestroyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoRemoveMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  readonly __typename: "RepoRemoveMemberAuditEntry";
  readonly visibility: RepoRemoveMemberAuditEntryVisibility | null;
}

interface RepoRemoveMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  readonly visibility: () => Field<"visibility">;
}

export const isRepoRemoveMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoRemoveMemberAuditEntry> => {
  return object.__typename === "RepoRemoveMemberAuditEntry";
};

export const RepoRemoveMemberAuditEntry: RepoRemoveMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoRemoveTopicAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData,
    ITopicAuditEntryData {
  readonly __typename: "RepoRemoveTopicAuditEntry";
}

interface RepoRemoveTopicAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The name of the topic added to the repository
   */

  readonly topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;

  /**
   * @description The name of the topic added to the repository
   */

  readonly topicName: () => Field<"topicName">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepoRemoveTopicAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoRemoveTopicAuditEntry> => {
  return object.__typename === "RepoRemoveTopicAuditEntry";
};

export const RepoRemoveTopicAuditEntry: RepoRemoveTopicAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The name of the topic added to the repository
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),

  /**
   * @description The name of the topic added to the repository
   */
  topicName: () => new Field("topicName"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepository
  extends INode,
    IPackageOwner,
    IProjectOwner,
    IRepositoryInfo,
    IStarrable,
    ISubscribable,
    IUniformResourceLocatable {
  readonly __typename: "Repository";
  readonly assignableUsers: IUserConnection;
  readonly branchProtectionRules: IBranchProtectionRuleConnection;
  readonly codeOfConduct: ICodeOfConduct | null;
  readonly collaborators: IRepositoryCollaboratorConnection | null;
  readonly commitComments: ICommitCommentConnection;
  readonly contactLinks: ReadonlyArray<IRepositoryContactLink> | null;
  readonly databaseId: number | null;
  readonly defaultBranchRef: IRef | null;
  readonly deleteBranchOnMerge: boolean;
  readonly deployKeys: IDeployKeyConnection;
  readonly deployments: IDeploymentConnection;
  readonly diskUsage: number | null;
  readonly forks: IRepositoryConnection;
  readonly fundingLinks: ReadonlyArray<IFundingLink>;
  readonly interactionAbility: IRepositoryInteractionAbility | null;
  readonly isBlankIssuesEnabled: boolean;
  readonly isDisabled: boolean;
  readonly isEmpty: boolean;
  readonly isSecurityPolicyEnabled: boolean | null;
  readonly isUserConfigurationRepository: boolean;
  readonly issue: IIssue | null;
  readonly issueOrPullRequest: IIssueOrPullRequest | null;
  readonly issueTemplates: ReadonlyArray<IIssueTemplate> | null;
  readonly issues: IIssueConnection;
  readonly label: ILabel | null;
  readonly labels: ILabelConnection | null;
  readonly languages: ILanguageConnection | null;
  readonly mentionableUsers: IUserConnection;
  readonly mergeCommitAllowed: boolean;
  readonly milestone: IMilestone | null;
  readonly milestones: IMilestoneConnection | null;
  readonly object: IGitObject | null;
  readonly parent: IRepository | null;
  readonly primaryLanguage: ILanguage | null;
  readonly pullRequest: IPullRequest | null;
  readonly pullRequests: IPullRequestConnection;
  readonly rebaseMergeAllowed: boolean;
  readonly ref: IRef | null;
  readonly refs: IRefConnection | null;
  readonly release: IRelease | null;
  readonly releases: IReleaseConnection;
  readonly repositoryTopics: IRepositoryTopicConnection;
  readonly securityPolicyUrl: unknown | null;
  readonly squashMergeAllowed: boolean;
  readonly sshUrl: unknown;
  readonly submodules: ISubmoduleConnection;
  readonly tempCloneToken: string | null;
  readonly templateRepository: IRepository | null;
  readonly viewerCanAdminister: boolean;
  readonly viewerCanUpdateTopics: boolean;
  readonly viewerDefaultCommitEmail: string | null;
  readonly viewerDefaultMergeMethod: PullRequestMergeMethod;
  readonly viewerPermission: RepositoryPermission | null;
  readonly viewerPossibleCommitEmails: ReadonlyArray<string> | null;
  readonly vulnerabilityAlerts: IRepositoryVulnerabilityAlertConnection | null;
  readonly watchers: IUserConnection;
}

interface RepositorySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of users that can be assigned to issues in this repository.
   */

  readonly assignableUsers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "assignableUsers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of branch protection rules for this repository.
   */

  readonly branchProtectionRules: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: BranchProtectionRuleConnectionSelector) => T
  ) => Field<
    "branchProtectionRules",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns the code of conduct for this repository
   */

  readonly codeOfConduct: <T extends Array<Selection>>(
    select: (t: CodeOfConductSelector) => T
  ) => Field<"codeOfConduct", never, SelectionSet<T>>;

  /**
   * @description A list of collaborators associated with the repository.
   */

  readonly collaborators: <T extends Array<Selection>>(
    variables: {
      affiliation?: Variable<"affiliation"> | CollaboratorAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: RepositoryCollaboratorConnectionSelector) => T
  ) => Field<
    "collaborators",
    [
      Argument<
        "affiliation",
        Variable<"affiliation"> | CollaboratorAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of commit comments associated with the repository.
   */

  readonly commitComments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "commitComments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns a list of contact links associated to the repository
   */

  readonly contactLinks: <T extends Array<Selection>>(
    select: (t: RepositoryContactLinkSelector) => T
  ) => Field<"contactLinks", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The Ref associated with the repository's default branch.
   */

  readonly defaultBranchRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"defaultBranchRef", never, SelectionSet<T>>;

  /**
   * @description Whether or not branches are automatically deleted when merged in this repository.
   */

  readonly deleteBranchOnMerge: () => Field<"deleteBranchOnMerge">;

  /**
   * @description A list of deploy keys that are on this repository.
   */

  readonly deployKeys: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: DeployKeyConnectionSelector) => T
  ) => Field<
    "deployKeys",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Deployments associated with the repository
   */

  readonly deployments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      environments?: Variable<"environments"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | DeploymentOrder;
    },
    select: (t: DeploymentConnectionSelector) => T
  ) => Field<
    "deployments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"environments", Variable<"environments"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | DeploymentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The description of the repository.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The description of the repository rendered to HTML.
   */

  readonly descriptionHTML: () => Field<"descriptionHTML">;

  /**
   * @description The number of kilobytes this repository occupies on disk.
   */

  readonly diskUsage: () => Field<"diskUsage">;

  /**
   * @description Returns how many forks there are of this repository in the whole network.
   */

  readonly forkCount: () => Field<"forkCount">;

  /**
   * @description A list of direct forked repositories.
   */

  readonly forks: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "forks",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The funding links for this repository
   */

  readonly fundingLinks: <T extends Array<Selection>>(
    select: (t: FundingLinkSelector) => T
  ) => Field<"fundingLinks", never, SelectionSet<T>>;

  /**
   * @description Indicates if the repository has issues feature enabled.
   */

  readonly hasIssuesEnabled: () => Field<"hasIssuesEnabled">;

  /**
   * @description Indicates if the repository has the Projects feature enabled.
   */

  readonly hasProjectsEnabled: () => Field<"hasProjectsEnabled">;

  /**
   * @description Indicates if the repository has wiki feature enabled.
   */

  readonly hasWikiEnabled: () => Field<"hasWikiEnabled">;

  /**
   * @description The repository's URL.
   */

  readonly homepageUrl: () => Field<"homepageUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The interaction ability settings for this repository.
   */

  readonly interactionAbility: <T extends Array<Selection>>(
    select: (t: RepositoryInteractionAbilitySelector) => T
  ) => Field<"interactionAbility", never, SelectionSet<T>>;

  /**
   * @description Indicates if the repository is unmaintained.
   */

  readonly isArchived: () => Field<"isArchived">;

  /**
   * @description Returns true if blank issue creation is allowed
   */

  readonly isBlankIssuesEnabled: () => Field<"isBlankIssuesEnabled">;

  /**
   * @description Returns whether or not this repository disabled.
   */

  readonly isDisabled: () => Field<"isDisabled">;

  /**
   * @description Returns whether or not this repository is empty.
   */

  readonly isEmpty: () => Field<"isEmpty">;

  /**
   * @description Identifies if the repository is a fork.
   */

  readonly isFork: () => Field<"isFork">;

  /**
   * @description Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
   */

  readonly isInOrganization: () => Field<"isInOrganization">;

  /**
   * @description Indicates if the repository has been locked or not.
   */

  readonly isLocked: () => Field<"isLocked">;

  /**
   * @description Identifies if the repository is a mirror.
   */

  readonly isMirror: () => Field<"isMirror">;

  /**
   * @description Identifies if the repository is private.
   */

  readonly isPrivate: () => Field<"isPrivate">;

  /**
   * @description Returns true if this repository has a security policy
   */

  readonly isSecurityPolicyEnabled: () => Field<"isSecurityPolicyEnabled">;

  /**
   * @description Identifies if the repository is a template that can be used to generate new repositories.
   */

  readonly isTemplate: () => Field<"isTemplate">;

  /**
   * @description Is this repository a user configuration repository?
   */

  readonly isUserConfigurationRepository: () => Field<"isUserConfigurationRepository">;

  /**
   * @description Returns a single issue from the current repository by number.
   */

  readonly issue: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: IssueSelector) => T
  ) => Field<
    "issue",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description Returns a single issue-like object from the current repository by number.
   */

  readonly issueOrPullRequest: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<
    "issueOrPullRequest",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description Returns a list of issue templates associated to the repository
   */

  readonly issueTemplates: <T extends Array<Selection>>(
    select: (t: IssueTemplateSelector) => T
  ) => Field<"issueTemplates", never, SelectionSet<T>>;

  /**
   * @description A list of issues that have been opened in the repository.
   */

  readonly issues: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | IssueFilters;
      first?: Variable<"first"> | number;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | IssueState;
    },
    select: (t: IssueConnectionSelector) => T
  ) => Field<
    "issues",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | IssueFilters>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | IssueState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns a single label by name
   */

  readonly label: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: LabelSelector) => T
  ) => Field<
    "label",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description A list of labels associated with the repository.
   */

  readonly labels: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LabelOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: LabelConnectionSelector) => T
  ) => Field<
    "labels",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LabelOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list containing a breakdown of the language composition of the repository.
   */

  readonly languages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LanguageOrder;
    },
    select: (t: LanguageConnectionSelector) => T
  ) => Field<
    "languages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LanguageOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The license associated with the repository
   */

  readonly licenseInfo: <T extends Array<Selection>>(
    select: (t: LicenseSelector) => T
  ) => Field<"licenseInfo", never, SelectionSet<T>>;

  /**
   * @description The reason the repository has been locked.
   */

  readonly lockReason: () => Field<"lockReason">;

  /**
   * @description A list of Users that can be mentioned in the context of the repository.
   */

  readonly mentionableUsers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "mentionableUsers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not PRs are merged with a merge commit on this repository.
   */

  readonly mergeCommitAllowed: () => Field<"mergeCommitAllowed">;

  /**
   * @description Returns a single milestone from the current repository by number.
   */

  readonly milestone: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: MilestoneSelector) => T
  ) => Field<
    "milestone",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of milestones associated with the repository.
   */

  readonly milestones: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | MilestoneOrder;
      query?: Variable<"query"> | string;
      states?: Variable<"states"> | MilestoneState;
    },
    select: (t: MilestoneConnectionSelector) => T
  ) => Field<
    "milestones",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | MilestoneOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"states", Variable<"states"> | MilestoneState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository's original mirror URL.
   */

  readonly mirrorUrl: () => Field<"mirrorUrl">;

  /**
   * @description The name of the repository.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The repository's name with owner.
   */

  readonly nameWithOwner: () => Field<"nameWithOwner">;

  /**
   * @description A Git object in the repository
   */

  readonly object: <T extends Array<Selection>>(
    variables: {
      expression?: Variable<"expression"> | string;
      oid?: Variable<"oid"> | unknown;
    },
    select: (t: GitObjectSelector) => T
  ) => Field<
    "object",
    [
      Argument<"expression", Variable<"expression"> | string>,
      Argument<"oid", Variable<"oid"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The image used to represent this repository in Open Graph data.
   */

  readonly openGraphImageUrl: () => Field<"openGraphImageUrl">;

  /**
   * @description The User owner of the repository.
   */

  readonly owner: <T extends Array<Selection>>(
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description A list of packages under the owner.
   */

  readonly packages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      names?: Variable<"names"> | string;
      orderBy?: Variable<"orderBy"> | PackageOrder;
      packageType?: Variable<"packageType"> | PackageType;
      repositoryId?: Variable<"repositoryId"> | string;
    },
    select: (t: PackageConnectionSelector) => T
  ) => Field<
    "packages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"names", Variable<"names"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | PackageOrder>,
      Argument<"packageType", Variable<"packageType"> | PackageType>,
      Argument<"repositoryId", Variable<"repositoryId"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository parent, if this is a fork.
   */

  readonly parent: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"parent", never, SelectionSet<T>>;

  /**
   * @description The primary language of the repository's code.
   */

  readonly primaryLanguage: <T extends Array<Selection>>(
    select: (t: LanguageSelector) => T
  ) => Field<"primaryLanguage", never, SelectionSet<T>>;

  /**
   * @description Find project by number.
   */

  readonly project: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: ProjectSelector) => T
  ) => Field<
    "project",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of projects under the owner.
   */

  readonly projects: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ProjectOrder;
      search?: Variable<"search"> | string;
      states?: Variable<"states"> | ProjectState;
    },
    select: (t: ProjectConnectionSelector) => T
  ) => Field<
    "projects",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ProjectOrder>,
      Argument<"search", Variable<"search"> | string>,
      Argument<"states", Variable<"states"> | ProjectState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing the repository's projects
   */

  readonly projectsResourcePath: () => Field<"projectsResourcePath">;

  /**
   * @description The HTTP URL listing the repository's projects
   */

  readonly projectsUrl: () => Field<"projectsUrl">;

  /**
   * @description Returns a single pull request from the current repository by number.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: PullRequestSelector) => T
  ) => Field<
    "pullRequest",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of pull requests that have been opened in the repository.
   */

  readonly pullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "pullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies when the repository was last pushed to.
   */

  readonly pushedAt: () => Field<"pushedAt">;

  /**
   * @description Whether or not rebase-merging is enabled on this repository.
   */

  readonly rebaseMergeAllowed: () => Field<"rebaseMergeAllowed">;

  /**
   * @description Fetch a given ref from the repository
   */

  readonly ref: <T extends Array<Selection>>(
    variables: { qualifiedName?: Variable<"qualifiedName"> | string },
    select: (t: RefSelector) => T
  ) => Field<
    "ref",
    [Argument<"qualifiedName", Variable<"qualifiedName"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Fetch a list of refs from the repository
   */

  readonly refs: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      direction?: Variable<"direction"> | OrderDirection;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RefOrder;
      query?: Variable<"query"> | string;
      refPrefix?: Variable<"refPrefix"> | string;
    },
    select: (t: RefConnectionSelector) => T
  ) => Field<
    "refs",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"direction", Variable<"direction"> | OrderDirection>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RefOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"refPrefix", Variable<"refPrefix"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Lookup a single release given various criteria.
   */

  readonly release: <T extends Array<Selection>>(
    variables: { tagName?: Variable<"tagName"> | string },
    select: (t: ReleaseSelector) => T
  ) => Field<
    "release",
    [Argument<"tagName", Variable<"tagName"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description List of releases which are dependent on this repository.
   */

  readonly releases: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReleaseOrder;
    },
    select: (t: ReleaseConnectionSelector) => T
  ) => Field<
    "releases",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReleaseOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of applied repository-topic associations for this repository.
   */

  readonly repositoryTopics: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: RepositoryTopicConnectionSelector) => T
  ) => Field<
    "repositoryTopics",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this repository
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The security policy URL.
   */

  readonly securityPolicyUrl: () => Field<"securityPolicyUrl">;

  /**
   * @description A description of the repository, rendered to HTML without any links in it.
   */

  readonly shortDescriptionHTML: (variables: {
    limit?: Variable<"limit"> | number;
  }) => Field<
    "shortDescriptionHTML",
    [Argument<"limit", Variable<"limit"> | number>]
  >;

  /**
   * @description Whether or not squash-merging is enabled on this repository.
   */

  readonly squashMergeAllowed: () => Field<"squashMergeAllowed">;

  /**
   * @description The SSH URL to clone this repository
   */

  readonly sshUrl: () => Field<"sshUrl">;

  /**
   * @description Returns a count of how many stargazers there are on this object
   */

  readonly stargazerCount: () => Field<"stargazerCount">;

  /**
   * @description A list of users who have starred this starrable.
   */

  readonly stargazers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
    },
    select: (t: StargazerConnectionSelector) => T
  ) => Field<
    "stargazers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>
    ],
    SelectionSet<T>
  >;

  /**
     * @description Returns a list of all submodules in this repository parsed from the
.gitmodules file as of the default branch's HEAD commit.
     */

  readonly submodules: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: SubmoduleConnectionSelector) => T
  ) => Field<
    "submodules",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Temporary authentication token for cloning this repository.
   */

  readonly tempCloneToken: () => Field<"tempCloneToken">;

  /**
   * @description The repository from which this repository was generated, if any.
   */

  readonly templateRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"templateRepository", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this repository
   */

  readonly url: () => Field<"url">;

  /**
   * @description Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
   */

  readonly usesCustomOpenGraphImage: () => Field<"usesCustomOpenGraphImage">;

  /**
   * @description Indicates whether the viewer has admin permissions on this repository.
   */

  readonly viewerCanAdminister: () => Field<"viewerCanAdminister">;

  /**
   * @description Can the current viewer create new projects on this owner.
   */

  readonly viewerCanCreateProjects: () => Field<"viewerCanCreateProjects">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  readonly viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Indicates whether the viewer can update the topics of this repository.
   */

  readonly viewerCanUpdateTopics: () => Field<"viewerCanUpdateTopics">;

  /**
   * @description The last commit email for the viewer.
   */

  readonly viewerDefaultCommitEmail: () => Field<"viewerDefaultCommitEmail">;

  /**
   * @description The last used merge method by the viewer or the default for the repository.
   */

  readonly viewerDefaultMergeMethod: () => Field<"viewerDefaultMergeMethod">;

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */

  readonly viewerHasStarred: () => Field<"viewerHasStarred">;

  /**
   * @description The users permission level on the repository. Will return null if authenticated as an GitHub App.
   */

  readonly viewerPermission: () => Field<"viewerPermission">;

  /**
   * @description A list of emails this viewer can commit with.
   */

  readonly viewerPossibleCommitEmails: () => Field<"viewerPossibleCommitEmails">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  readonly viewerSubscription: () => Field<"viewerSubscription">;

  /**
   * @description A list of vulnerability alerts that are on this repository.
   */

  readonly vulnerabilityAlerts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: RepositoryVulnerabilityAlertConnectionSelector) => T
  ) => Field<
    "vulnerabilityAlerts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users watching the repository.
   */

  readonly watchers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "watchers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;
}

export const isRepository = (
  object: Record<string, any>
): object is Partial<IRepository> => {
  return object.__typename === "Repository";
};

export const Repository: RepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of users that can be assigned to issues in this repository.
   */

  assignableUsers: (variables, select) =>
    new Field(
      "assignableUsers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description A list of branch protection rules for this repository.
   */

  branchProtectionRules: (variables, select) =>
    new Field(
      "branchProtectionRules",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(BranchProtectionRuleConnection))
    ),

  /**
   * @description Returns the code of conduct for this repository
   */

  codeOfConduct: (select) =>
    new Field(
      "codeOfConduct",
      undefined as never,
      new SelectionSet(select(CodeOfConduct))
    ),

  /**
   * @description A list of collaborators associated with the repository.
   */

  collaborators: (variables, select) =>
    new Field(
      "collaborators",
      [
        new Argument(
          "affiliation",
          variables.affiliation,
          CollaboratorAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(RepositoryCollaboratorConnection))
    ),

  /**
   * @description A list of commit comments associated with the repository.
   */

  commitComments: (variables, select) =>
    new Field(
      "commitComments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description Returns a list of contact links associated to the repository
   */

  contactLinks: (select) =>
    new Field(
      "contactLinks",
      undefined as never,
      new SelectionSet(select(RepositoryContactLink))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The Ref associated with the repository's default branch.
   */

  defaultBranchRef: (select) =>
    new Field(
      "defaultBranchRef",
      undefined as never,
      new SelectionSet(select(Ref))
    ),

  /**
   * @description Whether or not branches are automatically deleted when merged in this repository.
   */
  deleteBranchOnMerge: () => new Field("deleteBranchOnMerge"),

  /**
   * @description A list of deploy keys that are on this repository.
   */

  deployKeys: (variables, select) =>
    new Field(
      "deployKeys",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(DeployKeyConnection))
    ),

  /**
   * @description Deployments associated with the repository
   */

  deployments: (variables, select) =>
    new Field(
      "deployments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("environments", variables.environments),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(DeploymentConnection))
    ),

  /**
   * @description The description of the repository.
   */
  description: () => new Field("description"),

  /**
   * @description The description of the repository rendered to HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),

  /**
   * @description The number of kilobytes this repository occupies on disk.
   */
  diskUsage: () => new Field("diskUsage"),

  /**
   * @description Returns how many forks there are of this repository in the whole network.
   */
  forkCount: () => new Field("forkCount"),

  /**
   * @description A list of direct forked repositories.
   */

  forks: (variables, select) =>
    new Field(
      "forks",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description The funding links for this repository
   */

  fundingLinks: (select) =>
    new Field(
      "fundingLinks",
      undefined as never,
      new SelectionSet(select(FundingLink))
    ),

  /**
   * @description Indicates if the repository has issues feature enabled.
   */
  hasIssuesEnabled: () => new Field("hasIssuesEnabled"),

  /**
   * @description Indicates if the repository has the Projects feature enabled.
   */
  hasProjectsEnabled: () => new Field("hasProjectsEnabled"),

  /**
   * @description Indicates if the repository has wiki feature enabled.
   */
  hasWikiEnabled: () => new Field("hasWikiEnabled"),

  /**
   * @description The repository's URL.
   */
  homepageUrl: () => new Field("homepageUrl"),
  id: () => new Field("id"),

  /**
   * @description The interaction ability settings for this repository.
   */

  interactionAbility: (select) =>
    new Field(
      "interactionAbility",
      undefined as never,
      new SelectionSet(select(RepositoryInteractionAbility))
    ),

  /**
   * @description Indicates if the repository is unmaintained.
   */
  isArchived: () => new Field("isArchived"),

  /**
   * @description Returns true if blank issue creation is allowed
   */
  isBlankIssuesEnabled: () => new Field("isBlankIssuesEnabled"),

  /**
   * @description Returns whether or not this repository disabled.
   */
  isDisabled: () => new Field("isDisabled"),

  /**
   * @description Returns whether or not this repository is empty.
   */
  isEmpty: () => new Field("isEmpty"),

  /**
   * @description Identifies if the repository is a fork.
   */
  isFork: () => new Field("isFork"),

  /**
   * @description Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
   */
  isInOrganization: () => new Field("isInOrganization"),

  /**
   * @description Indicates if the repository has been locked or not.
   */
  isLocked: () => new Field("isLocked"),

  /**
   * @description Identifies if the repository is a mirror.
   */
  isMirror: () => new Field("isMirror"),

  /**
   * @description Identifies if the repository is private.
   */
  isPrivate: () => new Field("isPrivate"),

  /**
   * @description Returns true if this repository has a security policy
   */
  isSecurityPolicyEnabled: () => new Field("isSecurityPolicyEnabled"),

  /**
   * @description Identifies if the repository is a template that can be used to generate new repositories.
   */
  isTemplate: () => new Field("isTemplate"),

  /**
   * @description Is this repository a user configuration repository?
   */
  isUserConfigurationRepository: () =>
    new Field("isUserConfigurationRepository"),

  /**
   * @description Returns a single issue from the current repository by number.
   */

  issue: (variables, select) =>
    new Field(
      "issue",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Issue))
    ),

  /**
   * @description Returns a single issue-like object from the current repository by number.
   */

  issueOrPullRequest: (variables, select) =>
    new Field(
      "issueOrPullRequest",
      [new Argument("number", variables.number)],
      new SelectionSet(select(IssueOrPullRequest))
    ),

  /**
   * @description Returns a list of issue templates associated to the repository
   */

  issueTemplates: (select) =>
    new Field(
      "issueTemplates",
      undefined as never,
      new SelectionSet(select(IssueTemplate))
    ),

  /**
   * @description A list of issues that have been opened in the repository.
   */

  issues: (variables, select) =>
    new Field(
      "issues",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, IssueState),
      ],
      new SelectionSet(select(IssueConnection))
    ),

  /**
   * @description Returns a single label by name
   */

  label: (variables, select) =>
    new Field(
      "label",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Label))
    ),

  /**
   * @description A list of labels associated with the repository.
   */

  labels: (variables, select) =>
    new Field(
      "labels",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(LabelConnection))
    ),

  /**
   * @description A list containing a breakdown of the language composition of the repository.
   */

  languages: (variables, select) =>
    new Field(
      "languages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(LanguageConnection))
    ),

  /**
   * @description The license associated with the repository
   */

  licenseInfo: (select) =>
    new Field(
      "licenseInfo",
      undefined as never,
      new SelectionSet(select(License))
    ),

  /**
   * @description The reason the repository has been locked.
   */
  lockReason: () => new Field("lockReason"),

  /**
   * @description A list of Users that can be mentioned in the context of the repository.
   */

  mentionableUsers: (variables, select) =>
    new Field(
      "mentionableUsers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description Whether or not PRs are merged with a merge commit on this repository.
   */
  mergeCommitAllowed: () => new Field("mergeCommitAllowed"),

  /**
   * @description Returns a single milestone from the current repository by number.
   */

  milestone: (variables, select) =>
    new Field(
      "milestone",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Milestone))
    ),

  /**
   * @description A list of milestones associated with the repository.
   */

  milestones: (variables, select) =>
    new Field(
      "milestones",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("states", variables.states, MilestoneState),
      ],
      new SelectionSet(select(MilestoneConnection))
    ),

  /**
   * @description The repository's original mirror URL.
   */
  mirrorUrl: () => new Field("mirrorUrl"),

  /**
   * @description The name of the repository.
   */
  name: () => new Field("name"),

  /**
   * @description The repository's name with owner.
   */
  nameWithOwner: () => new Field("nameWithOwner"),

  /**
   * @description A Git object in the repository
   */

  object: (variables, select) =>
    new Field(
      "object",
      [
        new Argument("expression", variables.expression),
        new Argument("oid", variables.oid),
      ],
      new SelectionSet(select(GitObject))
    ),

  /**
   * @description The image used to represent this repository in Open Graph data.
   */
  openGraphImageUrl: () => new Field("openGraphImageUrl"),

  /**
   * @description The User owner of the repository.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description A list of packages under the owner.
   */

  packages: (variables, select) =>
    new Field(
      "packages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("names", variables.names),
        new Argument("orderBy", variables.orderBy),
        new Argument("packageType", variables.packageType, PackageType),
        new Argument("repositoryId", variables.repositoryId),
      ],
      new SelectionSet(select(PackageConnection))
    ),

  /**
   * @description The repository parent, if this is a fork.
   */

  parent: (select) =>
    new Field(
      "parent",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The primary language of the repository's code.
   */

  primaryLanguage: (select) =>
    new Field(
      "primaryLanguage",
      undefined as never,
      new SelectionSet(select(Language))
    ),

  /**
   * @description Find project by number.
   */

  project: (variables, select) =>
    new Field(
      "project",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Project))
    ),

  /**
   * @description A list of projects under the owner.
   */

  projects: (variables, select) =>
    new Field(
      "projects",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("search", variables.search),
        new Argument("states", variables.states, ProjectState),
      ],
      new SelectionSet(select(ProjectConnection))
    ),

  /**
   * @description The HTTP path listing the repository's projects
   */
  projectsResourcePath: () => new Field("projectsResourcePath"),

  /**
   * @description The HTTP URL listing the repository's projects
   */
  projectsUrl: () => new Field("projectsUrl"),

  /**
   * @description Returns a single pull request from the current repository by number.
   */

  pullRequest: (variables, select) =>
    new Field(
      "pullRequest",
      [new Argument("number", variables.number)],
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description A list of pull requests that have been opened in the repository.
   */

  pullRequests: (variables, select) =>
    new Field(
      "pullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description Identifies when the repository was last pushed to.
   */
  pushedAt: () => new Field("pushedAt"),

  /**
   * @description Whether or not rebase-merging is enabled on this repository.
   */
  rebaseMergeAllowed: () => new Field("rebaseMergeAllowed"),

  /**
   * @description Fetch a given ref from the repository
   */

  ref: (variables, select) =>
    new Field(
      "ref",
      [new Argument("qualifiedName", variables.qualifiedName)],
      new SelectionSet(select(Ref))
    ),

  /**
   * @description Fetch a list of refs from the repository
   */

  refs: (variables, select) =>
    new Field(
      "refs",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("direction", variables.direction, OrderDirection),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("refPrefix", variables.refPrefix),
      ],
      new SelectionSet(select(RefConnection))
    ),

  /**
   * @description Lookup a single release given various criteria.
   */

  release: (variables, select) =>
    new Field(
      "release",
      [new Argument("tagName", variables.tagName)],
      new SelectionSet(select(Release))
    ),

  /**
   * @description List of releases which are dependent on this repository.
   */

  releases: (variables, select) =>
    new Field(
      "releases",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReleaseConnection))
    ),

  /**
   * @description A list of applied repository-topic associations for this repository.
   */

  repositoryTopics: (variables, select) =>
    new Field(
      "repositoryTopics",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(RepositoryTopicConnection))
    ),

  /**
   * @description The HTTP path for this repository
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The security policy URL.
   */
  securityPolicyUrl: () => new Field("securityPolicyUrl"),

  /**
   * @description A description of the repository, rendered to HTML without any links in it.
   */
  shortDescriptionHTML: (variables) => new Field("shortDescriptionHTML"),

  /**
   * @description Whether or not squash-merging is enabled on this repository.
   */
  squashMergeAllowed: () => new Field("squashMergeAllowed"),

  /**
   * @description The SSH URL to clone this repository
   */
  sshUrl: () => new Field("sshUrl"),

  /**
   * @description Returns a count of how many stargazers there are on this object
   */
  stargazerCount: () => new Field("stargazerCount"),

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: (variables, select) =>
    new Field(
      "stargazers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(StargazerConnection))
    ),

  /**
     * @description Returns a list of all submodules in this repository parsed from the
.gitmodules file as of the default branch's HEAD commit.
     */

  submodules: (variables, select) =>
    new Field(
      "submodules",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(SubmoduleConnection))
    ),

  /**
   * @description Temporary authentication token for cloning this repository.
   */
  tempCloneToken: () => new Field("tempCloneToken"),

  /**
   * @description The repository from which this repository was generated, if any.
   */

  templateRepository: (select) =>
    new Field(
      "templateRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this repository
   */
  url: () => new Field("url"),

  /**
   * @description Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
   */
  usesCustomOpenGraphImage: () => new Field("usesCustomOpenGraphImage"),

  /**
   * @description Indicates whether the viewer has admin permissions on this repository.
   */
  viewerCanAdminister: () => new Field("viewerCanAdminister"),

  /**
   * @description Can the current viewer create new projects on this owner.
   */
  viewerCanCreateProjects: () => new Field("viewerCanCreateProjects"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Indicates whether the viewer can update the topics of this repository.
   */
  viewerCanUpdateTopics: () => new Field("viewerCanUpdateTopics"),

  /**
   * @description The last commit email for the viewer.
   */
  viewerDefaultCommitEmail: () => new Field("viewerDefaultCommitEmail"),

  /**
   * @description The last used merge method by the viewer or the default for the repository.
   */
  viewerDefaultMergeMethod: () => new Field("viewerDefaultMergeMethod"),

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */
  viewerHasStarred: () => new Field("viewerHasStarred"),

  /**
   * @description The users permission level on the repository. Will return null if authenticated as an GitHub App.
   */
  viewerPermission: () => new Field("viewerPermission"),

  /**
   * @description A list of emails this viewer can commit with.
   */
  viewerPossibleCommitEmails: () => new Field("viewerPossibleCommitEmails"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),

  /**
   * @description A list of vulnerability alerts that are on this repository.
   */

  vulnerabilityAlerts: (variables, select) =>
    new Field(
      "vulnerabilityAlerts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(RepositoryVulnerabilityAlertConnection))
    ),

  /**
   * @description A list of users watching the repository.
   */

  watchers: (variables, select) =>
    new Field(
      "watchers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),
};

export interface IRepositoryAuditEntryData {
  readonly __typename: string;
  readonly repository: IRepository | null;
  readonly repositoryName: string | null;
  readonly repositoryResourcePath: unknown | null;
  readonly repositoryUrl: unknown | null;
}

interface RepositoryAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "OrgRestoreMemberMembershipRepositoryAuditEntryData"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "OrgRestoreMemberMembershipRepositoryAuditEntryData"
        ? OrgRestoreMemberMembershipRepositoryAuditEntryDataSelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RepositoryAuditEntryData: RepositoryAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  on: (type, select) => {
    switch (type) {
      case "OrgRestoreMemberMembershipRepositoryAuditEntryData": {
        return new InlineFragment(
          new NamedType(
            "OrgRestoreMemberMembershipRepositoryAuditEntryData"
          ) as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipRepositoryAuditEntryData as any)
          )
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "RepositoryAuditEntryData",
        });
    }
  },
};

export interface IRepositoryCollaboratorConnection {
  readonly __typename: "RepositoryCollaboratorConnection";
  readonly edges: ReadonlyArray<IRepositoryCollaboratorEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface RepositoryCollaboratorConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: RepositoryCollaboratorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const RepositoryCollaboratorConnection: RepositoryCollaboratorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryCollaboratorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRepositoryCollaboratorEdge {
  readonly __typename: "RepositoryCollaboratorEdge";
  readonly cursor: string;
  readonly node: IUser;
  readonly permission: RepositoryPermission;
  readonly permissionSources: ReadonlyArray<IPermissionSource> | null;
}

interface RepositoryCollaboratorEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The permission the user has on the repository.
   */

  readonly permission: () => Field<"permission">;

  /**
   * @description A list of sources for the user's access to the repository.
   */

  readonly permissionSources: <T extends Array<Selection>>(
    select: (t: PermissionSourceSelector) => T
  ) => Field<"permissionSources", never, SelectionSet<T>>;
}

export const RepositoryCollaboratorEdge: RepositoryCollaboratorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The permission the user has on the repository.
   */
  permission: () => new Field("permission"),

  /**
   * @description A list of sources for the user's access to the repository.
   */

  permissionSources: (select) =>
    new Field(
      "permissionSources",
      undefined as never,
      new SelectionSet(select(PermissionSource))
    ),
};

export interface IRepositoryConnection {
  readonly __typename: "RepositoryConnection";
  readonly edges: ReadonlyArray<IRepositoryEdge> | null;
  readonly nodes: ReadonlyArray<IRepository> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
  readonly totalDiskUsage: number;
}

interface RepositoryConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: RepositoryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;

  /**
   * @description The total size in kilobytes of all repositories in the connection.
   */

  readonly totalDiskUsage: () => Field<"totalDiskUsage">;
}

export const RepositoryConnection: RepositoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description The total size in kilobytes of all repositories in the connection.
   */
  totalDiskUsage: () => new Field("totalDiskUsage"),
};

export interface IRepositoryContactLink {
  readonly __typename: "RepositoryContactLink";
  readonly about: string;
  readonly name: string;
  readonly url: unknown;
}

interface RepositoryContactLinkSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The contact link purpose.
   */

  readonly about: () => Field<"about">;

  /**
   * @description The contact link name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The contact link URL.
   */

  readonly url: () => Field<"url">;
}

export const RepositoryContactLink: RepositoryContactLinkSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The contact link purpose.
   */
  about: () => new Field("about"),

  /**
   * @description The contact link name.
   */
  name: () => new Field("name"),

  /**
   * @description The contact link URL.
   */
  url: () => new Field("url"),
};

export interface IRepositoryEdge {
  readonly __typename: "RepositoryEdge";
  readonly cursor: string;
  readonly node: IRepository | null;
}

interface RepositoryEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RepositoryEdge: RepositoryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Repository))),
};

export interface IRepositoryInfo {
  readonly __typename: string;
  readonly createdAt: unknown;
  readonly description: string | null;
  readonly descriptionHTML: unknown;
  readonly forkCount: number;
  readonly hasIssuesEnabled: boolean;
  readonly hasProjectsEnabled: boolean;
  readonly hasWikiEnabled: boolean;
  readonly homepageUrl: unknown | null;
  readonly isArchived: boolean;
  readonly isFork: boolean;
  readonly isInOrganization: boolean;
  readonly isLocked: boolean;
  readonly isMirror: boolean;
  readonly isPrivate: boolean;
  readonly isTemplate: boolean;
  readonly licenseInfo: ILicense | null;
  readonly lockReason: RepositoryLockReason | null;
  readonly mirrorUrl: unknown | null;
  readonly name: string;
  readonly nameWithOwner: string;
  readonly openGraphImageUrl: unknown;
  readonly owner: IRepositoryOwner;
  readonly pushedAt: unknown | null;
  readonly resourcePath: unknown;
  readonly shortDescriptionHTML: unknown;
  readonly updatedAt: unknown;
  readonly url: unknown;
  readonly usesCustomOpenGraphImage: boolean;
}

interface RepositoryInfoSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The description of the repository.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The description of the repository rendered to HTML.
   */

  readonly descriptionHTML: () => Field<"descriptionHTML">;

  /**
   * @description Returns how many forks there are of this repository in the whole network.
   */

  readonly forkCount: () => Field<"forkCount">;

  /**
   * @description Indicates if the repository has issues feature enabled.
   */

  readonly hasIssuesEnabled: () => Field<"hasIssuesEnabled">;

  /**
   * @description Indicates if the repository has the Projects feature enabled.
   */

  readonly hasProjectsEnabled: () => Field<"hasProjectsEnabled">;

  /**
   * @description Indicates if the repository has wiki feature enabled.
   */

  readonly hasWikiEnabled: () => Field<"hasWikiEnabled">;

  /**
   * @description The repository's URL.
   */

  readonly homepageUrl: () => Field<"homepageUrl">;

  /**
   * @description Indicates if the repository is unmaintained.
   */

  readonly isArchived: () => Field<"isArchived">;

  /**
   * @description Identifies if the repository is a fork.
   */

  readonly isFork: () => Field<"isFork">;

  /**
   * @description Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
   */

  readonly isInOrganization: () => Field<"isInOrganization">;

  /**
   * @description Indicates if the repository has been locked or not.
   */

  readonly isLocked: () => Field<"isLocked">;

  /**
   * @description Identifies if the repository is a mirror.
   */

  readonly isMirror: () => Field<"isMirror">;

  /**
   * @description Identifies if the repository is private.
   */

  readonly isPrivate: () => Field<"isPrivate">;

  /**
   * @description Identifies if the repository is a template that can be used to generate new repositories.
   */

  readonly isTemplate: () => Field<"isTemplate">;

  /**
   * @description The license associated with the repository
   */

  readonly licenseInfo: <T extends Array<Selection>>(
    select: (t: LicenseSelector) => T
  ) => Field<"licenseInfo", never, SelectionSet<T>>;

  /**
   * @description The reason the repository has been locked.
   */

  readonly lockReason: () => Field<"lockReason">;

  /**
   * @description The repository's original mirror URL.
   */

  readonly mirrorUrl: () => Field<"mirrorUrl">;

  /**
   * @description The name of the repository.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The repository's name with owner.
   */

  readonly nameWithOwner: () => Field<"nameWithOwner">;

  /**
   * @description The image used to represent this repository in Open Graph data.
   */

  readonly openGraphImageUrl: () => Field<"openGraphImageUrl">;

  /**
   * @description The User owner of the repository.
   */

  readonly owner: <T extends Array<Selection>>(
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description Identifies when the repository was last pushed to.
   */

  readonly pushedAt: () => Field<"pushedAt">;

  /**
   * @description The HTTP path for this repository
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description A description of the repository, rendered to HTML without any links in it.
   */

  readonly shortDescriptionHTML: (variables: {
    limit?: Variable<"limit"> | number;
  }) => Field<
    "shortDescriptionHTML",
    [Argument<"limit", Variable<"limit"> | number>]
  >;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this repository
   */

  readonly url: () => Field<"url">;

  /**
   * @description Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
   */

  readonly usesCustomOpenGraphImage: () => Field<"usesCustomOpenGraphImage">;

  readonly on: <T extends Array<Selection>, F extends "Repository">(
    type: F,
    select: (t: RepositorySelector) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RepositoryInfo: RepositoryInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The description of the repository.
   */
  description: () => new Field("description"),

  /**
   * @description The description of the repository rendered to HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),

  /**
   * @description Returns how many forks there are of this repository in the whole network.
   */
  forkCount: () => new Field("forkCount"),

  /**
   * @description Indicates if the repository has issues feature enabled.
   */
  hasIssuesEnabled: () => new Field("hasIssuesEnabled"),

  /**
   * @description Indicates if the repository has the Projects feature enabled.
   */
  hasProjectsEnabled: () => new Field("hasProjectsEnabled"),

  /**
   * @description Indicates if the repository has wiki feature enabled.
   */
  hasWikiEnabled: () => new Field("hasWikiEnabled"),

  /**
   * @description The repository's URL.
   */
  homepageUrl: () => new Field("homepageUrl"),

  /**
   * @description Indicates if the repository is unmaintained.
   */
  isArchived: () => new Field("isArchived"),

  /**
   * @description Identifies if the repository is a fork.
   */
  isFork: () => new Field("isFork"),

  /**
   * @description Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
   */
  isInOrganization: () => new Field("isInOrganization"),

  /**
   * @description Indicates if the repository has been locked or not.
   */
  isLocked: () => new Field("isLocked"),

  /**
   * @description Identifies if the repository is a mirror.
   */
  isMirror: () => new Field("isMirror"),

  /**
   * @description Identifies if the repository is private.
   */
  isPrivate: () => new Field("isPrivate"),

  /**
   * @description Identifies if the repository is a template that can be used to generate new repositories.
   */
  isTemplate: () => new Field("isTemplate"),

  /**
   * @description The license associated with the repository
   */

  licenseInfo: (select) =>
    new Field(
      "licenseInfo",
      undefined as never,
      new SelectionSet(select(License))
    ),

  /**
   * @description The reason the repository has been locked.
   */
  lockReason: () => new Field("lockReason"),

  /**
   * @description The repository's original mirror URL.
   */
  mirrorUrl: () => new Field("mirrorUrl"),

  /**
   * @description The name of the repository.
   */
  name: () => new Field("name"),

  /**
   * @description The repository's name with owner.
   */
  nameWithOwner: () => new Field("nameWithOwner"),

  /**
   * @description The image used to represent this repository in Open Graph data.
   */
  openGraphImageUrl: () => new Field("openGraphImageUrl"),

  /**
   * @description The User owner of the repository.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description Identifies when the repository was last pushed to.
   */
  pushedAt: () => new Field("pushedAt"),

  /**
   * @description The HTTP path for this repository
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description A description of the repository, rendered to HTML without any links in it.
   */
  shortDescriptionHTML: (variables) => new Field("shortDescriptionHTML"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this repository
   */
  url: () => new Field("url"),

  /**
   * @description Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
   */
  usesCustomOpenGraphImage: () => new Field("usesCustomOpenGraphImage"),

  on: (type, select) => {
    switch (type) {
      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "RepositoryInfo",
        });
    }
  },
};

export interface IRepositoryInteractionAbility {
  readonly __typename: "RepositoryInteractionAbility";
  readonly expiresAt: unknown | null;
  readonly limit: RepositoryInteractionLimit;
  readonly origin: RepositoryInteractionLimitOrigin;
}

interface RepositoryInteractionAbilitySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The time the currently active limit expires.
   */

  readonly expiresAt: () => Field<"expiresAt">;

  /**
   * @description The current limit that is enabled on this object.
   */

  readonly limit: () => Field<"limit">;

  /**
   * @description The origin of the currently active interaction limit.
   */

  readonly origin: () => Field<"origin">;
}

export const RepositoryInteractionAbility: RepositoryInteractionAbilitySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The time the currently active limit expires.
   */
  expiresAt: () => new Field("expiresAt"),

  /**
   * @description The current limit that is enabled on this object.
   */
  limit: () => new Field("limit"),

  /**
   * @description The origin of the currently active interaction limit.
   */
  origin: () => new Field("origin"),
};

export interface IRepositoryInvitation extends INode {
  readonly __typename: "RepositoryInvitation";
  readonly email: string | null;
  readonly invitee: IUser | null;
  readonly inviter: IUser;
  readonly permalink: unknown;
  readonly permission: RepositoryPermission;
  readonly repository: IRepositoryInfo | null;
}

interface RepositoryInvitationSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The email address that received the invitation.
   */

  readonly email: () => Field<"email">;

  readonly id: () => Field<"id">;

  /**
   * @description The user who received the invitation.
   */

  readonly invitee: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"invitee", never, SelectionSet<T>>;

  /**
   * @description The user who created the invitation.
   */

  readonly inviter: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"inviter", never, SelectionSet<T>>;

  /**
   * @description The permalink for this repository invitation.
   */

  readonly permalink: () => Field<"permalink">;

  /**
   * @description The permission granted on this repository by this invitation.
   */

  readonly permission: () => Field<"permission">;

  /**
   * @description The Repository the user is invited to.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositoryInfoSelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isRepositoryInvitation = (
  object: Record<string, any>
): object is Partial<IRepositoryInvitation> => {
  return object.__typename === "RepositoryInvitation";
};

export const RepositoryInvitation: RepositoryInvitationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The email address that received the invitation.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description The user who received the invitation.
   */

  invitee: (select) =>
    new Field("invitee", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The user who created the invitation.
   */

  inviter: (select) =>
    new Field("inviter", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The permalink for this repository invitation.
   */
  permalink: () => new Field("permalink"),

  /**
   * @description The permission granted on this repository by this invitation.
   */
  permission: () => new Field("permission"),

  /**
   * @description The Repository the user is invited to.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(RepositoryInfo))
    ),
};

export interface IRepositoryInvitationConnection {
  readonly __typename: "RepositoryInvitationConnection";
  readonly edges: ReadonlyArray<IRepositoryInvitationEdge> | null;
  readonly nodes: ReadonlyArray<IRepositoryInvitation> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface RepositoryInvitationConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: RepositoryInvitationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: RepositoryInvitationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const RepositoryInvitationConnection: RepositoryInvitationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryInvitationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(RepositoryInvitation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRepositoryInvitationEdge {
  readonly __typename: "RepositoryInvitationEdge";
  readonly cursor: string;
  readonly node: IRepositoryInvitation | null;
}

interface RepositoryInvitationEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: RepositoryInvitationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RepositoryInvitationEdge: RepositoryInvitationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(RepositoryInvitation))
    ),
};

export interface IRepositoryNode {
  readonly __typename: string;
  readonly repository: IRepository;
}

interface RepositoryNodeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The repository associated with this node.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "CommitCommentThread"
      | "Issue"
      | "IssueComment"
      | "PullRequest"
      | "PullRequestCommitCommentThread"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "RepositoryVulnerabilityAlert"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "CommitCommentThread"
        ? CommitCommentThreadSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestCommitCommentThread"
        ? PullRequestCommitCommentThreadSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "RepositoryVulnerabilityAlert"
        ? RepositoryVulnerabilityAlertSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RepositoryNode: RepositoryNodeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "CommitCommentThread": {
        return new InlineFragment(
          new NamedType("CommitCommentThread") as any,
          new SelectionSet(select(CommitCommentThread as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestCommitCommentThread": {
        return new InlineFragment(
          new NamedType("PullRequestCommitCommentThread") as any,
          new SelectionSet(select(PullRequestCommitCommentThread as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "RepositoryVulnerabilityAlert": {
        return new InlineFragment(
          new NamedType("RepositoryVulnerabilityAlert") as any,
          new SelectionSet(select(RepositoryVulnerabilityAlert as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "RepositoryNode",
        });
    }
  },
};

export interface IRepositoryOwner {
  readonly __typename: string;
  readonly avatarUrl: unknown;
  readonly id: string;
  readonly login: string;
  readonly repositories: IRepositoryConnection;
  readonly repository: IRepository | null;
  readonly resourcePath: unknown;
  readonly url: unknown;
}

interface RepositoryOwnerSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the owner's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  readonly id: () => Field<"id">;

  /**
   * @description The username used to login.
   */

  readonly login: () => Field<"login">;

  /**
   * @description A list of repositories that the user owns.
   */

  readonly repositories: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isFork?: Variable<"isFork"> | boolean;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isFork", Variable<"isFork"> | boolean>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find Repository.
   */

  readonly repository: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: RepositorySelector) => T
  ) => Field<
    "repository",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP URL for the owner.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for the owner.
   */

  readonly url: () => Field<"url">;

  readonly on: <T extends Array<Selection>, F extends "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RepositoryOwner: RepositoryOwnerSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the owner's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),
  id: () => new Field("id"),

  /**
   * @description The username used to login.
   */
  login: () => new Field("login"),

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isFork", variables.isFork),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description Find Repository.
   */

  repository: (variables, select) =>
    new Field(
      "repository",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP URL for the owner.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for the owner.
   */
  url: () => new Field("url"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "RepositoryOwner",
        });
    }
  },
};

export interface IRepositoryTopic extends INode, IUniformResourceLocatable {
  readonly __typename: "RepositoryTopic";
  readonly topic: ITopic;
}

interface RepositoryTopicSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description The HTTP path for this repository-topic.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The topic.
   */

  readonly topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;

  /**
   * @description The HTTP URL for this repository-topic.
   */

  readonly url: () => Field<"url">;
}

export const isRepositoryTopic = (
  object: Record<string, any>
): object is Partial<IRepositoryTopic> => {
  return object.__typename === "RepositoryTopic";
};

export const RepositoryTopic: RepositoryTopicSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description The HTTP path for this repository-topic.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The topic.
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),

  /**
   * @description The HTTP URL for this repository-topic.
   */
  url: () => new Field("url"),
};

export interface IRepositoryTopicConnection {
  readonly __typename: "RepositoryTopicConnection";
  readonly edges: ReadonlyArray<IRepositoryTopicEdge> | null;
  readonly nodes: ReadonlyArray<IRepositoryTopic> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface RepositoryTopicConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: RepositoryTopicEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: RepositoryTopicSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const RepositoryTopicConnection: RepositoryTopicConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryTopicEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(RepositoryTopic))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRepositoryTopicEdge {
  readonly __typename: "RepositoryTopicEdge";
  readonly cursor: string;
  readonly node: IRepositoryTopic | null;
}

interface RepositoryTopicEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: RepositoryTopicSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RepositoryTopicEdge: RepositoryTopicEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(RepositoryTopic))
    ),
};

export interface IRepositoryVisibilityChangeDisableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "RepositoryVisibilityChangeDisableAuditEntry";
}

interface RepositoryVisibilityChangeDisableAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepositoryVisibilityChangeDisableAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepositoryVisibilityChangeDisableAuditEntry> => {
  return object.__typename === "RepositoryVisibilityChangeDisableAuditEntry";
};

export const RepositoryVisibilityChangeDisableAuditEntry: RepositoryVisibilityChangeDisableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepositoryVisibilityChangeEnableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  readonly __typename: "RepositoryVisibilityChangeEnableAuditEntry";
}

interface RepositoryVisibilityChangeEnableAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  readonly enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  readonly enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  readonly enterpriseUrl: () => Field<"enterpriseUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isRepositoryVisibilityChangeEnableAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepositoryVisibilityChangeEnableAuditEntry> => {
  return object.__typename === "RepositoryVisibilityChangeEnableAuditEntry";
};

export const RepositoryVisibilityChangeEnableAuditEntry: RepositoryVisibilityChangeEnableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepositoryVulnerabilityAlert extends INode, IRepositoryNode {
  readonly __typename: "RepositoryVulnerabilityAlert";
  readonly createdAt: unknown;
  readonly dismissReason: string | null;
  readonly dismissedAt: unknown | null;
  readonly dismisser: IUser | null;
  readonly securityAdvisory: ISecurityAdvisory | null;
  readonly securityVulnerability: ISecurityVulnerability | null;
  readonly vulnerableManifestFilename: string;
  readonly vulnerableManifestPath: string;
  readonly vulnerableRequirements: string | null;
}

interface RepositoryVulnerabilityAlertSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description When was the alert created?
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The reason the alert was dismissed
   */

  readonly dismissReason: () => Field<"dismissReason">;

  /**
   * @description When was the alert dimissed?
   */

  readonly dismissedAt: () => Field<"dismissedAt">;

  /**
   * @description The user who dismissed the alert
   */

  readonly dismisser: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"dismisser", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The associated repository
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The associated security advisory
   */

  readonly securityAdvisory: <T extends Array<Selection>>(
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<"securityAdvisory", never, SelectionSet<T>>;

  /**
   * @description The associated security vulnerablity
   */

  readonly securityVulnerability: <T extends Array<Selection>>(
    select: (t: SecurityVulnerabilitySelector) => T
  ) => Field<"securityVulnerability", never, SelectionSet<T>>;

  /**
   * @description The vulnerable manifest filename
   */

  readonly vulnerableManifestFilename: () => Field<"vulnerableManifestFilename">;

  /**
   * @description The vulnerable manifest path
   */

  readonly vulnerableManifestPath: () => Field<"vulnerableManifestPath">;

  /**
   * @description The vulnerable requirements
   */

  readonly vulnerableRequirements: () => Field<"vulnerableRequirements">;
}

export const isRepositoryVulnerabilityAlert = (
  object: Record<string, any>
): object is Partial<IRepositoryVulnerabilityAlert> => {
  return object.__typename === "RepositoryVulnerabilityAlert";
};

export const RepositoryVulnerabilityAlert: RepositoryVulnerabilityAlertSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description When was the alert created?
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The reason the alert was dismissed
   */
  dismissReason: () => new Field("dismissReason"),

  /**
   * @description When was the alert dimissed?
   */
  dismissedAt: () => new Field("dismissedAt"),

  /**
   * @description The user who dismissed the alert
   */

  dismisser: (select) =>
    new Field("dismisser", undefined as never, new SelectionSet(select(User))),

  id: () => new Field("id"),

  /**
   * @description The associated repository
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The associated security advisory
   */

  securityAdvisory: (select) =>
    new Field(
      "securityAdvisory",
      undefined as never,
      new SelectionSet(select(SecurityAdvisory))
    ),

  /**
   * @description The associated security vulnerablity
   */

  securityVulnerability: (select) =>
    new Field(
      "securityVulnerability",
      undefined as never,
      new SelectionSet(select(SecurityVulnerability))
    ),

  /**
   * @description The vulnerable manifest filename
   */
  vulnerableManifestFilename: () => new Field("vulnerableManifestFilename"),

  /**
   * @description The vulnerable manifest path
   */
  vulnerableManifestPath: () => new Field("vulnerableManifestPath"),

  /**
   * @description The vulnerable requirements
   */
  vulnerableRequirements: () => new Field("vulnerableRequirements"),
};

export interface IRepositoryVulnerabilityAlertConnection {
  readonly __typename: "RepositoryVulnerabilityAlertConnection";
  readonly edges: ReadonlyArray<IRepositoryVulnerabilityAlertEdge> | null;
  readonly nodes: ReadonlyArray<IRepositoryVulnerabilityAlert> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface RepositoryVulnerabilityAlertConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: RepositoryVulnerabilityAlertEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: RepositoryVulnerabilityAlertSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const RepositoryVulnerabilityAlertConnection: RepositoryVulnerabilityAlertConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryVulnerabilityAlertEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(RepositoryVulnerabilityAlert))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRepositoryVulnerabilityAlertEdge {
  readonly __typename: "RepositoryVulnerabilityAlertEdge";
  readonly cursor: string;
  readonly node: IRepositoryVulnerabilityAlert | null;
}

interface RepositoryVulnerabilityAlertEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: RepositoryVulnerabilityAlertSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RepositoryVulnerabilityAlertEdge: RepositoryVulnerabilityAlertEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(RepositoryVulnerabilityAlert))
    ),
};

export interface IRequestReviewsPayload {
  readonly __typename: "RequestReviewsPayload";
  readonly actor: IActor | null;
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
  readonly requestedReviewersEdge: IUserEdge | null;
}

interface RequestReviewsPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that is getting requests.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The edge from the pull request to the requested reviewers.
   */

  readonly requestedReviewersEdge: <T extends Array<Selection>>(
    select: (t: UserEdgeSelector) => T
  ) => Field<"requestedReviewersEdge", never, SelectionSet<T>>;
}

export const RequestReviewsPayload: RequestReviewsPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that is getting requests.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The edge from the pull request to the requested reviewers.
   */

  requestedReviewersEdge: (select) =>
    new Field(
      "requestedReviewersEdge",
      undefined as never,
      new SelectionSet(select(UserEdge))
    ),
};

export interface IRerequestCheckSuitePayload {
  readonly __typename: "RerequestCheckSuitePayload";
  readonly checkSuite: ICheckSuite | null;
  readonly clientMutationId: string | null;
}

interface RerequestCheckSuitePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The requested check suite.
   */

  readonly checkSuite: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"checkSuite", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const RerequestCheckSuitePayload: RerequestCheckSuitePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The requested check suite.
   */

  checkSuite: (select) =>
    new Field(
      "checkSuite",
      undefined as never,
      new SelectionSet(select(CheckSuite))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IResolveReviewThreadPayload {
  readonly __typename: "ResolveReviewThreadPayload";
  readonly clientMutationId: string | null;
  readonly thread: IPullRequestReviewThread | null;
}

interface ResolveReviewThreadPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The thread to resolve.
   */

  readonly thread: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"thread", never, SelectionSet<T>>;
}

export const ResolveReviewThreadPayload: ResolveReviewThreadPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The thread to resolve.
   */

  thread: (select) =>
    new Field(
      "thread",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),
};

export interface IRestrictedContribution extends IContribution {
  readonly __typename: "RestrictedContribution";
}

interface RestrictedContributionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  readonly isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  readonly occurredAt: () => Field<"occurredAt">;

  /**
   * @description The HTTP path for this contribution.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  readonly url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isRestrictedContribution = (
  object: Record<string, any>
): object is Partial<IRestrictedContribution> => {
  return object.__typename === "RestrictedContribution";
};

export const RestrictedContribution: RestrictedContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IReviewDismissalAllowance extends INode {
  readonly __typename: "ReviewDismissalAllowance";
  readonly actor: IReviewDismissalAllowanceActor | null;
  readonly branchProtectionRule: IBranchProtectionRule | null;
}

interface ReviewDismissalAllowanceSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor that can dismiss.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ReviewDismissalAllowanceActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the branch protection rule associated with the allowed user or team.
   */

  readonly branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;
}

export const isReviewDismissalAllowance = (
  object: Record<string, any>
): object is Partial<IReviewDismissalAllowance> => {
  return object.__typename === "ReviewDismissalAllowance";
};

export const ReviewDismissalAllowance: ReviewDismissalAllowanceSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor that can dismiss.
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(ReviewDismissalAllowanceActor))
    ),

  /**
   * @description Identifies the branch protection rule associated with the allowed user or team.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  id: () => new Field("id"),
};

export interface IReviewDismissalAllowanceConnection {
  readonly __typename: "ReviewDismissalAllowanceConnection";
  readonly edges: ReadonlyArray<IReviewDismissalAllowanceEdge> | null;
  readonly nodes: ReadonlyArray<IReviewDismissalAllowance> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ReviewDismissalAllowanceConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ReviewDismissalAllowanceEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ReviewDismissalAllowanceSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ReviewDismissalAllowanceConnection: ReviewDismissalAllowanceConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReviewDismissalAllowanceEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ReviewDismissalAllowance))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReviewDismissalAllowanceEdge {
  readonly __typename: "ReviewDismissalAllowanceEdge";
  readonly cursor: string;
  readonly node: IReviewDismissalAllowance | null;
}

interface ReviewDismissalAllowanceEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ReviewDismissalAllowanceSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReviewDismissalAllowanceEdge: ReviewDismissalAllowanceEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ReviewDismissalAllowance))
    ),
};

export interface IReviewDismissedEvent
  extends INode,
    IUniformResourceLocatable {
  readonly __typename: "ReviewDismissedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly dismissalMessage: string | null;
  readonly dismissalMessageHTML: string | null;
  readonly previousReviewState: PullRequestReviewState;
  readonly pullRequest: IPullRequest;
  readonly pullRequestCommit: IPullRequestCommit | null;
  readonly review: IPullRequestReview | null;
}

interface ReviewDismissedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description Identifies the optional message associated with the 'review_dismissed' event.
   */

  readonly dismissalMessage: () => Field<"dismissalMessage">;

  /**
   * @description Identifies the optional message associated with the event, rendered to HTML.
   */

  readonly dismissalMessageHTML: () => Field<"dismissalMessageHTML">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the previous state of the review with the 'review_dismissed' event.
   */

  readonly previousReviewState: () => Field<"previousReviewState">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the commit which caused the review to become stale.
   */

  readonly pullRequestCommit: <T extends Array<Selection>>(
    select: (t: PullRequestCommitSelector) => T
  ) => Field<"pullRequestCommit", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this review dismissed event.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the review associated with the 'review_dismissed' event.
   */

  readonly review: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"review", never, SelectionSet<T>>;

  /**
   * @description The HTTP URL for this review dismissed event.
   */

  readonly url: () => Field<"url">;
}

export const isReviewDismissedEvent = (
  object: Record<string, any>
): object is Partial<IReviewDismissedEvent> => {
  return object.__typename === "ReviewDismissedEvent";
};

export const ReviewDismissedEvent: ReviewDismissedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description Identifies the optional message associated with the 'review_dismissed' event.
   */
  dismissalMessage: () => new Field("dismissalMessage"),

  /**
   * @description Identifies the optional message associated with the event, rendered to HTML.
   */
  dismissalMessageHTML: () => new Field("dismissalMessageHTML"),
  id: () => new Field("id"),

  /**
   * @description Identifies the previous state of the review with the 'review_dismissed' event.
   */
  previousReviewState: () => new Field("previousReviewState"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the commit which caused the review to become stale.
   */

  pullRequestCommit: (select) =>
    new Field(
      "pullRequestCommit",
      undefined as never,
      new SelectionSet(select(PullRequestCommit))
    ),

  /**
   * @description The HTTP path for this review dismissed event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the review associated with the 'review_dismissed' event.
   */

  review: (select) =>
    new Field(
      "review",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description The HTTP URL for this review dismissed event.
   */
  url: () => new Field("url"),
};

export interface IReviewRequest extends INode {
  readonly __typename: "ReviewRequest";
  readonly asCodeOwner: boolean;
  readonly databaseId: number | null;
  readonly pullRequest: IPullRequest;
  readonly requestedReviewer: IRequestedReviewer | null;
}

interface ReviewRequestSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Whether this request was created for a code owner
   */

  readonly asCodeOwner: () => Field<"asCodeOwner">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the pull request associated with this review request.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The reviewer that is requested.
   */

  readonly requestedReviewer: <T extends Array<Selection>>(
    select: (t: RequestedReviewerSelector) => T
  ) => Field<"requestedReviewer", never, SelectionSet<T>>;
}

export const isReviewRequest = (
  object: Record<string, any>
): object is Partial<IReviewRequest> => {
  return object.__typename === "ReviewRequest";
};

export const ReviewRequest: ReviewRequestSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Whether this request was created for a code owner
   */
  asCodeOwner: () => new Field("asCodeOwner"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description Identifies the pull request associated with this review request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The reviewer that is requested.
   */

  requestedReviewer: (select) =>
    new Field(
      "requestedReviewer",
      undefined as never,
      new SelectionSet(select(RequestedReviewer))
    ),
};

export interface IReviewRequestConnection {
  readonly __typename: "ReviewRequestConnection";
  readonly edges: ReadonlyArray<IReviewRequestEdge> | null;
  readonly nodes: ReadonlyArray<IReviewRequest> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface ReviewRequestConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: ReviewRequestEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: ReviewRequestSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const ReviewRequestConnection: ReviewRequestConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReviewRequestEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ReviewRequest))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReviewRequestEdge {
  readonly __typename: "ReviewRequestEdge";
  readonly cursor: string;
  readonly node: IReviewRequest | null;
}

interface ReviewRequestEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: ReviewRequestSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReviewRequestEdge: ReviewRequestEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ReviewRequest))
    ),
};

export interface IReviewRequestRemovedEvent extends INode {
  readonly __typename: "ReviewRequestRemovedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly pullRequest: IPullRequest;
  readonly requestedReviewer: IRequestedReviewer | null;
}

interface ReviewRequestRemovedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the reviewer whose review request was removed.
   */

  readonly requestedReviewer: <T extends Array<Selection>>(
    select: (t: RequestedReviewerSelector) => T
  ) => Field<"requestedReviewer", never, SelectionSet<T>>;
}

export const isReviewRequestRemovedEvent = (
  object: Record<string, any>
): object is Partial<IReviewRequestRemovedEvent> => {
  return object.__typename === "ReviewRequestRemovedEvent";
};

export const ReviewRequestRemovedEvent: ReviewRequestRemovedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the reviewer whose review request was removed.
   */

  requestedReviewer: (select) =>
    new Field(
      "requestedReviewer",
      undefined as never,
      new SelectionSet(select(RequestedReviewer))
    ),
};

export interface IReviewRequestedEvent extends INode {
  readonly __typename: "ReviewRequestedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly pullRequest: IPullRequest;
  readonly requestedReviewer: IRequestedReviewer | null;
}

interface ReviewRequestedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the reviewer whose review was requested.
   */

  readonly requestedReviewer: <T extends Array<Selection>>(
    select: (t: RequestedReviewerSelector) => T
  ) => Field<"requestedReviewer", never, SelectionSet<T>>;
}

export const isReviewRequestedEvent = (
  object: Record<string, any>
): object is Partial<IReviewRequestedEvent> => {
  return object.__typename === "ReviewRequestedEvent";
};

export const ReviewRequestedEvent: ReviewRequestedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the reviewer whose review was requested.
   */

  requestedReviewer: (select) =>
    new Field(
      "requestedReviewer",
      undefined as never,
      new SelectionSet(select(RequestedReviewer))
    ),
};

export interface IReviewStatusHovercardContext extends IHovercardContext {
  readonly __typename: "ReviewStatusHovercardContext";
  readonly reviewDecision: PullRequestReviewDecision | null;
}

interface ReviewStatusHovercardContextSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  readonly message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  readonly octicon: () => Field<"octicon">;

  /**
   * @description The current status of the pull request with respect to code review.
   */

  readonly reviewDecision: () => Field<"reviewDecision">;
}

export const isReviewStatusHovercardContext = (
  object: Record<string, any>
): object is Partial<IReviewStatusHovercardContext> => {
  return object.__typename === "ReviewStatusHovercardContext";
};

export const ReviewStatusHovercardContext: ReviewStatusHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  /**
   * @description The current status of the pull request with respect to code review.
   */
  reviewDecision: () => new Field("reviewDecision"),
};

export interface ISavedReply extends INode {
  readonly __typename: "SavedReply";
  readonly body: string;
  readonly bodyHTML: unknown;
  readonly databaseId: number | null;
  readonly title: string;
  readonly user: IActor | null;
}

interface SavedReplySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The body of the saved reply.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The saved reply body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  readonly id: () => Field<"id">;

  /**
   * @description The title of the saved reply.
   */

  readonly title: () => Field<"title">;

  /**
   * @description The user that saved this reply.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isSavedReply = (
  object: Record<string, any>
): object is Partial<ISavedReply> => {
  return object.__typename === "SavedReply";
};

export const SavedReply: SavedReplySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The body of the saved reply.
   */
  body: () => new Field("body"),

  /**
   * @description The saved reply body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The title of the saved reply.
   */
  title: () => new Field("title"),

  /**
   * @description The user that saved this reply.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(Actor))),
};

export interface ISavedReplyConnection {
  readonly __typename: "SavedReplyConnection";
  readonly edges: ReadonlyArray<ISavedReplyEdge> | null;
  readonly nodes: ReadonlyArray<ISavedReply> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface SavedReplyConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: SavedReplyEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: SavedReplySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const SavedReplyConnection: SavedReplyConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SavedReplyEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SavedReply))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISavedReplyEdge {
  readonly __typename: "SavedReplyEdge";
  readonly cursor: string;
  readonly node: ISavedReply | null;
}

interface SavedReplyEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: SavedReplySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SavedReplyEdge: SavedReplyEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(SavedReply))),
};

export interface ISearchResultItemConnection {
  readonly __typename: "SearchResultItemConnection";
  readonly codeCount: number;
  readonly edges: ReadonlyArray<ISearchResultItemEdge> | null;
  readonly issueCount: number;
  readonly nodes: ReadonlyArray<ISearchResultItem> | null;
  readonly pageInfo: IPageInfo;
  readonly repositoryCount: number;
  readonly userCount: number;
  readonly wikiCount: number;
}

interface SearchResultItemConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The number of pieces of code that matched the search query.
   */

  readonly codeCount: () => Field<"codeCount">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: SearchResultItemEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description The number of issues that matched the search query.
   */

  readonly issueCount: () => Field<"issueCount">;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: SearchResultItemSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description The number of repositories that matched the search query.
   */

  readonly repositoryCount: () => Field<"repositoryCount">;

  /**
   * @description The number of users that matched the search query.
   */

  readonly userCount: () => Field<"userCount">;

  /**
   * @description The number of wiki pages that matched the search query.
   */

  readonly wikiCount: () => Field<"wikiCount">;
}

export const SearchResultItemConnection: SearchResultItemConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The number of pieces of code that matched the search query.
   */
  codeCount: () => new Field("codeCount"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SearchResultItemEdge))
    ),

  /**
   * @description The number of issues that matched the search query.
   */
  issueCount: () => new Field("issueCount"),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SearchResultItem))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description The number of repositories that matched the search query.
   */
  repositoryCount: () => new Field("repositoryCount"),

  /**
   * @description The number of users that matched the search query.
   */
  userCount: () => new Field("userCount"),

  /**
   * @description The number of wiki pages that matched the search query.
   */
  wikiCount: () => new Field("wikiCount"),
};

export interface ISearchResultItemEdge {
  readonly __typename: "SearchResultItemEdge";
  readonly cursor: string;
  readonly node: ISearchResultItem | null;
  readonly textMatches: ReadonlyArray<ITextMatch> | null;
}

interface SearchResultItemEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: SearchResultItemSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description Text matches on the result found.
   */

  readonly textMatches: <T extends Array<Selection>>(
    select: (t: TextMatchSelector) => T
  ) => Field<"textMatches", never, SelectionSet<T>>;
}

export const SearchResultItemEdge: SearchResultItemEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(SearchResultItem))
    ),

  /**
   * @description Text matches on the result found.
   */

  textMatches: (select) =>
    new Field(
      "textMatches",
      undefined as never,
      new SelectionSet(select(TextMatch))
    ),
};

export interface ISecurityAdvisory extends INode {
  readonly __typename: "SecurityAdvisory";
  readonly databaseId: number | null;
  readonly description: string;
  readonly ghsaId: string;
  readonly identifiers: ReadonlyArray<ISecurityAdvisoryIdentifier>;
  readonly origin: string;
  readonly permalink: unknown | null;
  readonly publishedAt: unknown;
  readonly references: ReadonlyArray<ISecurityAdvisoryReference>;
  readonly severity: SecurityAdvisorySeverity;
  readonly summary: string;
  readonly updatedAt: unknown;
  readonly vulnerabilities: ISecurityVulnerabilityConnection;
  readonly withdrawnAt: unknown | null;
}

interface SecurityAdvisorySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description This is a long plaintext description of the advisory
   */

  readonly description: () => Field<"description">;

  /**
   * @description The GitHub Security Advisory ID
   */

  readonly ghsaId: () => Field<"ghsaId">;

  readonly id: () => Field<"id">;

  /**
   * @description A list of identifiers for this advisory
   */

  readonly identifiers: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryIdentifierSelector) => T
  ) => Field<"identifiers", never, SelectionSet<T>>;

  /**
   * @description The organization that originated the advisory
   */

  readonly origin: () => Field<"origin">;

  /**
   * @description The permalink for the advisory
   */

  readonly permalink: () => Field<"permalink">;

  /**
   * @description When the advisory was published
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of references for this advisory
   */

  readonly references: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryReferenceSelector) => T
  ) => Field<"references", never, SelectionSet<T>>;

  /**
   * @description The severity of the advisory
   */

  readonly severity: () => Field<"severity">;

  /**
   * @description A short plaintext summary of the advisory
   */

  readonly summary: () => Field<"summary">;

  /**
   * @description When the advisory was last updated
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description Vulnerabilities associated with this Advisory
   */

  readonly vulnerabilities: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      ecosystem?: Variable<"ecosystem"> | SecurityAdvisoryEcosystem;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SecurityVulnerabilityOrder;
      package?: Variable<"package"> | string;
      severities?: Variable<"severities"> | SecurityAdvisorySeverity;
    },
    select: (t: SecurityVulnerabilityConnectionSelector) => T
  ) => Field<
    "vulnerabilities",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"ecosystem", Variable<"ecosystem"> | SecurityAdvisoryEcosystem>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SecurityVulnerabilityOrder>,
      Argument<"package", Variable<"package"> | string>,
      Argument<"severities", Variable<"severities"> | SecurityAdvisorySeverity>
    ],
    SelectionSet<T>
  >;

  /**
   * @description When the advisory was withdrawn, if it has been withdrawn
   */

  readonly withdrawnAt: () => Field<"withdrawnAt">;
}

export const isSecurityAdvisory = (
  object: Record<string, any>
): object is Partial<ISecurityAdvisory> => {
  return object.__typename === "SecurityAdvisory";
};

export const SecurityAdvisory: SecurityAdvisorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description This is a long plaintext description of the advisory
   */
  description: () => new Field("description"),

  /**
   * @description The GitHub Security Advisory ID
   */
  ghsaId: () => new Field("ghsaId"),
  id: () => new Field("id"),

  /**
   * @description A list of identifiers for this advisory
   */

  identifiers: (select) =>
    new Field(
      "identifiers",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryIdentifier))
    ),

  /**
   * @description The organization that originated the advisory
   */
  origin: () => new Field("origin"),

  /**
   * @description The permalink for the advisory
   */
  permalink: () => new Field("permalink"),

  /**
   * @description When the advisory was published
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of references for this advisory
   */

  references: (select) =>
    new Field(
      "references",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryReference))
    ),

  /**
   * @description The severity of the advisory
   */
  severity: () => new Field("severity"),

  /**
   * @description A short plaintext summary of the advisory
   */
  summary: () => new Field("summary"),

  /**
   * @description When the advisory was last updated
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description Vulnerabilities associated with this Advisory
   */

  vulnerabilities: (variables, select) =>
    new Field(
      "vulnerabilities",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument(
          "ecosystem",
          variables.ecosystem,
          SecurityAdvisoryEcosystem
        ),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("package", variables.package),
        new Argument(
          "severities",
          variables.severities,
          SecurityAdvisorySeverity
        ),
      ],
      new SelectionSet(select(SecurityVulnerabilityConnection))
    ),

  /**
   * @description When the advisory was withdrawn, if it has been withdrawn
   */
  withdrawnAt: () => new Field("withdrawnAt"),
};

export interface ISecurityAdvisoryConnection {
  readonly __typename: "SecurityAdvisoryConnection";
  readonly edges: ReadonlyArray<ISecurityAdvisoryEdge> | null;
  readonly nodes: ReadonlyArray<ISecurityAdvisory> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface SecurityAdvisoryConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const SecurityAdvisoryConnection: SecurityAdvisoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SecurityAdvisory))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISecurityAdvisoryEdge {
  readonly __typename: "SecurityAdvisoryEdge";
  readonly cursor: string;
  readonly node: ISecurityAdvisory | null;
}

interface SecurityAdvisoryEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SecurityAdvisoryEdge: SecurityAdvisoryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(SecurityAdvisory))
    ),
};

export interface ISecurityAdvisoryIdentifier {
  readonly __typename: "SecurityAdvisoryIdentifier";
  readonly type: string;
  readonly value: string;
}

interface SecurityAdvisoryIdentifierSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The identifier type, e.g. GHSA, CVE
   */

  readonly type: () => Field<"type">;

  /**
   * @description The identifier
   */

  readonly value: () => Field<"value">;
}

export const SecurityAdvisoryIdentifier: SecurityAdvisoryIdentifierSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The identifier type, e.g. GHSA, CVE
   */
  type: () => new Field("type"),

  /**
   * @description The identifier
   */
  value: () => new Field("value"),
};

export interface ISecurityAdvisoryPackage {
  readonly __typename: "SecurityAdvisoryPackage";
  readonly ecosystem: SecurityAdvisoryEcosystem;
  readonly name: string;
}

interface SecurityAdvisoryPackageSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The ecosystem the package belongs to, e.g. RUBYGEMS, NPM
   */

  readonly ecosystem: () => Field<"ecosystem">;

  /**
   * @description The package name
   */

  readonly name: () => Field<"name">;
}

export const SecurityAdvisoryPackage: SecurityAdvisoryPackageSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The ecosystem the package belongs to, e.g. RUBYGEMS, NPM
   */
  ecosystem: () => new Field("ecosystem"),

  /**
   * @description The package name
   */
  name: () => new Field("name"),
};

export interface ISecurityAdvisoryPackageVersion {
  readonly __typename: "SecurityAdvisoryPackageVersion";
  readonly identifier: string;
}

interface SecurityAdvisoryPackageVersionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The package name or version
   */

  readonly identifier: () => Field<"identifier">;
}

export const SecurityAdvisoryPackageVersion: SecurityAdvisoryPackageVersionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The package name or version
   */
  identifier: () => new Field("identifier"),
};

export interface ISecurityAdvisoryReference {
  readonly __typename: "SecurityAdvisoryReference";
  readonly url: unknown;
}

interface SecurityAdvisoryReferenceSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A publicly accessible reference
   */

  readonly url: () => Field<"url">;
}

export const SecurityAdvisoryReference: SecurityAdvisoryReferenceSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A publicly accessible reference
   */
  url: () => new Field("url"),
};

export interface ISecurityVulnerability {
  readonly __typename: "SecurityVulnerability";
  readonly advisory: ISecurityAdvisory;
  readonly firstPatchedVersion: ISecurityAdvisoryPackageVersion | null;
  readonly package: ISecurityAdvisoryPackage;
  readonly severity: SecurityAdvisorySeverity;
  readonly updatedAt: unknown;
  readonly vulnerableVersionRange: string;
}

interface SecurityVulnerabilitySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The Advisory associated with this Vulnerability
   */

  readonly advisory: <T extends Array<Selection>>(
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<"advisory", never, SelectionSet<T>>;

  /**
   * @description The first version containing a fix for the vulnerability
   */

  readonly firstPatchedVersion: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryPackageVersionSelector) => T
  ) => Field<"firstPatchedVersion", never, SelectionSet<T>>;

  /**
   * @description A description of the vulnerable package
   */

  readonly package: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryPackageSelector) => T
  ) => Field<"package", never, SelectionSet<T>>;

  /**
   * @description The severity of the vulnerability within this package
   */

  readonly severity: () => Field<"severity">;

  /**
   * @description When the vulnerability was last updated
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
     * @description A string that describes the vulnerable package versions.
This string follows a basic syntax with a few forms.
+ `= 0.2.0` denotes a single vulnerable version.
+ `<= 1.0.8` denotes a version range up to and including the specified version
+ `< 0.1.11` denotes a version range up to, but excluding, the specified version
+ `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
+ `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
     */

  readonly vulnerableVersionRange: () => Field<"vulnerableVersionRange">;
}

export const SecurityVulnerability: SecurityVulnerabilitySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The Advisory associated with this Vulnerability
   */

  advisory: (select) =>
    new Field(
      "advisory",
      undefined as never,
      new SelectionSet(select(SecurityAdvisory))
    ),

  /**
   * @description The first version containing a fix for the vulnerability
   */

  firstPatchedVersion: (select) =>
    new Field(
      "firstPatchedVersion",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryPackageVersion))
    ),

  /**
   * @description A description of the vulnerable package
   */

  package: (select) =>
    new Field(
      "package",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryPackage))
    ),

  /**
   * @description The severity of the vulnerability within this package
   */
  severity: () => new Field("severity"),

  /**
   * @description When the vulnerability was last updated
   */
  updatedAt: () => new Field("updatedAt"),

  /**
     * @description A string that describes the vulnerable package versions.
This string follows a basic syntax with a few forms.
+ `= 0.2.0` denotes a single vulnerable version.
+ `<= 1.0.8` denotes a version range up to and including the specified version
+ `< 0.1.11` denotes a version range up to, but excluding, the specified version
+ `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
+ `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
     */
  vulnerableVersionRange: () => new Field("vulnerableVersionRange"),
};

export interface ISecurityVulnerabilityConnection {
  readonly __typename: "SecurityVulnerabilityConnection";
  readonly edges: ReadonlyArray<ISecurityVulnerabilityEdge> | null;
  readonly nodes: ReadonlyArray<ISecurityVulnerability> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface SecurityVulnerabilityConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: SecurityVulnerabilityEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: SecurityVulnerabilitySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const SecurityVulnerabilityConnection: SecurityVulnerabilityConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SecurityVulnerabilityEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SecurityVulnerability))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISecurityVulnerabilityEdge {
  readonly __typename: "SecurityVulnerabilityEdge";
  readonly cursor: string;
  readonly node: ISecurityVulnerability | null;
}

interface SecurityVulnerabilityEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: SecurityVulnerabilitySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SecurityVulnerabilityEdge: SecurityVulnerabilityEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(SecurityVulnerability))
    ),
};

export interface ISetEnterpriseIdentityProviderPayload {
  readonly __typename: "SetEnterpriseIdentityProviderPayload";
  readonly clientMutationId: string | null;
  readonly identityProvider: IEnterpriseIdentityProvider | null;
}

interface SetEnterpriseIdentityProviderPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The identity provider for the enterprise.
   */

  readonly identityProvider: <T extends Array<Selection>>(
    select: (t: EnterpriseIdentityProviderSelector) => T
  ) => Field<"identityProvider", never, SelectionSet<T>>;
}

export const SetEnterpriseIdentityProviderPayload: SetEnterpriseIdentityProviderPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The identity provider for the enterprise.
   */

  identityProvider: (select) =>
    new Field(
      "identityProvider",
      undefined as never,
      new SelectionSet(select(EnterpriseIdentityProvider))
    ),
};

export interface ISetOrganizationInteractionLimitPayload {
  readonly __typename: "SetOrganizationInteractionLimitPayload";
  readonly clientMutationId: string | null;
  readonly organization: IOrganization | null;
}

interface SetOrganizationInteractionLimitPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The organization that the interaction limit was set for.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;
}

export const SetOrganizationInteractionLimitPayload: SetOrganizationInteractionLimitPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The organization that the interaction limit was set for.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),
};

export interface ISetRepositoryInteractionLimitPayload {
  readonly __typename: "SetRepositoryInteractionLimitPayload";
  readonly clientMutationId: string | null;
  readonly repository: IRepository | null;
}

interface SetRepositoryInteractionLimitPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository that the interaction limit was set for.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const SetRepositoryInteractionLimitPayload: SetRepositoryInteractionLimitPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository that the interaction limit was set for.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ISetUserInteractionLimitPayload {
  readonly __typename: "SetUserInteractionLimitPayload";
  readonly clientMutationId: string | null;
  readonly user: IUser | null;
}

interface SetUserInteractionLimitPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The user that the interaction limit was set for.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const SetUserInteractionLimitPayload: SetUserInteractionLimitPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The user that the interaction limit was set for.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ISmimeSignature extends IGitSignature {
  readonly __typename: "SmimeSignature";
}

interface SmimeSignatureSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Email used to sign this object.
   */

  readonly email: () => Field<"email">;

  /**
   * @description True if the signature is valid and verified by GitHub.
   */

  readonly isValid: () => Field<"isValid">;

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */

  readonly payload: () => Field<"payload">;

  /**
   * @description ASCII-armored signature header from object.
   */

  readonly signature: () => Field<"signature">;

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  readonly signer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"signer", never, SelectionSet<T>>;

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */

  readonly state: () => Field<"state">;

  /**
   * @description True if the signature was made with GitHub's signing key.
   */

  readonly wasSignedByGitHub: () => Field<"wasSignedByGitHub">;
}

export const isSmimeSignature = (
  object: Record<string, any>
): object is Partial<ISmimeSignature> => {
  return object.__typename === "SmimeSignature";
};

export const SmimeSignature: SmimeSignatureSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Email used to sign this object.
   */
  email: () => new Field("email"),

  /**
   * @description True if the signature is valid and verified by GitHub.
   */
  isValid: () => new Field("isValid"),

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */
  payload: () => new Field("payload"),

  /**
   * @description ASCII-armored signature header from object.
   */
  signature: () => new Field("signature"),

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: (select) =>
    new Field("signer", undefined as never, new SelectionSet(select(User))),

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */
  state: () => new Field("state"),

  /**
   * @description True if the signature was made with GitHub's signing key.
   */
  wasSignedByGitHub: () => new Field("wasSignedByGitHub"),
};

export interface ISponsorable {
  readonly __typename: string;
  readonly hasSponsorsListing: boolean;
  readonly isSponsoringViewer: boolean;
  readonly sponsorsListing: ISponsorsListing | null;
  readonly sponsorshipsAsMaintainer: ISponsorshipConnection;
  readonly sponsorshipsAsSponsor: ISponsorshipConnection;
  readonly viewerCanSponsor: boolean;
  readonly viewerIsSponsoring: boolean;
}

interface SponsorableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */

  readonly hasSponsorsListing: () => Field<"hasSponsorsListing">;

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */

  readonly isSponsoringViewer: () => Field<"isSponsoringViewer">;

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  readonly sponsorsListing: <T extends Array<Selection>>(
    select: (t: SponsorsListingSelector) => T
  ) => Field<"sponsorsListing", never, SelectionSet<T>>;

  /**
   * @description This object's sponsorships as the maintainer.
   */

  readonly sponsorshipsAsMaintainer: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      includePrivate?: Variable<"includePrivate"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsMaintainer",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"includePrivate", Variable<"includePrivate"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description This object's sponsorships as the sponsor.
   */

  readonly sponsorshipsAsSponsor: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsSponsor",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */

  readonly viewerCanSponsor: () => Field<"viewerCanSponsor">;

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */

  readonly viewerIsSponsoring: () => Field<"viewerIsSponsoring">;

  readonly on: <T extends Array<Selection>, F extends "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Sponsorable: SponsorableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */
  hasSponsorsListing: () => new Field("hasSponsorsListing"),

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */
  isSponsoringViewer: () => new Field("isSponsoringViewer"),

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: (select) =>
    new Field(
      "sponsorsListing",
      undefined as never,
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: (variables, select) =>
    new Field(
      "sponsorshipsAsMaintainer",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("includePrivate", variables.includePrivate),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: (variables, select) =>
    new Field(
      "sponsorshipsAsSponsor",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */
  viewerCanSponsor: () => new Field("viewerCanSponsor"),

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */
  viewerIsSponsoring: () => new Field("viewerIsSponsoring"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Sponsorable",
        });
    }
  },
};

export interface ISponsorsListing extends INode {
  readonly __typename: "SponsorsListing";
  readonly createdAt: unknown;
  readonly fullDescription: string;
  readonly fullDescriptionHTML: unknown;
  readonly name: string;
  readonly shortDescription: string;
  readonly slug: string;
  readonly tiers: ISponsorsTierConnection | null;
}

interface SponsorsListingSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The full description of the listing.
   */

  readonly fullDescription: () => Field<"fullDescription">;

  /**
   * @description The full description of the listing rendered to HTML.
   */

  readonly fullDescriptionHTML: () => Field<"fullDescriptionHTML">;

  readonly id: () => Field<"id">;

  /**
   * @description The listing's full name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The short description of the listing.
   */

  readonly shortDescription: () => Field<"shortDescription">;

  /**
   * @description The short name of the listing.
   */

  readonly slug: () => Field<"slug">;

  /**
   * @description The published tiers for this GitHub Sponsors listing.
   */

  readonly tiers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorsTierOrder;
    },
    select: (t: SponsorsTierConnectionSelector) => T
  ) => Field<
    "tiers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorsTierOrder>
    ],
    SelectionSet<T>
  >;
}

export const isSponsorsListing = (
  object: Record<string, any>
): object is Partial<ISponsorsListing> => {
  return object.__typename === "SponsorsListing";
};

export const SponsorsListing: SponsorsListingSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The full description of the listing.
   */
  fullDescription: () => new Field("fullDescription"),

  /**
   * @description The full description of the listing rendered to HTML.
   */
  fullDescriptionHTML: () => new Field("fullDescriptionHTML"),
  id: () => new Field("id"),

  /**
   * @description The listing's full name.
   */
  name: () => new Field("name"),

  /**
   * @description The short description of the listing.
   */
  shortDescription: () => new Field("shortDescription"),

  /**
   * @description The short name of the listing.
   */
  slug: () => new Field("slug"),

  /**
   * @description The published tiers for this GitHub Sponsors listing.
   */

  tiers: (variables, select) =>
    new Field(
      "tiers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorsTierConnection))
    ),
};

export interface ISponsorsTier extends INode {
  readonly __typename: "SponsorsTier";
  readonly adminInfo: ISponsorsTierAdminInfo | null;
  readonly createdAt: unknown;
  readonly description: string;
  readonly descriptionHTML: unknown;
  readonly monthlyPriceInCents: number;
  readonly monthlyPriceInDollars: number;
  readonly name: string;
  readonly sponsorsListing: ISponsorsListing;
  readonly updatedAt: unknown;
}

interface SponsorsTierSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description SponsorsTier information only visible to users that can administer the associated Sponsors listing.
   */

  readonly adminInfo: <T extends Array<Selection>>(
    select: (t: SponsorsTierAdminInfoSelector) => T
  ) => Field<"adminInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The description of the tier.
   */

  readonly description: () => Field<"description">;

  /**
   * @description The tier description rendered to HTML
   */

  readonly descriptionHTML: () => Field<"descriptionHTML">;

  readonly id: () => Field<"id">;

  /**
   * @description How much this tier costs per month in cents.
   */

  readonly monthlyPriceInCents: () => Field<"monthlyPriceInCents">;

  /**
   * @description How much this tier costs per month in dollars.
   */

  readonly monthlyPriceInDollars: () => Field<"monthlyPriceInDollars">;

  /**
   * @description The name of the tier.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The sponsors listing that this tier belongs to.
   */

  readonly sponsorsListing: <T extends Array<Selection>>(
    select: (t: SponsorsListingSelector) => T
  ) => Field<"sponsorsListing", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const isSponsorsTier = (
  object: Record<string, any>
): object is Partial<ISponsorsTier> => {
  return object.__typename === "SponsorsTier";
};

export const SponsorsTier: SponsorsTierSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description SponsorsTier information only visible to users that can administer the associated Sponsors listing.
   */

  adminInfo: (select) =>
    new Field(
      "adminInfo",
      undefined as never,
      new SelectionSet(select(SponsorsTierAdminInfo))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The description of the tier.
   */
  description: () => new Field("description"),

  /**
   * @description The tier description rendered to HTML
   */
  descriptionHTML: () => new Field("descriptionHTML"),
  id: () => new Field("id"),

  /**
   * @description How much this tier costs per month in cents.
   */
  monthlyPriceInCents: () => new Field("monthlyPriceInCents"),

  /**
   * @description How much this tier costs per month in dollars.
   */
  monthlyPriceInDollars: () => new Field("monthlyPriceInDollars"),

  /**
   * @description The name of the tier.
   */
  name: () => new Field("name"),

  /**
   * @description The sponsors listing that this tier belongs to.
   */

  sponsorsListing: (select) =>
    new Field(
      "sponsorsListing",
      undefined as never,
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface ISponsorsTierAdminInfo {
  readonly __typename: "SponsorsTierAdminInfo";
  readonly sponsorships: ISponsorshipConnection;
}

interface SponsorsTierAdminInfoSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The sponsorships associated with this tier.
   */

  readonly sponsorships: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      includePrivate?: Variable<"includePrivate"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorships",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"includePrivate", Variable<"includePrivate"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;
}

export const SponsorsTierAdminInfo: SponsorsTierAdminInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The sponsorships associated with this tier.
   */

  sponsorships: (variables, select) =>
    new Field(
      "sponsorships",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("includePrivate", variables.includePrivate),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),
};

export interface ISponsorsTierConnection {
  readonly __typename: "SponsorsTierConnection";
  readonly edges: ReadonlyArray<ISponsorsTierEdge> | null;
  readonly nodes: ReadonlyArray<ISponsorsTier> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface SponsorsTierConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: SponsorsTierEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: SponsorsTierSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const SponsorsTierConnection: SponsorsTierConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SponsorsTierEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SponsorsTier))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISponsorsTierEdge {
  readonly __typename: "SponsorsTierEdge";
  readonly cursor: string;
  readonly node: ISponsorsTier | null;
}

interface SponsorsTierEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: SponsorsTierSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SponsorsTierEdge: SponsorsTierEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(SponsorsTier))
    ),
};

export interface ISponsorship extends INode {
  readonly __typename: "Sponsorship";
  readonly createdAt: unknown;
  readonly maintainer: IUser;
  readonly privacyLevel: SponsorshipPrivacy;
  readonly sponsor: IUser | null;
  readonly sponsorEntity: ISponsor | null;
  readonly sponsorable: ISponsorable;
  readonly tier: ISponsorsTier | null;
}

interface SponsorshipSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */

  readonly maintainer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"maintainer", never, SelectionSet<T>>;

  /**
   * @description The privacy level for this sponsorship.
   */

  readonly privacyLevel: () => Field<"privacyLevel">;

  /**
   * @description The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */

  readonly sponsor: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"sponsor", never, SelectionSet<T>>;

  /**
   * @description The user or organization that is sponsoring, if you have permission to view them.
   */

  readonly sponsorEntity: <T extends Array<Selection>>(
    select: (t: SponsorSelector) => T
  ) => Field<"sponsorEntity", never, SelectionSet<T>>;

  /**
   * @description The entity that is being sponsored
   */

  readonly sponsorable: <T extends Array<Selection>>(
    select: (t: SponsorableSelector) => T
  ) => Field<"sponsorable", never, SelectionSet<T>>;

  /**
   * @description The associated sponsorship tier
   */

  readonly tier: <T extends Array<Selection>>(
    select: (t: SponsorsTierSelector) => T
  ) => Field<"tier", never, SelectionSet<T>>;
}

export const isSponsorship = (
  object: Record<string, any>
): object is Partial<ISponsorship> => {
  return object.__typename === "Sponsorship";
};

export const Sponsorship: SponsorshipSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */

  maintainer: (select) =>
    new Field("maintainer", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The privacy level for this sponsorship.
   */
  privacyLevel: () => new Field("privacyLevel"),

  /**
   * @description The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */

  sponsor: (select) =>
    new Field("sponsor", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The user or organization that is sponsoring, if you have permission to view them.
   */

  sponsorEntity: (select) =>
    new Field(
      "sponsorEntity",
      undefined as never,
      new SelectionSet(select(Sponsor))
    ),

  /**
   * @description The entity that is being sponsored
   */

  sponsorable: (select) =>
    new Field(
      "sponsorable",
      undefined as never,
      new SelectionSet(select(Sponsorable))
    ),

  /**
   * @description The associated sponsorship tier
   */

  tier: (select) =>
    new Field(
      "tier",
      undefined as never,
      new SelectionSet(select(SponsorsTier))
    ),
};

export interface ISponsorshipConnection {
  readonly __typename: "SponsorshipConnection";
  readonly edges: ReadonlyArray<ISponsorshipEdge> | null;
  readonly nodes: ReadonlyArray<ISponsorship> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface SponsorshipConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: SponsorshipEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: SponsorshipSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const SponsorshipConnection: SponsorshipConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SponsorshipEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Sponsorship))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISponsorshipEdge {
  readonly __typename: "SponsorshipEdge";
  readonly cursor: string;
  readonly node: ISponsorship | null;
}

interface SponsorshipEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: SponsorshipSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SponsorshipEdge: SponsorshipEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(Sponsorship))
    ),
};

export interface IStargazerConnection {
  readonly __typename: "StargazerConnection";
  readonly edges: ReadonlyArray<IStargazerEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface StargazerConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: StargazerEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const StargazerConnection: StargazerConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(StargazerEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IStargazerEdge {
  readonly __typename: "StargazerEdge";
  readonly cursor: string;
  readonly node: IUser;
  readonly starredAt: unknown;
}

interface StargazerEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description Identifies when the item was starred.
   */

  readonly starredAt: () => Field<"starredAt">;
}

export const StargazerEdge: StargazerEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Identifies when the item was starred.
   */
  starredAt: () => new Field("starredAt"),
};

export interface IStarrable {
  readonly __typename: string;
  readonly id: string;
  readonly stargazerCount: number;
  readonly stargazers: IStargazerConnection;
  readonly viewerHasStarred: boolean;
}

interface StarrableSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description Returns a count of how many stargazers there are on this object
   */

  readonly stargazerCount: () => Field<"stargazerCount">;

  /**
   * @description A list of users who have starred this starrable.
   */

  readonly stargazers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
    },
    select: (t: StargazerConnectionSelector) => T
  ) => Field<
    "stargazers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */

  readonly viewerHasStarred: () => Field<"viewerHasStarred">;

  readonly on: <
    T extends Array<Selection>,
    F extends "Gist" | "Repository" | "Topic"
  >(
    type: F,
    select: (
      t: F extends "Gist"
        ? GistSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "Topic"
        ? TopicSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Starrable: StarrableSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Returns a count of how many stargazers there are on this object
   */
  stargazerCount: () => new Field("stargazerCount"),

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: (variables, select) =>
    new Field(
      "stargazers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(StargazerConnection))
    ),

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */
  viewerHasStarred: () => new Field("viewerHasStarred"),

  on: (type, select) => {
    switch (type) {
      case "Gist": {
        return new InlineFragment(
          new NamedType("Gist") as any,
          new SelectionSet(select(Gist as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "Topic": {
        return new InlineFragment(
          new NamedType("Topic") as any,
          new SelectionSet(select(Topic as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Starrable",
        });
    }
  },
};

export interface IStarredRepositoryConnection {
  readonly __typename: "StarredRepositoryConnection";
  readonly edges: ReadonlyArray<IStarredRepositoryEdge> | null;
  readonly isOverLimit: boolean;
  readonly nodes: ReadonlyArray<IRepository> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface StarredRepositoryConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: StarredRepositoryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description Is the list of stars for this user truncated? This is true for users that have many stars.
   */

  readonly isOverLimit: () => Field<"isOverLimit">;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const StarredRepositoryConnection: StarredRepositoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(StarredRepositoryEdge))
    ),

  /**
   * @description Is the list of stars for this user truncated? This is true for users that have many stars.
   */
  isOverLimit: () => new Field("isOverLimit"),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IStarredRepositoryEdge {
  readonly __typename: "StarredRepositoryEdge";
  readonly cursor: string;
  readonly node: IRepository;
  readonly starredAt: unknown;
}

interface StarredRepositoryEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  readonly node: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description Identifies when the item was starred.
   */

  readonly starredAt: () => Field<"starredAt">;
}

export const StarredRepositoryEdge: StarredRepositoryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Repository))),

  /**
   * @description Identifies when the item was starred.
   */
  starredAt: () => new Field("starredAt"),
};

export interface IStatus extends INode {
  readonly __typename: "Status";
  readonly combinedContexts: IStatusCheckRollupContextConnection;
  readonly commit: ICommit | null;
  readonly context: IStatusContext | null;
  readonly contexts: ReadonlyArray<IStatusContext>;
  readonly state: StatusState;
}

interface StatusSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of status contexts and check runs for this commit.
   */

  readonly combinedContexts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: StatusCheckRollupContextConnectionSelector) => T
  ) => Field<
    "combinedContexts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The commit this status is attached to.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Looks up an individual status context by context name.
   */

  readonly context: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: StatusContextSelector) => T
  ) => Field<
    "context",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The individual status contexts for this commit.
   */

  readonly contexts: <T extends Array<Selection>>(
    select: (t: StatusContextSelector) => T
  ) => Field<"contexts", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The combined commit status.
   */

  readonly state: () => Field<"state">;
}

export const isStatus = (
  object: Record<string, any>
): object is Partial<IStatus> => {
  return object.__typename === "Status";
};

export const Status: StatusSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of status contexts and check runs for this commit.
   */

  combinedContexts: (variables, select) =>
    new Field(
      "combinedContexts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(StatusCheckRollupContextConnection))
    ),

  /**
   * @description The commit this status is attached to.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Looks up an individual status context by context name.
   */

  context: (variables, select) =>
    new Field(
      "context",
      [new Argument("name", variables.name)],
      new SelectionSet(select(StatusContext))
    ),

  /**
   * @description The individual status contexts for this commit.
   */

  contexts: (select) =>
    new Field(
      "contexts",
      undefined as never,
      new SelectionSet(select(StatusContext))
    ),

  id: () => new Field("id"),

  /**
   * @description The combined commit status.
   */
  state: () => new Field("state"),
};

export interface IStatusCheckRollup extends INode {
  readonly __typename: "StatusCheckRollup";
  readonly commit: ICommit | null;
  readonly contexts: IStatusCheckRollupContextConnection;
  readonly state: StatusState;
}

interface StatusCheckRollupSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The commit the status and check runs are attached to.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description A list of status contexts and check runs for this commit.
   */

  readonly contexts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: StatusCheckRollupContextConnectionSelector) => T
  ) => Field<
    "contexts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description The combined status for the commit.
   */

  readonly state: () => Field<"state">;
}

export const isStatusCheckRollup = (
  object: Record<string, any>
): object is Partial<IStatusCheckRollup> => {
  return object.__typename === "StatusCheckRollup";
};

export const StatusCheckRollup: StatusCheckRollupSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The commit the status and check runs are attached to.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description A list of status contexts and check runs for this commit.
   */

  contexts: (variables, select) =>
    new Field(
      "contexts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(StatusCheckRollupContextConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The combined status for the commit.
   */
  state: () => new Field("state"),
};

export interface IStatusCheckRollupContextConnection {
  readonly __typename: "StatusCheckRollupContextConnection";
  readonly edges: ReadonlyArray<IStatusCheckRollupContextEdge> | null;
  readonly nodes: ReadonlyArray<IStatusCheckRollupContext> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface StatusCheckRollupContextConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: StatusCheckRollupContextEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: StatusCheckRollupContextSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const StatusCheckRollupContextConnection: StatusCheckRollupContextConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(StatusCheckRollupContextEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(StatusCheckRollupContext))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IStatusCheckRollupContextEdge {
  readonly __typename: "StatusCheckRollupContextEdge";
  readonly cursor: string;
  readonly node: IStatusCheckRollupContext | null;
}

interface StatusCheckRollupContextEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: StatusCheckRollupContextSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const StatusCheckRollupContextEdge: StatusCheckRollupContextEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(StatusCheckRollupContext))
    ),
};

export interface IStatusContext extends INode {
  readonly __typename: "StatusContext";
  readonly avatarUrl: unknown | null;
  readonly commit: ICommit | null;
  readonly context: string;
  readonly createdAt: unknown;
  readonly creator: IActor | null;
  readonly description: string | null;
  readonly state: StatusState;
  readonly targetUrl: unknown | null;
}

interface StatusContextSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The avatar of the OAuth application or the user that created the status
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description This commit this status context is attached to.
   */

  readonly commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description The name of this status context.
   */

  readonly context: () => Field<"context">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The actor who created this status context.
   */

  readonly creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description The description for this status context.
   */

  readonly description: () => Field<"description">;

  readonly id: () => Field<"id">;

  /**
   * @description The state of this status context.
   */

  readonly state: () => Field<"state">;

  /**
   * @description The URL for this status context.
   */

  readonly targetUrl: () => Field<"targetUrl">;
}

export const isStatusContext = (
  object: Record<string, any>
): object is Partial<IStatusContext> => {
  return object.__typename === "StatusContext";
};

export const StatusContext: StatusContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The avatar of the OAuth application or the user that created the status
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description This commit this status context is attached to.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description The name of this status context.
   */
  context: () => new Field("context"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The actor who created this status context.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The description for this status context.
   */
  description: () => new Field("description"),
  id: () => new Field("id"),

  /**
   * @description The state of this status context.
   */
  state: () => new Field("state"),

  /**
   * @description The URL for this status context.
   */
  targetUrl: () => new Field("targetUrl"),
};

export interface ISubmitPullRequestReviewPayload {
  readonly __typename: "SubmitPullRequestReviewPayload";
  readonly clientMutationId: string | null;
  readonly pullRequestReview: IPullRequestReview | null;
}

interface SubmitPullRequestReviewPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The submitted pull request review.
   */

  readonly pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const SubmitPullRequestReviewPayload: SubmitPullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The submitted pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface ISubmodule {
  readonly __typename: "Submodule";
  readonly branch: string | null;
  readonly gitUrl: unknown;
  readonly name: string;
  readonly path: string;
  readonly subprojectCommitOid: unknown | null;
}

interface SubmoduleSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The branch of the upstream submodule for tracking updates
   */

  readonly branch: () => Field<"branch">;

  /**
   * @description The git URL of the submodule repository
   */

  readonly gitUrl: () => Field<"gitUrl">;

  /**
   * @description The name of the submodule in .gitmodules
   */

  readonly name: () => Field<"name">;

  /**
   * @description The path in the superproject that this submodule is located in
   */

  readonly path: () => Field<"path">;

  /**
   * @description The commit revision of the subproject repository being tracked by the submodule
   */

  readonly subprojectCommitOid: () => Field<"subprojectCommitOid">;
}

export const Submodule: SubmoduleSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The branch of the upstream submodule for tracking updates
   */
  branch: () => new Field("branch"),

  /**
   * @description The git URL of the submodule repository
   */
  gitUrl: () => new Field("gitUrl"),

  /**
   * @description The name of the submodule in .gitmodules
   */
  name: () => new Field("name"),

  /**
   * @description The path in the superproject that this submodule is located in
   */
  path: () => new Field("path"),

  /**
   * @description The commit revision of the subproject repository being tracked by the submodule
   */
  subprojectCommitOid: () => new Field("subprojectCommitOid"),
};

export interface ISubmoduleConnection {
  readonly __typename: "SubmoduleConnection";
  readonly edges: ReadonlyArray<ISubmoduleEdge> | null;
  readonly nodes: ReadonlyArray<ISubmodule> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface SubmoduleConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: SubmoduleEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: SubmoduleSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const SubmoduleConnection: SubmoduleConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SubmoduleEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Submodule))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISubmoduleEdge {
  readonly __typename: "SubmoduleEdge";
  readonly cursor: string;
  readonly node: ISubmodule | null;
}

interface SubmoduleEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: SubmoduleSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SubmoduleEdge: SubmoduleEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Submodule))),
};

export interface ISubscribable {
  readonly __typename: string;
  readonly id: string;
  readonly viewerCanSubscribe: boolean;
  readonly viewerSubscription: SubscriptionState | null;
}

interface SubscribableSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  readonly viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  readonly viewerSubscription: () => Field<"viewerSubscription">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "Commit"
      | "Issue"
      | "PullRequest"
      | "Repository"
      | "Team"
      | "TeamDiscussion"
  >(
    type: F,
    select: (
      t: F extends "Commit"
        ? CommitSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "Team"
        ? TeamSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Subscribable: SubscribableSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),

  on: (type, select) => {
    switch (type) {
      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Subscribable",
        });
    }
  },
};

export interface ISubscribedEvent extends INode {
  readonly __typename: "SubscribedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly subscribable: ISubscribable;
}

interface SubscribedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Object referenced by event.
   */

  readonly subscribable: <T extends Array<Selection>>(
    select: (t: SubscribableSelector) => T
  ) => Field<"subscribable", never, SelectionSet<T>>;
}

export const isSubscribedEvent = (
  object: Record<string, any>
): object is Partial<ISubscribedEvent> => {
  return object.__typename === "SubscribedEvent";
};

export const SubscribedEvent: SubscribedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Object referenced by event.
   */

  subscribable: (select) =>
    new Field(
      "subscribable",
      undefined as never,
      new SelectionSet(select(Subscribable))
    ),
};

export interface ISuggestedReviewer {
  readonly __typename: "SuggestedReviewer";
  readonly isAuthor: boolean;
  readonly isCommenter: boolean;
  readonly reviewer: IUser;
}

interface SuggestedReviewerSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Is this suggestion based on past commits?
   */

  readonly isAuthor: () => Field<"isAuthor">;

  /**
   * @description Is this suggestion based on past review comments?
   */

  readonly isCommenter: () => Field<"isCommenter">;

  /**
   * @description Identifies the user suggested to review the pull request.
   */

  readonly reviewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"reviewer", never, SelectionSet<T>>;
}

export const SuggestedReviewer: SuggestedReviewerSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Is this suggestion based on past commits?
   */
  isAuthor: () => new Field("isAuthor"),

  /**
   * @description Is this suggestion based on past review comments?
   */
  isCommenter: () => new Field("isCommenter"),

  /**
   * @description Identifies the user suggested to review the pull request.
   */

  reviewer: (select) =>
    new Field("reviewer", undefined as never, new SelectionSet(select(User))),
};

export interface ITag extends IGitObject, INode {
  readonly __typename: "Tag";
  readonly message: string | null;
  readonly name: string;
  readonly tagger: IGitActor | null;
  readonly target: IGitObject;
}

interface TagSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  readonly abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description The HTTP path for this Git object
   */

  readonly commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  readonly commitUrl: () => Field<"commitUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description The Git tag message.
   */

  readonly message: () => Field<"message">;

  /**
   * @description The Git tag name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The Git object ID
   */

  readonly oid: () => Field<"oid">;

  /**
   * @description The Repository the Git object belongs to
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description Details about the tag author.
   */

  readonly tagger: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"tagger", never, SelectionSet<T>>;

  /**
   * @description The Git object the tag points to.
   */

  readonly target: <T extends Array<Selection>>(
    select: (t: GitObjectSelector) => T
  ) => Field<"target", never, SelectionSet<T>>;
}

export const isTag = (object: Record<string, any>): object is Partial<ITag> => {
  return object.__typename === "Tag";
};

export const Tag: TagSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),
  id: () => new Field("id"),

  /**
   * @description The Git tag message.
   */
  message: () => new Field("message"),

  /**
   * @description The Git tag name.
   */
  name: () => new Field("name"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The Repository the Git object belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Details about the tag author.
   */

  tagger: (select) =>
    new Field("tagger", undefined as never, new SelectionSet(select(GitActor))),

  /**
   * @description The Git object the tag points to.
   */

  target: (select) =>
    new Field(
      "target",
      undefined as never,
      new SelectionSet(select(GitObject))
    ),
};

export interface ITeam extends IMemberStatusable, INode, ISubscribable {
  readonly __typename: "Team";
  readonly ancestors: ITeamConnection;
  readonly avatarUrl: unknown | null;
  readonly childTeams: ITeamConnection;
  readonly combinedSlug: string;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly description: string | null;
  readonly discussion: ITeamDiscussion | null;
  readonly discussions: ITeamDiscussionConnection;
  readonly discussionsResourcePath: unknown;
  readonly discussionsUrl: unknown;
  readonly editTeamResourcePath: unknown;
  readonly editTeamUrl: unknown;
  readonly invitations: IOrganizationInvitationConnection | null;
  readonly members: ITeamMemberConnection;
  readonly membersResourcePath: unknown;
  readonly membersUrl: unknown;
  readonly name: string;
  readonly newTeamResourcePath: unknown;
  readonly newTeamUrl: unknown;
  readonly organization: IOrganization;
  readonly parentTeam: ITeam | null;
  readonly privacy: TeamPrivacy;
  readonly repositories: ITeamRepositoryConnection;
  readonly repositoriesResourcePath: unknown;
  readonly repositoriesUrl: unknown;
  readonly resourcePath: unknown;
  readonly slug: string;
  readonly teamsResourcePath: unknown;
  readonly teamsUrl: unknown;
  readonly updatedAt: unknown;
  readonly url: unknown;
  readonly viewerCanAdminister: boolean;
}

interface TeamSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of teams that are ancestors of this team.
   */

  readonly ancestors: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "ancestors",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A URL pointing to the team's avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description List of child teams belonging to this team
   */

  readonly childTeams: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      immediateOnly?: Variable<"immediateOnly"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | TeamOrder;
      userLogins?: Variable<"userLogins"> | string;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "childTeams",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"immediateOnly", Variable<"immediateOnly"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | TeamOrder>,
      Argument<"userLogins", Variable<"userLogins"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The slug corresponding to the organization and team.
   */

  readonly combinedSlug: () => Field<"combinedSlug">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The description of the team.
   */

  readonly description: () => Field<"description">;

  /**
   * @description Find a team discussion by its number.
   */

  readonly discussion: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: TeamDiscussionSelector) => T
  ) => Field<
    "discussion",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of team discussions.
   */

  readonly discussions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isPinned?: Variable<"isPinned"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | TeamDiscussionOrder;
    },
    select: (t: TeamDiscussionConnectionSelector) => T
  ) => Field<
    "discussions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isPinned", Variable<"isPinned"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | TeamDiscussionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for team discussions
   */

  readonly discussionsResourcePath: () => Field<"discussionsResourcePath">;

  /**
   * @description The HTTP URL for team discussions
   */

  readonly discussionsUrl: () => Field<"discussionsUrl">;

  /**
   * @description The HTTP path for editing this team
   */

  readonly editTeamResourcePath: () => Field<"editTeamResourcePath">;

  /**
   * @description The HTTP URL for editing this team
   */

  readonly editTeamUrl: () => Field<"editTeamUrl">;

  readonly id: () => Field<"id">;

  /**
   * @description A list of pending invitations for users to this team
   */

  readonly invitations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: OrganizationInvitationConnectionSelector) => T
  ) => Field<
    "invitations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  readonly memberStatuses: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | UserStatusOrder;
    },
    select: (t: UserStatusConnectionSelector) => T
  ) => Field<
    "memberStatuses",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | UserStatusOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users who are members of this team.
   */

  readonly members: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      membership?: Variable<"membership"> | TeamMembershipType;
      orderBy?: Variable<"orderBy"> | TeamMemberOrder;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | TeamMemberRole;
    },
    select: (t: TeamMemberConnectionSelector) => T
  ) => Field<
    "members",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"membership", Variable<"membership"> | TeamMembershipType>,
      Argument<"orderBy", Variable<"orderBy"> | TeamMemberOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | TeamMemberRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for the team' members
   */

  readonly membersResourcePath: () => Field<"membersResourcePath">;

  /**
   * @description The HTTP URL for the team' members
   */

  readonly membersUrl: () => Field<"membersUrl">;

  /**
   * @description The name of the team.
   */

  readonly name: () => Field<"name">;

  /**
   * @description The HTTP path creating a new team
   */

  readonly newTeamResourcePath: () => Field<"newTeamResourcePath">;

  /**
   * @description The HTTP URL creating a new team
   */

  readonly newTeamUrl: () => Field<"newTeamUrl">;

  /**
   * @description The organization that owns this team.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The parent team of the team.
   */

  readonly parentTeam: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"parentTeam", never, SelectionSet<T>>;

  /**
   * @description The level of privacy the team has.
   */

  readonly privacy: () => Field<"privacy">;

  /**
   * @description A list of repositories this team has access to.
   */

  readonly repositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | TeamRepositoryOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: TeamRepositoryConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | TeamRepositoryOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this team's repositories
   */

  readonly repositoriesResourcePath: () => Field<"repositoriesResourcePath">;

  /**
   * @description The HTTP URL for this team's repositories
   */

  readonly repositoriesUrl: () => Field<"repositoriesUrl">;

  /**
   * @description The HTTP path for this team
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The slug corresponding to the team.
   */

  readonly slug: () => Field<"slug">;

  /**
   * @description The HTTP path for this team's teams
   */

  readonly teamsResourcePath: () => Field<"teamsResourcePath">;

  /**
   * @description The HTTP URL for this team's teams
   */

  readonly teamsUrl: () => Field<"teamsUrl">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this team
   */

  readonly url: () => Field<"url">;

  /**
   * @description Team is adminable by the viewer.
   */

  readonly viewerCanAdminister: () => Field<"viewerCanAdminister">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  readonly viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  readonly viewerSubscription: () => Field<"viewerSubscription">;
}

export const isTeam = (
  object: Record<string, any>
): object is Partial<ITeam> => {
  return object.__typename === "Team";
};

export const Team: TeamSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of teams that are ancestors of this team.
   */

  ancestors: (variables, select) =>
    new Field(
      "ancestors",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description A URL pointing to the team's avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description List of child teams belonging to this team
   */

  childTeams: (variables, select) =>
    new Field(
      "childTeams",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("immediateOnly", variables.immediateOnly),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("userLogins", variables.userLogins),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description The slug corresponding to the organization and team.
   */
  combinedSlug: () => new Field("combinedSlug"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The description of the team.
   */
  description: () => new Field("description"),

  /**
   * @description Find a team discussion by its number.
   */

  discussion: (variables, select) =>
    new Field(
      "discussion",
      [new Argument("number", variables.number)],
      new SelectionSet(select(TeamDiscussion))
    ),

  /**
   * @description A list of team discussions.
   */

  discussions: (variables, select) =>
    new Field(
      "discussions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isPinned", variables.isPinned),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(TeamDiscussionConnection))
    ),

  /**
   * @description The HTTP path for team discussions
   */
  discussionsResourcePath: () => new Field("discussionsResourcePath"),

  /**
   * @description The HTTP URL for team discussions
   */
  discussionsUrl: () => new Field("discussionsUrl"),

  /**
   * @description The HTTP path for editing this team
   */
  editTeamResourcePath: () => new Field("editTeamResourcePath"),

  /**
   * @description The HTTP URL for editing this team
   */
  editTeamUrl: () => new Field("editTeamUrl"),
  id: () => new Field("id"),

  /**
   * @description A list of pending invitations for users to this team
   */

  invitations: (variables, select) =>
    new Field(
      "invitations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(OrganizationInvitationConnection))
    ),

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: (variables, select) =>
    new Field(
      "memberStatuses",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(UserStatusConnection))
    ),

  /**
   * @description A list of users who are members of this team.
   */

  members: (variables, select) =>
    new Field(
      "members",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("membership", variables.membership, TeamMembershipType),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("role", variables.role, TeamMemberRole),
      ],
      new SelectionSet(select(TeamMemberConnection))
    ),

  /**
   * @description The HTTP path for the team' members
   */
  membersResourcePath: () => new Field("membersResourcePath"),

  /**
   * @description The HTTP URL for the team' members
   */
  membersUrl: () => new Field("membersUrl"),

  /**
   * @description The name of the team.
   */
  name: () => new Field("name"),

  /**
   * @description The HTTP path creating a new team
   */
  newTeamResourcePath: () => new Field("newTeamResourcePath"),

  /**
   * @description The HTTP URL creating a new team
   */
  newTeamUrl: () => new Field("newTeamUrl"),

  /**
   * @description The organization that owns this team.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The parent team of the team.
   */

  parentTeam: (select) =>
    new Field("parentTeam", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The level of privacy the team has.
   */
  privacy: () => new Field("privacy"),

  /**
   * @description A list of repositories this team has access to.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(TeamRepositoryConnection))
    ),

  /**
   * @description The HTTP path for this team's repositories
   */
  repositoriesResourcePath: () => new Field("repositoriesResourcePath"),

  /**
   * @description The HTTP URL for this team's repositories
   */
  repositoriesUrl: () => new Field("repositoriesUrl"),

  /**
   * @description The HTTP path for this team
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The slug corresponding to the team.
   */
  slug: () => new Field("slug"),

  /**
   * @description The HTTP path for this team's teams
   */
  teamsResourcePath: () => new Field("teamsResourcePath"),

  /**
   * @description The HTTP URL for this team's teams
   */
  teamsUrl: () => new Field("teamsUrl"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this team
   */
  url: () => new Field("url"),

  /**
   * @description Team is adminable by the viewer.
   */
  viewerCanAdminister: () => new Field("viewerCanAdminister"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),
};

export interface ITeamAddMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    ITeamAuditEntryData {
  readonly __typename: "TeamAddMemberAuditEntry";
  readonly isLdapMapped: boolean | null;
}

interface TeamAddMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  readonly isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The team associated with the action
   */

  readonly team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  readonly teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  readonly teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  readonly teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isTeamAddMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamAddMemberAuditEntry> => {
  return object.__typename === "TeamAddMemberAuditEntry";
};

export const TeamAddMemberAuditEntry: TeamAddMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamAddRepositoryAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData,
    ITeamAuditEntryData {
  readonly __typename: "TeamAddRepositoryAuditEntry";
  readonly isLdapMapped: boolean | null;
}

interface TeamAddRepositoryAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  readonly isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The team associated with the action
   */

  readonly team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  readonly teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  readonly teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  readonly teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isTeamAddRepositoryAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamAddRepositoryAuditEntry> => {
  return object.__typename === "TeamAddRepositoryAuditEntry";
};

export const TeamAddRepositoryAuditEntry: TeamAddRepositoryAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamAuditEntryData {
  readonly __typename: string;
  readonly team: ITeam | null;
  readonly teamName: string | null;
  readonly teamResourcePath: unknown | null;
  readonly teamUrl: unknown | null;
}

interface TeamAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The team associated with the action
   */

  readonly team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  readonly teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  readonly teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  readonly teamUrl: () => Field<"teamUrl">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "OrgRestoreMemberMembershipTeamAuditEntryData"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "OrgRestoreMemberMembershipTeamAuditEntryData"
        ? OrgRestoreMemberMembershipTeamAuditEntryDataSelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const TeamAuditEntryData: TeamAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  on: (type, select) => {
    switch (type) {
      case "OrgRestoreMemberMembershipTeamAuditEntryData": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberMembershipTeamAuditEntryData") as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipTeamAuditEntryData as any)
          )
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "TeamAuditEntryData",
        });
    }
  },
};

export interface ITeamChangeParentTeamAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    ITeamAuditEntryData {
  readonly __typename: "TeamChangeParentTeamAuditEntry";
  readonly isLdapMapped: boolean | null;
  readonly parentTeam: ITeam | null;
  readonly parentTeamName: string | null;
  readonly parentTeamNameWas: string | null;
  readonly parentTeamResourcePath: unknown | null;
  readonly parentTeamUrl: unknown | null;
  readonly parentTeamWas: ITeam | null;
  readonly parentTeamWasResourcePath: unknown | null;
  readonly parentTeamWasUrl: unknown | null;
}

interface TeamChangeParentTeamAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  readonly isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The new parent team.
   */

  readonly parentTeam: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"parentTeam", never, SelectionSet<T>>;

  /**
   * @description The name of the new parent team
   */

  readonly parentTeamName: () => Field<"parentTeamName">;

  /**
   * @description The name of the former parent team
   */

  readonly parentTeamNameWas: () => Field<"parentTeamNameWas">;

  /**
   * @description The HTTP path for the parent team
   */

  readonly parentTeamResourcePath: () => Field<"parentTeamResourcePath">;

  /**
   * @description The HTTP URL for the parent team
   */

  readonly parentTeamUrl: () => Field<"parentTeamUrl">;

  /**
   * @description The former parent team.
   */

  readonly parentTeamWas: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"parentTeamWas", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for the previous parent team
   */

  readonly parentTeamWasResourcePath: () => Field<"parentTeamWasResourcePath">;

  /**
   * @description The HTTP URL for the previous parent team
   */

  readonly parentTeamWasUrl: () => Field<"parentTeamWasUrl">;

  /**
   * @description The team associated with the action
   */

  readonly team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  readonly teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  readonly teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  readonly teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isTeamChangeParentTeamAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamChangeParentTeamAuditEntry> => {
  return object.__typename === "TeamChangeParentTeamAuditEntry";
};

export const TeamChangeParentTeamAuditEntry: TeamChangeParentTeamAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The new parent team.
   */

  parentTeam: (select) =>
    new Field("parentTeam", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the new parent team
   */
  parentTeamName: () => new Field("parentTeamName"),

  /**
   * @description The name of the former parent team
   */
  parentTeamNameWas: () => new Field("parentTeamNameWas"),

  /**
   * @description The HTTP path for the parent team
   */
  parentTeamResourcePath: () => new Field("parentTeamResourcePath"),

  /**
   * @description The HTTP URL for the parent team
   */
  parentTeamUrl: () => new Field("parentTeamUrl"),

  /**
   * @description The former parent team.
   */

  parentTeamWas: (select) =>
    new Field(
      "parentTeamWas",
      undefined as never,
      new SelectionSet(select(Team))
    ),

  /**
   * @description The HTTP path for the previous parent team
   */
  parentTeamWasResourcePath: () => new Field("parentTeamWasResourcePath"),

  /**
   * @description The HTTP URL for the previous parent team
   */
  parentTeamWasUrl: () => new Field("parentTeamWasUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamConnection {
  readonly __typename: "TeamConnection";
  readonly edges: ReadonlyArray<ITeamEdge> | null;
  readonly nodes: ReadonlyArray<ITeam> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface TeamConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: TeamEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const TeamConnection: TeamConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(TeamEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamDiscussion
  extends IComment,
    IDeletable,
    INode,
    IReactable,
    ISubscribable,
    IUniformResourceLocatable,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "TeamDiscussion";
  readonly bodyVersion: string;
  readonly comments: ITeamDiscussionCommentConnection;
  readonly commentsResourcePath: unknown;
  readonly commentsUrl: unknown;
  readonly isPinned: boolean;
  readonly isPrivate: boolean;
  readonly number: number;
  readonly team: ITeam;
  readonly title: string;
  readonly viewerCanPin: boolean;
}

interface TeamDiscussionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the discussion's team.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The body as Markdown.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the discussion body hash.
   */

  readonly bodyVersion: () => Field<"bodyVersion">;

  /**
   * @description A list of comments on this discussion.
   */

  readonly comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      fromComment?: Variable<"fromComment"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | TeamDiscussionCommentOrder;
    },
    select: (t: TeamDiscussionCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"fromComment", Variable<"fromComment"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | TeamDiscussionCommentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for discussion comments
   */

  readonly commentsResourcePath: () => Field<"commentsResourcePath">;

  /**
   * @description The HTTP URL for discussion comments
   */

  readonly commentsUrl: () => Field<"commentsUrl">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Whether or not the discussion is pinned.
   */

  readonly isPinned: () => Field<"isPinned">;

  /**
   * @description Whether or not the discussion is only visible to team members and org admins.
   */

  readonly isPrivate: () => Field<"isPrivate">;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Identifies the discussion within its team.
   */

  readonly number: () => Field<"number">;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this discussion
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The team that defines the context of this discussion.
   */

  readonly team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The title of the discussion
   */

  readonly title: () => Field<"title">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this discussion
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  readonly viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Whether or not the current viewer can pin this discussion.
   */

  readonly viewerCanPin: () => Field<"viewerCanPin">;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  readonly viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  readonly viewerSubscription: () => Field<"viewerSubscription">;
}

export const isTeamDiscussion = (
  object: Record<string, any>
): object is Partial<ITeamDiscussion> => {
  return object.__typename === "TeamDiscussion";
};

export const TeamDiscussion: TeamDiscussionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the discussion's team.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the discussion body hash.
   */
  bodyVersion: () => new Field("bodyVersion"),

  /**
   * @description A list of comments on this discussion.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("fromComment", variables.fromComment),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(TeamDiscussionCommentConnection))
    ),

  /**
   * @description The HTTP path for discussion comments
   */
  commentsResourcePath: () => new Field("commentsResourcePath"),

  /**
   * @description The HTTP URL for discussion comments
   */
  commentsUrl: () => new Field("commentsUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Whether or not the discussion is pinned.
   */
  isPinned: () => new Field("isPinned"),

  /**
   * @description Whether or not the discussion is only visible to team members and org admins.
   */
  isPrivate: () => new Field("isPrivate"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Identifies the discussion within its team.
   */
  number: () => new Field("number"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The HTTP path for this discussion
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The team that defines the context of this discussion.
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The title of the discussion
   */
  title: () => new Field("title"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this discussion
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Whether or not the current viewer can pin this discussion.
   */
  viewerCanPin: () => new Field("viewerCanPin"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),
};

export interface ITeamDiscussionComment
  extends IComment,
    IDeletable,
    INode,
    IReactable,
    IUniformResourceLocatable,
    IUpdatable,
    IUpdatableComment {
  readonly __typename: "TeamDiscussionComment";
  readonly bodyVersion: string;
  readonly discussion: ITeamDiscussion;
  readonly number: number;
}

interface TeamDiscussionCommentSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  readonly author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the comment's team.
   */

  readonly authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The body as Markdown.
   */

  readonly body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  readonly bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  readonly bodyText: () => Field<"bodyText">;

  /**
   * @description The current version of the body content.
   */

  readonly bodyVersion: () => Field<"bodyVersion">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  readonly createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The discussion this comment is about.
   */

  readonly discussion: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"discussion", never, SelectionSet<T>>;

  /**
   * @description The actor who edited the comment.
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  readonly includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description The moment the editor made the last edit
   */

  readonly lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Identifies the comment number.
   */

  readonly number: () => Field<"number">;

  /**
   * @description Identifies when the comment was published at.
   */

  readonly publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  readonly reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  readonly reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this comment
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this comment
   */

  readonly url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  readonly userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  readonly viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Can user react to this subject
   */

  readonly viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  readonly viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isTeamDiscussionComment = (
  object: Record<string, any>
): object is Partial<ITeamDiscussionComment> => {
  return object.__typename === "TeamDiscussionComment";
};

export const TeamDiscussionComment: TeamDiscussionCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the comment's team.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description The current version of the body content.
   */
  bodyVersion: () => new Field("bodyVersion"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The discussion this comment is about.
   */

  discussion: (select) =>
    new Field(
      "discussion",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Identifies the comment number.
   */
  number: () => new Field("number"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The HTTP path for this comment
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this comment
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface ITeamDiscussionCommentConnection {
  readonly __typename: "TeamDiscussionCommentConnection";
  readonly edges: ReadonlyArray<ITeamDiscussionCommentEdge> | null;
  readonly nodes: ReadonlyArray<ITeamDiscussionComment> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface TeamDiscussionCommentConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const TeamDiscussionCommentConnection: TeamDiscussionCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(TeamDiscussionCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(TeamDiscussionComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamDiscussionCommentEdge {
  readonly __typename: "TeamDiscussionCommentEdge";
  readonly cursor: string;
  readonly node: ITeamDiscussionComment | null;
}

interface TeamDiscussionCommentEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const TeamDiscussionCommentEdge: TeamDiscussionCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(TeamDiscussionComment))
    ),
};

export interface ITeamDiscussionConnection {
  readonly __typename: "TeamDiscussionConnection";
  readonly edges: ReadonlyArray<ITeamDiscussionEdge> | null;
  readonly nodes: ReadonlyArray<ITeamDiscussion> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface TeamDiscussionConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: TeamDiscussionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const TeamDiscussionConnection: TeamDiscussionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(TeamDiscussionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamDiscussionEdge {
  readonly __typename: "TeamDiscussionEdge";
  readonly cursor: string;
  readonly node: ITeamDiscussion | null;
}

interface TeamDiscussionEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const TeamDiscussionEdge: TeamDiscussionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),
};

export interface ITeamEdge {
  readonly __typename: "TeamEdge";
  readonly cursor: string;
  readonly node: ITeam | null;
}

interface TeamEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const TeamEdge: TeamEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Team))),
};

export interface ITeamMemberConnection {
  readonly __typename: "TeamMemberConnection";
  readonly edges: ReadonlyArray<ITeamMemberEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface TeamMemberConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: TeamMemberEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const TeamMemberConnection: TeamMemberConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(TeamMemberEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamMemberEdge {
  readonly __typename: "TeamMemberEdge";
  readonly cursor: string;
  readonly memberAccessResourcePath: unknown;
  readonly memberAccessUrl: unknown;
  readonly node: IUser;
  readonly role: TeamMemberRole;
}

interface TeamMemberEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The HTTP path to the organization's member access page.
   */

  readonly memberAccessResourcePath: () => Field<"memberAccessResourcePath">;

  /**
   * @description The HTTP URL to the organization's member access page.
   */

  readonly memberAccessUrl: () => Field<"memberAccessUrl">;

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The role the member has on the team.
   */

  readonly role: () => Field<"role">;
}

export const TeamMemberEdge: TeamMemberEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The HTTP path to the organization's member access page.
   */
  memberAccessResourcePath: () => new Field("memberAccessResourcePath"),

  /**
   * @description The HTTP URL to the organization's member access page.
   */
  memberAccessUrl: () => new Field("memberAccessUrl"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The role the member has on the team.
   */
  role: () => new Field("role"),
};

export interface ITeamRemoveMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    ITeamAuditEntryData {
  readonly __typename: "TeamRemoveMemberAuditEntry";
  readonly isLdapMapped: boolean | null;
}

interface TeamRemoveMemberAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  readonly isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The team associated with the action
   */

  readonly team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  readonly teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  readonly teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  readonly teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isTeamRemoveMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamRemoveMemberAuditEntry> => {
  return object.__typename === "TeamRemoveMemberAuditEntry";
};

export const TeamRemoveMemberAuditEntry: TeamRemoveMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamRemoveRepositoryAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData,
    ITeamAuditEntryData {
  readonly __typename: "TeamRemoveRepositoryAuditEntry";
  readonly isLdapMapped: boolean | null;
}

interface TeamRemoveRepositoryAuditEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  readonly action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  readonly actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  readonly actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  readonly actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  readonly actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  readonly actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  readonly isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  readonly operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  readonly organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  readonly organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  readonly organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  readonly repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  readonly repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  readonly repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The team associated with the action
   */

  readonly team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  readonly teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  readonly teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  readonly teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  readonly userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  readonly userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  readonly userUrl: () => Field<"userUrl">;
}

export const isTeamRemoveRepositoryAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamRemoveRepositoryAuditEntry> => {
  return object.__typename === "TeamRemoveRepositoryAuditEntry";
};

export const TeamRemoveRepositoryAuditEntry: TeamRemoveRepositoryAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamRepositoryConnection {
  readonly __typename: "TeamRepositoryConnection";
  readonly edges: ReadonlyArray<ITeamRepositoryEdge> | null;
  readonly nodes: ReadonlyArray<IRepository> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface TeamRepositoryConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: TeamRepositoryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const TeamRepositoryConnection: TeamRepositoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(TeamRepositoryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamRepositoryEdge {
  readonly __typename: "TeamRepositoryEdge";
  readonly cursor: string;
  readonly node: IRepository;
  readonly permission: RepositoryPermission;
}

interface TeamRepositoryEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  readonly node: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The permission level the team has on the repository
   */

  readonly permission: () => Field<"permission">;
}

export const TeamRepositoryEdge: TeamRepositoryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Repository))),

  /**
   * @description The permission level the team has on the repository
   */
  permission: () => new Field("permission"),
};

export interface ITextMatch {
  readonly __typename: "TextMatch";
  readonly fragment: string;
  readonly highlights: ReadonlyArray<ITextMatchHighlight>;
  readonly property: string;
}

interface TextMatchSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The specific text fragment within the property matched on.
   */

  readonly fragment: () => Field<"fragment">;

  /**
   * @description Highlights within the matched fragment.
   */

  readonly highlights: <T extends Array<Selection>>(
    select: (t: TextMatchHighlightSelector) => T
  ) => Field<"highlights", never, SelectionSet<T>>;

  /**
   * @description The property matched on.
   */

  readonly property: () => Field<"property">;
}

export const TextMatch: TextMatchSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The specific text fragment within the property matched on.
   */
  fragment: () => new Field("fragment"),

  /**
   * @description Highlights within the matched fragment.
   */

  highlights: (select) =>
    new Field(
      "highlights",
      undefined as never,
      new SelectionSet(select(TextMatchHighlight))
    ),

  /**
   * @description The property matched on.
   */
  property: () => new Field("property"),
};

export interface ITextMatchHighlight {
  readonly __typename: "TextMatchHighlight";
  readonly beginIndice: number;
  readonly endIndice: number;
  readonly text: string;
}

interface TextMatchHighlightSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The indice in the fragment where the matched text begins.
   */

  readonly beginIndice: () => Field<"beginIndice">;

  /**
   * @description The indice in the fragment where the matched text ends.
   */

  readonly endIndice: () => Field<"endIndice">;

  /**
   * @description The text matched.
   */

  readonly text: () => Field<"text">;
}

export const TextMatchHighlight: TextMatchHighlightSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The indice in the fragment where the matched text begins.
   */
  beginIndice: () => new Field("beginIndice"),

  /**
   * @description The indice in the fragment where the matched text ends.
   */
  endIndice: () => new Field("endIndice"),

  /**
   * @description The text matched.
   */
  text: () => new Field("text"),
};

export interface ITopic extends INode, IStarrable {
  readonly __typename: "Topic";
  readonly name: string;
  readonly relatedTopics: ReadonlyArray<ITopic>;
}

interface TopicSelector {
  readonly __typename: () => Field<"__typename">;

  readonly id: () => Field<"id">;

  /**
   * @description The topic's name.
   */

  readonly name: () => Field<"name">;

  /**
     * @description A list of related topics, including aliases of this topic, sorted with the most relevant
first. Returns up to 10 Topics.
     */

  readonly relatedTopics: <T extends Array<Selection>>(
    variables: { first?: Variable<"first"> | number },
    select: (t: TopicSelector) => T
  ) => Field<
    "relatedTopics",
    [Argument<"first", Variable<"first"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description Returns a count of how many stargazers there are on this object
   */

  readonly stargazerCount: () => Field<"stargazerCount">;

  /**
   * @description A list of users who have starred this starrable.
   */

  readonly stargazers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
    },
    select: (t: StargazerConnectionSelector) => T
  ) => Field<
    "stargazers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */

  readonly viewerHasStarred: () => Field<"viewerHasStarred">;
}

export const isTopic = (
  object: Record<string, any>
): object is Partial<ITopic> => {
  return object.__typename === "Topic";
};

export const Topic: TopicSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description The topic's name.
   */
  name: () => new Field("name"),

  /**
     * @description A list of related topics, including aliases of this topic, sorted with the most relevant
first. Returns up to 10 Topics.
     */

  relatedTopics: (variables, select) =>
    new Field(
      "relatedTopics",
      [new Argument("first", variables.first)],
      new SelectionSet(select(Topic))
    ),

  /**
   * @description Returns a count of how many stargazers there are on this object
   */
  stargazerCount: () => new Field("stargazerCount"),

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: (variables, select) =>
    new Field(
      "stargazers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(StargazerConnection))
    ),

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */
  viewerHasStarred: () => new Field("viewerHasStarred"),
};

export interface ITopicAuditEntryData {
  readonly __typename: string;
  readonly topic: ITopic | null;
  readonly topicName: string | null;
}

interface TopicAuditEntryDataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The name of the topic added to the repository
   */

  readonly topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;

  /**
   * @description The name of the topic added to the repository
   */

  readonly topicName: () => Field<"topicName">;

  readonly on: <
    T extends Array<Selection>,
    F extends "RepoAddTopicAuditEntry" | "RepoRemoveTopicAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const TopicAuditEntryData: TopicAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The name of the topic added to the repository
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),

  /**
   * @description The name of the topic added to the repository
   */
  topicName: () => new Field("topicName"),

  on: (type, select) => {
    switch (type) {
      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "TopicAuditEntryData",
        });
    }
  },
};

export interface ITransferIssuePayload {
  readonly __typename: "TransferIssuePayload";
  readonly clientMutationId: string | null;
  readonly issue: IIssue | null;
}

interface TransferIssuePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue that was transferred
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const TransferIssuePayload: TransferIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue that was transferred
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface ITransferredEvent extends INode {
  readonly __typename: "TransferredEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly fromRepository: IRepository | null;
  readonly issue: IIssue;
}

interface TransferredEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The repository this came from
   */

  readonly fromRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"fromRepository", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the issue associated with the event.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const isTransferredEvent = (
  object: Record<string, any>
): object is Partial<ITransferredEvent> => {
  return object.__typename === "TransferredEvent";
};

export const TransferredEvent: TransferredEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The repository this came from
   */

  fromRepository: (select) =>
    new Field(
      "fromRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  id: () => new Field("id"),

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface ITree extends IGitObject, INode {
  readonly __typename: "Tree";
  readonly entries: ReadonlyArray<ITreeEntry> | null;
}

interface TreeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  readonly abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description The HTTP path for this Git object
   */

  readonly commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  readonly commitUrl: () => Field<"commitUrl">;

  /**
   * @description A list of tree entries.
   */

  readonly entries: <T extends Array<Selection>>(
    select: (t: TreeEntrySelector) => T
  ) => Field<"entries", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description The Git object ID
   */

  readonly oid: () => Field<"oid">;

  /**
   * @description The Repository the Git object belongs to
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isTree = (
  object: Record<string, any>
): object is Partial<ITree> => {
  return object.__typename === "Tree";
};

export const Tree: TreeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),

  /**
   * @description A list of tree entries.
   */

  entries: (select) =>
    new Field(
      "entries",
      undefined as never,
      new SelectionSet(select(TreeEntry))
    ),

  id: () => new Field("id"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The Repository the Git object belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ITreeEntry {
  readonly __typename: "TreeEntry";
  readonly extension: string | null;
  readonly isGenerated: boolean;
  readonly mode: number;
  readonly name: string;
  readonly object: IGitObject | null;
  readonly oid: unknown;
  readonly path: string | null;
  readonly repository: IRepository;
  readonly submodule: ISubmodule | null;
  readonly type: string;
}

interface TreeEntrySelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The extension of the file
   */

  readonly extension: () => Field<"extension">;

  /**
   * @description Whether or not this tree entry is generated
   */

  readonly isGenerated: () => Field<"isGenerated">;

  /**
   * @description Entry file mode.
   */

  readonly mode: () => Field<"mode">;

  /**
   * @description Entry file name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description Entry file object.
   */

  readonly object: <T extends Array<Selection>>(
    select: (t: GitObjectSelector) => T
  ) => Field<"object", never, SelectionSet<T>>;

  /**
   * @description Entry file Git object ID.
   */

  readonly oid: () => Field<"oid">;

  /**
   * @description The full path of the file.
   */

  readonly path: () => Field<"path">;

  /**
   * @description The Repository the tree entry belongs to
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule
   */

  readonly submodule: <T extends Array<Selection>>(
    select: (t: SubmoduleSelector) => T
  ) => Field<"submodule", never, SelectionSet<T>>;

  /**
   * @description Entry file type.
   */

  readonly type: () => Field<"type">;
}

export const TreeEntry: TreeEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The extension of the file
   */
  extension: () => new Field("extension"),

  /**
   * @description Whether or not this tree entry is generated
   */
  isGenerated: () => new Field("isGenerated"),

  /**
   * @description Entry file mode.
   */
  mode: () => new Field("mode"),

  /**
   * @description Entry file name.
   */
  name: () => new Field("name"),

  /**
   * @description Entry file object.
   */

  object: (select) =>
    new Field(
      "object",
      undefined as never,
      new SelectionSet(select(GitObject))
    ),

  /**
   * @description Entry file Git object ID.
   */
  oid: () => new Field("oid"),

  /**
   * @description The full path of the file.
   */
  path: () => new Field("path"),

  /**
   * @description The Repository the tree entry belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule
   */

  submodule: (select) =>
    new Field(
      "submodule",
      undefined as never,
      new SelectionSet(select(Submodule))
    ),

  /**
   * @description Entry file type.
   */
  type: () => new Field("type"),
};

export interface IUnarchiveRepositoryPayload {
  readonly __typename: "UnarchiveRepositoryPayload";
  readonly clientMutationId: string | null;
  readonly repository: IRepository | null;
}

interface UnarchiveRepositoryPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository that was unarchived.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UnarchiveRepositoryPayload: UnarchiveRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository that was unarchived.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUnassignedEvent extends INode {
  readonly __typename: "UnassignedEvent";
  readonly actor: IActor | null;
  readonly assignable: IAssignable;
  readonly assignee: IAssignee | null;
  readonly createdAt: unknown;
  readonly user: IUser | null;
}

interface UnassignedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the assignable associated with the event.
   */

  readonly assignable: <T extends Array<Selection>>(
    select: (t: AssignableSelector) => T
  ) => Field<"assignable", never, SelectionSet<T>>;

  /**
   * @description Identifies the user or mannequin that was unassigned.
   */

  readonly assignee: <T extends Array<Selection>>(
    select: (t: AssigneeSelector) => T
  ) => Field<"assignee", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isUnassignedEvent = (
  object: Record<string, any>
): object is Partial<IUnassignedEvent> => {
  return object.__typename === "UnassignedEvent";
};

export const UnassignedEvent: UnassignedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the assignable associated with the event.
   */

  assignable: (select) =>
    new Field(
      "assignable",
      undefined as never,
      new SelectionSet(select(Assignable))
    ),

  /**
   * @description Identifies the user or mannequin that was unassigned.
   */

  assignee: (select) =>
    new Field(
      "assignee",
      undefined as never,
      new SelectionSet(select(Assignee))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IUnfollowUserPayload {
  readonly __typename: "UnfollowUserPayload";
  readonly clientMutationId: string | null;
  readonly user: IUser | null;
}

interface UnfollowUserPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The user that was unfollowed.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const UnfollowUserPayload: UnfollowUserPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The user that was unfollowed.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IUniformResourceLocatable {
  readonly __typename: string;
  readonly resourcePath: unknown;
  readonly url: unknown;
}

interface UniformResourceLocatableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The HTML path to this resource.
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description The URL to this resource.
   */

  readonly url: () => Field<"url">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "Bot"
      | "CheckRun"
      | "ClosedEvent"
      | "Commit"
      | "ConvertToDraftEvent"
      | "CrossReferencedEvent"
      | "Gist"
      | "Issue"
      | "Mannequin"
      | "MergedEvent"
      | "Milestone"
      | "Organization"
      | "PullRequest"
      | "PullRequestCommit"
      | "ReadyForReviewEvent"
      | "Release"
      | "Repository"
      | "RepositoryTopic"
      | "ReviewDismissedEvent"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
      | "User"
  >(
    type: F,
    select: (
      t: F extends "Bot"
        ? BotSelector
        : F extends "CheckRun"
        ? CheckRunSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "ConvertToDraftEvent"
        ? ConvertToDraftEventSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "Gist"
        ? GistSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "Mannequin"
        ? MannequinSelector
        : F extends "MergedEvent"
        ? MergedEventSelector
        : F extends "Milestone"
        ? MilestoneSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestCommit"
        ? PullRequestCommitSelector
        : F extends "ReadyForReviewEvent"
        ? ReadyForReviewEventSelector
        : F extends "Release"
        ? ReleaseSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "RepositoryTopic"
        ? RepositoryTopicSelector
        : F extends "ReviewDismissedEvent"
        ? ReviewDismissedEventSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const UniformResourceLocatable: UniformResourceLocatableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The HTML path to this resource.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The URL to this resource.
   */
  url: () => new Field("url"),

  on: (type, select) => {
    switch (type) {
      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "CheckRun": {
        return new InlineFragment(
          new NamedType("CheckRun") as any,
          new SelectionSet(select(CheckRun as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "ConvertToDraftEvent": {
        return new InlineFragment(
          new NamedType("ConvertToDraftEvent") as any,
          new SelectionSet(select(ConvertToDraftEvent as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "Gist": {
        return new InlineFragment(
          new NamedType("Gist") as any,
          new SelectionSet(select(Gist as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "MergedEvent": {
        return new InlineFragment(
          new NamedType("MergedEvent") as any,
          new SelectionSet(select(MergedEvent as any))
        );
      }

      case "Milestone": {
        return new InlineFragment(
          new NamedType("Milestone") as any,
          new SelectionSet(select(Milestone as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestCommit": {
        return new InlineFragment(
          new NamedType("PullRequestCommit") as any,
          new SelectionSet(select(PullRequestCommit as any))
        );
      }

      case "ReadyForReviewEvent": {
        return new InlineFragment(
          new NamedType("ReadyForReviewEvent") as any,
          new SelectionSet(select(ReadyForReviewEvent as any))
        );
      }

      case "Release": {
        return new InlineFragment(
          new NamedType("Release") as any,
          new SelectionSet(select(Release as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "RepositoryTopic": {
        return new InlineFragment(
          new NamedType("RepositoryTopic") as any,
          new SelectionSet(select(RepositoryTopic as any))
        );
      }

      case "ReviewDismissedEvent": {
        return new InlineFragment(
          new NamedType("ReviewDismissedEvent") as any,
          new SelectionSet(select(ReviewDismissedEvent as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "UniformResourceLocatable",
        });
    }
  },
};

export interface IUnknownSignature extends IGitSignature {
  readonly __typename: "UnknownSignature";
}

interface UnknownSignatureSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Email used to sign this object.
   */

  readonly email: () => Field<"email">;

  /**
   * @description True if the signature is valid and verified by GitHub.
   */

  readonly isValid: () => Field<"isValid">;

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */

  readonly payload: () => Field<"payload">;

  /**
   * @description ASCII-armored signature header from object.
   */

  readonly signature: () => Field<"signature">;

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  readonly signer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"signer", never, SelectionSet<T>>;

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */

  readonly state: () => Field<"state">;

  /**
   * @description True if the signature was made with GitHub's signing key.
   */

  readonly wasSignedByGitHub: () => Field<"wasSignedByGitHub">;
}

export const isUnknownSignature = (
  object: Record<string, any>
): object is Partial<IUnknownSignature> => {
  return object.__typename === "UnknownSignature";
};

export const UnknownSignature: UnknownSignatureSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Email used to sign this object.
   */
  email: () => new Field("email"),

  /**
   * @description True if the signature is valid and verified by GitHub.
   */
  isValid: () => new Field("isValid"),

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */
  payload: () => new Field("payload"),

  /**
   * @description ASCII-armored signature header from object.
   */
  signature: () => new Field("signature"),

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: (select) =>
    new Field("signer", undefined as never, new SelectionSet(select(User))),

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */
  state: () => new Field("state"),

  /**
   * @description True if the signature was made with GitHub's signing key.
   */
  wasSignedByGitHub: () => new Field("wasSignedByGitHub"),
};

export interface IUnlabeledEvent extends INode {
  readonly __typename: "UnlabeledEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly label: ILabel;
  readonly labelable: ILabelable;
}

interface UnlabeledEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the label associated with the 'unlabeled' event.
   */

  readonly label: <T extends Array<Selection>>(
    select: (t: LabelSelector) => T
  ) => Field<"label", never, SelectionSet<T>>;

  /**
   * @description Identifies the `Labelable` associated with the event.
   */

  readonly labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const isUnlabeledEvent = (
  object: Record<string, any>
): object is Partial<IUnlabeledEvent> => {
  return object.__typename === "UnlabeledEvent";
};

export const UnlabeledEvent: UnlabeledEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the label associated with the 'unlabeled' event.
   */

  label: (select) =>
    new Field("label", undefined as never, new SelectionSet(select(Label))),

  /**
   * @description Identifies the `Labelable` associated with the event.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface IUnlinkRepositoryFromProjectPayload {
  readonly __typename: "UnlinkRepositoryFromProjectPayload";
  readonly clientMutationId: string | null;
  readonly project: IProject | null;
  readonly repository: IRepository | null;
}

interface UnlinkRepositoryFromProjectPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The linked Project.
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;

  /**
   * @description The linked Repository.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UnlinkRepositoryFromProjectPayload: UnlinkRepositoryFromProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The linked Project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description The linked Repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUnlockLockablePayload {
  readonly __typename: "UnlockLockablePayload";
  readonly actor: IActor | null;
  readonly clientMutationId: string | null;
  readonly unlockedRecord: ILockable | null;
}

interface UnlockLockablePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The item that was unlocked.
   */

  readonly unlockedRecord: <T extends Array<Selection>>(
    select: (t: LockableSelector) => T
  ) => Field<"unlockedRecord", never, SelectionSet<T>>;
}

export const UnlockLockablePayload: UnlockLockablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The item that was unlocked.
   */

  unlockedRecord: (select) =>
    new Field(
      "unlockedRecord",
      undefined as never,
      new SelectionSet(select(Lockable))
    ),
};

export interface IUnlockedEvent extends INode {
  readonly __typename: "UnlockedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly lockable: ILockable;
}

interface UnlockedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Object that was unlocked.
   */

  readonly lockable: <T extends Array<Selection>>(
    select: (t: LockableSelector) => T
  ) => Field<"lockable", never, SelectionSet<T>>;
}

export const isUnlockedEvent = (
  object: Record<string, any>
): object is Partial<IUnlockedEvent> => {
  return object.__typename === "UnlockedEvent";
};

export const UnlockedEvent: UnlockedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Object that was unlocked.
   */

  lockable: (select) =>
    new Field(
      "lockable",
      undefined as never,
      new SelectionSet(select(Lockable))
    ),
};

export interface IUnmarkFileAsViewedPayload {
  readonly __typename: "UnmarkFileAsViewedPayload";
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
}

interface UnmarkFileAsViewedPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated pull request.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const UnmarkFileAsViewedPayload: UnmarkFileAsViewedPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated pull request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IUnmarkIssueAsDuplicatePayload {
  readonly __typename: "UnmarkIssueAsDuplicatePayload";
  readonly clientMutationId: string | null;
  readonly duplicate: IIssueOrPullRequest | null;
}

interface UnmarkIssueAsDuplicatePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue or pull request that was marked as a duplicate.
   */

  readonly duplicate: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"duplicate", never, SelectionSet<T>>;
}

export const UnmarkIssueAsDuplicatePayload: UnmarkIssueAsDuplicatePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue or pull request that was marked as a duplicate.
   */

  duplicate: (select) =>
    new Field(
      "duplicate",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),
};

export interface IUnmarkedAsDuplicateEvent extends INode {
  readonly __typename: "UnmarkedAsDuplicateEvent";
  readonly actor: IActor | null;
  readonly canonical: IIssueOrPullRequest | null;
  readonly createdAt: unknown;
  readonly duplicate: IIssueOrPullRequest | null;
  readonly isCrossRepository: boolean;
}

interface UnmarkedAsDuplicateEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The authoritative issue or pull request which has been duplicated by another.
   */

  readonly canonical: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"canonical", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description The issue or pull request which has been marked as a duplicate of another.
   */

  readonly duplicate: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"duplicate", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Canonical and duplicate belong to different repositories.
   */

  readonly isCrossRepository: () => Field<"isCrossRepository">;
}

export const isUnmarkedAsDuplicateEvent = (
  object: Record<string, any>
): object is Partial<IUnmarkedAsDuplicateEvent> => {
  return object.__typename === "UnmarkedAsDuplicateEvent";
};

export const UnmarkedAsDuplicateEvent: UnmarkedAsDuplicateEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The authoritative issue or pull request which has been duplicated by another.
   */

  canonical: (select) =>
    new Field(
      "canonical",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The issue or pull request which has been marked as a duplicate of another.
   */

  duplicate: (select) =>
    new Field(
      "duplicate",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),

  id: () => new Field("id"),

  /**
   * @description Canonical and duplicate belong to different repositories.
   */
  isCrossRepository: () => new Field("isCrossRepository"),
};

export interface IUnminimizeCommentPayload {
  readonly __typename: "UnminimizeCommentPayload";
  readonly clientMutationId: string | null;
  readonly unminimizedComment: IMinimizable | null;
}

interface UnminimizeCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The comment that was unminimized.
   */

  readonly unminimizedComment: <T extends Array<Selection>>(
    select: (t: MinimizableSelector) => T
  ) => Field<"unminimizedComment", never, SelectionSet<T>>;
}

export const UnminimizeCommentPayload: UnminimizeCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The comment that was unminimized.
   */

  unminimizedComment: (select) =>
    new Field(
      "unminimizedComment",
      undefined as never,
      new SelectionSet(select(Minimizable))
    ),
};

export interface IUnpinnedEvent extends INode {
  readonly __typename: "UnpinnedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly issue: IIssue;
}

interface UnpinnedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the issue associated with the event.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const isUnpinnedEvent = (
  object: Record<string, any>
): object is Partial<IUnpinnedEvent> => {
  return object.__typename === "UnpinnedEvent";
};

export const UnpinnedEvent: UnpinnedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IUnresolveReviewThreadPayload {
  readonly __typename: "UnresolveReviewThreadPayload";
  readonly clientMutationId: string | null;
  readonly thread: IPullRequestReviewThread | null;
}

interface UnresolveReviewThreadPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The thread to resolve.
   */

  readonly thread: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"thread", never, SelectionSet<T>>;
}

export const UnresolveReviewThreadPayload: UnresolveReviewThreadPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The thread to resolve.
   */

  thread: (select) =>
    new Field(
      "thread",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),
};

export interface IUnsubscribedEvent extends INode {
  readonly __typename: "UnsubscribedEvent";
  readonly actor: IActor | null;
  readonly createdAt: unknown;
  readonly subscribable: ISubscribable;
}

interface UnsubscribedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description Object referenced by event.
   */

  readonly subscribable: <T extends Array<Selection>>(
    select: (t: SubscribableSelector) => T
  ) => Field<"subscribable", never, SelectionSet<T>>;
}

export const isUnsubscribedEvent = (
  object: Record<string, any>
): object is Partial<IUnsubscribedEvent> => {
  return object.__typename === "UnsubscribedEvent";
};

export const UnsubscribedEvent: UnsubscribedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Object referenced by event.
   */

  subscribable: (select) =>
    new Field(
      "subscribable",
      undefined as never,
      new SelectionSet(select(Subscribable))
    ),
};

export interface IUpdatable {
  readonly __typename: string;
  readonly viewerCanUpdate: boolean;
}

interface UpdatableSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Check if the current viewer can update this object.
   */

  readonly viewerCanUpdate: () => Field<"viewerCanUpdate">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "Issue"
      | "IssueComment"
      | "Project"
      | "PullRequest"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "Project"
        ? ProjectSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Updatable: UpdatableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "Project": {
        return new InlineFragment(
          new NamedType("Project") as any,
          new SelectionSet(select(Project as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "Updatable",
        });
    }
  },
};

export interface IUpdatableComment {
  readonly __typename: string;
  readonly viewerCannotUpdateReasons: ReadonlyArray<CommentCannotUpdateReason>;
}

interface UpdatableCommentSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  readonly viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  readonly on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "Issue"
      | "IssueComment"
      | "PullRequest"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const UpdatableComment: UpdatableCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new TypeConditionError({
          selectedType: type,
          abstractType: "UpdatableComment",
        });
    }
  },
};

export interface IUpdateBranchProtectionRulePayload {
  readonly __typename: "UpdateBranchProtectionRulePayload";
  readonly branchProtectionRule: IBranchProtectionRule | null;
  readonly clientMutationId: string | null;
}

interface UpdateBranchProtectionRulePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The newly created BranchProtectionRule.
   */

  readonly branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const UpdateBranchProtectionRulePayload: UpdateBranchProtectionRulePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The newly created BranchProtectionRule.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IUpdateCheckRunPayload {
  readonly __typename: "UpdateCheckRunPayload";
  readonly checkRun: ICheckRun | null;
  readonly clientMutationId: string | null;
}

interface UpdateCheckRunPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description The updated check run.
   */

  readonly checkRun: <T extends Array<Selection>>(
    select: (t: CheckRunSelector) => T
  ) => Field<"checkRun", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;
}

export const UpdateCheckRunPayload: UpdateCheckRunPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The updated check run.
   */

  checkRun: (select) =>
    new Field(
      "checkRun",
      undefined as never,
      new SelectionSet(select(CheckRun))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IUpdateCheckSuitePreferencesPayload {
  readonly __typename: "UpdateCheckSuitePreferencesPayload";
  readonly clientMutationId: string | null;
  readonly repository: IRepository | null;
}

interface UpdateCheckSuitePreferencesPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated repository.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UpdateCheckSuitePreferencesPayload: UpdateCheckSuitePreferencesPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUpdateEnterpriseAdministratorRolePayload {
  readonly __typename: "UpdateEnterpriseAdministratorRolePayload";
  readonly clientMutationId: string | null;
  readonly message: string | null;
}

interface UpdateEnterpriseAdministratorRolePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description A message confirming the result of changing the administrator's role.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseAdministratorRolePayload: UpdateEnterpriseAdministratorRolePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description A message confirming the result of changing the administrator's role.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload {
  readonly __typename: "UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated allow private repository forking setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the allow private repository forking setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated allow private repository forking setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the allow private repository forking setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseDefaultRepositoryPermissionSettingPayload {
  readonly __typename: "UpdateEnterpriseDefaultRepositoryPermissionSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated default repository permission setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the default repository permission setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated default repository permission setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the default repository permission setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload {
  readonly __typename: "UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can change repository visibility setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can change repository visibility setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can change repository visibility setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can change repository visibility setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload {
  readonly __typename: "UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can create repositories setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can create repositories setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can create repositories setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can create repositories setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanDeleteIssuesSettingPayload {
  readonly __typename: "UpdateEnterpriseMembersCanDeleteIssuesSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can delete issues setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can delete issues setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can delete issues setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can delete issues setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload {
  readonly __typename: "UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can delete repositories setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can delete repositories setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can delete repositories setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can delete repositories setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload {
  readonly __typename: "UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can invite collaborators setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can invite collaborators setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can invite collaborators setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can invite collaborators setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanMakePurchasesSettingPayload {
  readonly __typename: "UpdateEnterpriseMembersCanMakePurchasesSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseMembersCanMakePurchasesSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can make purchases setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can make purchases setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanMakePurchasesSettingPayload: UpdateEnterpriseMembersCanMakePurchasesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can make purchases setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can make purchases setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload {
  readonly __typename: "UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can update protected branches setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can update protected branches setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can update protected branches setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can update protected branches setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload {
  readonly __typename: "UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can view dependency insights setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can view dependency insights setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can view dependency insights setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can view dependency insights setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseOrganizationProjectsSettingPayload {
  readonly __typename: "UpdateEnterpriseOrganizationProjectsSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseOrganizationProjectsSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated organization projects setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the organization projects setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseOrganizationProjectsSettingPayload: UpdateEnterpriseOrganizationProjectsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated organization projects setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the organization projects setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseProfilePayload {
  readonly __typename: "UpdateEnterpriseProfilePayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
}

interface UpdateEnterpriseProfilePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated enterprise.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;
}

export const UpdateEnterpriseProfilePayload: UpdateEnterpriseProfilePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated enterprise.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),
};

export interface IUpdateEnterpriseRepositoryProjectsSettingPayload {
  readonly __typename: "UpdateEnterpriseRepositoryProjectsSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseRepositoryProjectsSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated repository projects setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the repository projects setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseRepositoryProjectsSettingPayload: UpdateEnterpriseRepositoryProjectsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated repository projects setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the repository projects setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseTeamDiscussionsSettingPayload {
  readonly __typename: "UpdateEnterpriseTeamDiscussionsSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseTeamDiscussionsSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated team discussions setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the team discussions setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseTeamDiscussionsSettingPayload: UpdateEnterpriseTeamDiscussionsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated team discussions setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the team discussions setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload {
  readonly __typename: "UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload";
  readonly clientMutationId: string | null;
  readonly enterprise: IEnterprise | null;
  readonly message: string | null;
}

interface UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated two factor authentication required setting.
   */

  readonly enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the two factor authentication required setting.
   */

  readonly message: () => Field<"message">;
}

export const UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated two factor authentication required setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the two factor authentication required setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateIpAllowListEnabledSettingPayload {
  readonly __typename: "UpdateIpAllowListEnabledSettingPayload";
  readonly clientMutationId: string | null;
  readonly owner: IIpAllowListOwner | null;
}

interface UpdateIpAllowListEnabledSettingPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The IP allow list owner on which the setting was updated.
   */

  readonly owner: <T extends Array<Selection>>(
    select: (t: IpAllowListOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;
}

export const UpdateIpAllowListEnabledSettingPayload: UpdateIpAllowListEnabledSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The IP allow list owner on which the setting was updated.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(IpAllowListOwner))
    ),
};

export interface IUpdateIpAllowListEntryPayload {
  readonly __typename: "UpdateIpAllowListEntryPayload";
  readonly clientMutationId: string | null;
  readonly ipAllowListEntry: IIpAllowListEntry | null;
}

interface UpdateIpAllowListEntryPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The IP allow list entry that was updated.
   */

  readonly ipAllowListEntry: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"ipAllowListEntry", never, SelectionSet<T>>;
}

export const UpdateIpAllowListEntryPayload: UpdateIpAllowListEntryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The IP allow list entry that was updated.
   */

  ipAllowListEntry: (select) =>
    new Field(
      "ipAllowListEntry",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),
};

export interface IUpdateIssueCommentPayload {
  readonly __typename: "UpdateIssueCommentPayload";
  readonly clientMutationId: string | null;
  readonly issueComment: IIssueComment | null;
}

interface UpdateIssueCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated comment.
   */

  readonly issueComment: <T extends Array<Selection>>(
    select: (t: IssueCommentSelector) => T
  ) => Field<"issueComment", never, SelectionSet<T>>;
}

export const UpdateIssueCommentPayload: UpdateIssueCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated comment.
   */

  issueComment: (select) =>
    new Field(
      "issueComment",
      undefined as never,
      new SelectionSet(select(IssueComment))
    ),
};

export interface IUpdateIssuePayload {
  readonly __typename: "UpdateIssuePayload";
  readonly actor: IActor | null;
  readonly clientMutationId: string | null;
  readonly issue: IIssue | null;
}

interface UpdateIssuePayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue.
   */

  readonly issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const UpdateIssuePayload: UpdateIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IUpdateProjectCardPayload {
  readonly __typename: "UpdateProjectCardPayload";
  readonly clientMutationId: string | null;
  readonly projectCard: IProjectCard | null;
}

interface UpdateProjectCardPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated ProjectCard.
   */

  readonly projectCard: <T extends Array<Selection>>(
    select: (t: ProjectCardSelector) => T
  ) => Field<"projectCard", never, SelectionSet<T>>;
}

export const UpdateProjectCardPayload: UpdateProjectCardPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated ProjectCard.
   */

  projectCard: (select) =>
    new Field(
      "projectCard",
      undefined as never,
      new SelectionSet(select(ProjectCard))
    ),
};

export interface IUpdateProjectColumnPayload {
  readonly __typename: "UpdateProjectColumnPayload";
  readonly clientMutationId: string | null;
  readonly projectColumn: IProjectColumn | null;
}

interface UpdateProjectColumnPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated project column.
   */

  readonly projectColumn: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"projectColumn", never, SelectionSet<T>>;
}

export const UpdateProjectColumnPayload: UpdateProjectColumnPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated project column.
   */

  projectColumn: (select) =>
    new Field(
      "projectColumn",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),
};

export interface IUpdateProjectPayload {
  readonly __typename: "UpdateProjectPayload";
  readonly clientMutationId: string | null;
  readonly project: IProject | null;
}

interface UpdateProjectPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated project.
   */

  readonly project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const UpdateProjectPayload: UpdateProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface IUpdatePullRequestPayload {
  readonly __typename: "UpdatePullRequestPayload";
  readonly actor: IActor | null;
  readonly clientMutationId: string | null;
  readonly pullRequest: IPullRequest | null;
}

interface UpdatePullRequestPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated pull request.
   */

  readonly pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const UpdatePullRequestPayload: UpdatePullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated pull request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IUpdatePullRequestReviewCommentPayload {
  readonly __typename: "UpdatePullRequestReviewCommentPayload";
  readonly clientMutationId: string | null;
  readonly pullRequestReviewComment: IPullRequestReviewComment | null;
}

interface UpdatePullRequestReviewCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated comment.
   */

  readonly pullRequestReviewComment: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"pullRequestReviewComment", never, SelectionSet<T>>;
}

export const UpdatePullRequestReviewCommentPayload: UpdatePullRequestReviewCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated comment.
   */

  pullRequestReviewComment: (select) =>
    new Field(
      "pullRequestReviewComment",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),
};

export interface IUpdatePullRequestReviewPayload {
  readonly __typename: "UpdatePullRequestReviewPayload";
  readonly clientMutationId: string | null;
  readonly pullRequestReview: IPullRequestReview | null;
}

interface UpdatePullRequestReviewPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated pull request review.
   */

  readonly pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const UpdatePullRequestReviewPayload: UpdatePullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IUpdateRefPayload {
  readonly __typename: "UpdateRefPayload";
  readonly clientMutationId: string | null;
  readonly ref: IRef | null;
}

interface UpdateRefPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated Ref.
   */

  readonly ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const UpdateRefPayload: UpdateRefPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated Ref.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IUpdateRepositoryPayload {
  readonly __typename: "UpdateRepositoryPayload";
  readonly clientMutationId: string | null;
  readonly repository: IRepository | null;
}

interface UpdateRepositoryPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated repository.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UpdateRepositoryPayload: UpdateRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUpdateSubscriptionPayload {
  readonly __typename: "UpdateSubscriptionPayload";
  readonly clientMutationId: string | null;
  readonly subscribable: ISubscribable | null;
}

interface UpdateSubscriptionPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The input subscribable entity.
   */

  readonly subscribable: <T extends Array<Selection>>(
    select: (t: SubscribableSelector) => T
  ) => Field<"subscribable", never, SelectionSet<T>>;
}

export const UpdateSubscriptionPayload: UpdateSubscriptionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The input subscribable entity.
   */

  subscribable: (select) =>
    new Field(
      "subscribable",
      undefined as never,
      new SelectionSet(select(Subscribable))
    ),
};

export interface IUpdateTeamDiscussionCommentPayload {
  readonly __typename: "UpdateTeamDiscussionCommentPayload";
  readonly clientMutationId: string | null;
  readonly teamDiscussionComment: ITeamDiscussionComment | null;
}

interface UpdateTeamDiscussionCommentPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated comment.
   */

  readonly teamDiscussionComment: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentSelector) => T
  ) => Field<"teamDiscussionComment", never, SelectionSet<T>>;
}

export const UpdateTeamDiscussionCommentPayload: UpdateTeamDiscussionCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated comment.
   */

  teamDiscussionComment: (select) =>
    new Field(
      "teamDiscussionComment",
      undefined as never,
      new SelectionSet(select(TeamDiscussionComment))
    ),
};

export interface IUpdateTeamDiscussionPayload {
  readonly __typename: "UpdateTeamDiscussionPayload";
  readonly clientMutationId: string | null;
  readonly teamDiscussion: ITeamDiscussion | null;
}

interface UpdateTeamDiscussionPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated discussion.
   */

  readonly teamDiscussion: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"teamDiscussion", never, SelectionSet<T>>;
}

export const UpdateTeamDiscussionPayload: UpdateTeamDiscussionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated discussion.
   */

  teamDiscussion: (select) =>
    new Field(
      "teamDiscussion",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),
};

export interface IUpdateTopicsPayload {
  readonly __typename: "UpdateTopicsPayload";
  readonly clientMutationId: string | null;
  readonly invalidTopicNames: ReadonlyArray<string> | null;
  readonly repository: IRepository | null;
}

interface UpdateTopicsPayloadSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  readonly clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description Names of the provided topics that are not valid.
   */

  readonly invalidTopicNames: () => Field<"invalidTopicNames">;

  /**
   * @description The updated repository.
   */

  readonly repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UpdateTopicsPayload: UpdateTopicsPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description Names of the provided topics that are not valid.
   */
  invalidTopicNames: () => new Field("invalidTopicNames"),

  /**
   * @description The updated repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUser
  extends IActor,
    INode,
    IPackageOwner,
    IProfileOwner,
    IProjectOwner,
    IRepositoryOwner,
    ISponsorable,
    IUniformResourceLocatable {
  readonly __typename: "User";
  readonly bio: string | null;
  readonly bioHTML: unknown;
  readonly commitComments: ICommitCommentConnection;
  readonly company: string | null;
  readonly companyHTML: unknown;
  readonly contributionsCollection: IContributionsCollection;
  readonly createdAt: unknown;
  readonly databaseId: number | null;
  readonly followers: IFollowerConnection;
  readonly following: IFollowingConnection;
  readonly gist: IGist | null;
  readonly gistComments: IGistCommentConnection;
  readonly gists: IGistConnection;
  readonly hovercard: IHovercard;
  readonly interactionAbility: IRepositoryInteractionAbility | null;
  readonly isBountyHunter: boolean;
  readonly isCampusExpert: boolean;
  readonly isDeveloperProgramMember: boolean;
  readonly isEmployee: boolean;
  readonly isHireable: boolean;
  readonly isSiteAdmin: boolean;
  readonly isViewer: boolean;
  readonly issueComments: IIssueCommentConnection;
  readonly issues: IIssueConnection;
  readonly organization: IOrganization | null;
  readonly organizationVerifiedDomainEmails: ReadonlyArray<string>;
  readonly organizations: IOrganizationConnection;
  readonly publicKeys: IPublicKeyConnection;
  readonly pullRequests: IPullRequestConnection;
  readonly repositoriesContributedTo: IRepositoryConnection;
  readonly savedReplies: ISavedReplyConnection | null;
  readonly starredRepositories: IStarredRepositoryConnection;
  readonly status: IUserStatus | null;
  readonly topRepositories: IRepositoryConnection;
  readonly twitterUsername: string | null;
  readonly updatedAt: unknown;
  readonly viewerCanFollow: boolean;
  readonly viewerIsFollowing: boolean;
  readonly watching: IRepositoryConnection;
}

interface UserSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */

  readonly anyPinnableItems: (variables: {
    type?: Variable<"type"> | PinnableItemType;
  }) => Field<
    "anyPinnableItems",
    [Argument<"type", Variable<"type"> | PinnableItemType>]
  >;

  /**
   * @description A URL pointing to the user's public avatar.
   */

  readonly avatarUrl: (variables: {
    size?: Variable<"size"> | number;
  }) => Field<"avatarUrl", [Argument<"size", Variable<"size"> | number>]>;

  /**
   * @description The user's public profile bio.
   */

  readonly bio: () => Field<"bio">;

  /**
   * @description The user's public profile bio as HTML.
   */

  readonly bioHTML: () => Field<"bioHTML">;

  /**
   * @description A list of commit comments made by this user.
   */

  readonly commitComments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "commitComments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The user's public profile company.
   */

  readonly company: () => Field<"company">;

  /**
   * @description The user's public profile company as HTML.
   */

  readonly companyHTML: () => Field<"companyHTML">;

  /**
   * @description The collection of contributions this user has made to different repositories.
   */

  readonly contributionsCollection: <T extends Array<Selection>>(
    variables: {
      from?: Variable<"from"> | unknown;
      organizationID?: Variable<"organizationID"> | string;
      to?: Variable<"to"> | unknown;
    },
    select: (t: ContributionsCollectionSelector) => T
  ) => Field<
    "contributionsCollection",
    [
      Argument<"from", Variable<"from"> | unknown>,
      Argument<"organizationID", Variable<"organizationID"> | string>,
      Argument<"to", Variable<"to"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  readonly databaseId: () => Field<"databaseId">;

  /**
   * @description The user's publicly visible profile email.
   */

  readonly email: () => Field<"email">;

  /**
   * @description A list of users the given user is followed by.
   */

  readonly followers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: FollowerConnectionSelector) => T
  ) => Field<
    "followers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users the given user is following.
   */

  readonly following: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: FollowingConnectionSelector) => T
  ) => Field<
    "following",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find gist by repo name.
   */

  readonly gist: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: GistSelector) => T
  ) => Field<
    "gist",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description A list of gist comments made by this user.
   */

  readonly gistComments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: GistCommentConnectionSelector) => T
  ) => Field<
    "gistComments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of the Gists the user has created.
   */

  readonly gists: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | GistOrder;
      privacy?: Variable<"privacy"> | GistPrivacy;
    },
    select: (t: GistConnectionSelector) => T
  ) => Field<
    "gists",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | GistOrder>,
      Argument<"privacy", Variable<"privacy"> | GistPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */

  readonly hasSponsorsListing: () => Field<"hasSponsorsListing">;

  /**
   * @description The hovercard information for this user in a given context
   */

  readonly hovercard: <T extends Array<Selection>>(
    variables: { primarySubjectId?: Variable<"primarySubjectId"> | string },
    select: (t: HovercardSelector) => T
  ) => Field<
    "hovercard",
    [Argument<"primarySubjectId", Variable<"primarySubjectId"> | string>],
    SelectionSet<T>
  >;

  readonly id: () => Field<"id">;

  /**
   * @description The interaction ability settings for this user.
   */

  readonly interactionAbility: <T extends Array<Selection>>(
    select: (t: RepositoryInteractionAbilitySelector) => T
  ) => Field<"interactionAbility", never, SelectionSet<T>>;

  /**
   * @description Whether or not this user is a participant in the GitHub Security Bug Bounty.
   */

  readonly isBountyHunter: () => Field<"isBountyHunter">;

  /**
   * @description Whether or not this user is a participant in the GitHub Campus Experts Program.
   */

  readonly isCampusExpert: () => Field<"isCampusExpert">;

  /**
   * @description Whether or not this user is a GitHub Developer Program member.
   */

  readonly isDeveloperProgramMember: () => Field<"isDeveloperProgramMember">;

  /**
   * @description Whether or not this user is a GitHub employee.
   */

  readonly isEmployee: () => Field<"isEmployee">;

  /**
   * @description Whether or not the user has marked themselves as for hire.
   */

  readonly isHireable: () => Field<"isHireable">;

  /**
   * @description Whether or not this user is a site administrator.
   */

  readonly isSiteAdmin: () => Field<"isSiteAdmin">;

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */

  readonly isSponsoringViewer: () => Field<"isSponsoringViewer">;

  /**
   * @description Whether or not this user is the viewing user.
   */

  readonly isViewer: () => Field<"isViewer">;

  /**
   * @description A list of issue comments made by this user.
   */

  readonly issueComments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueCommentOrder;
    },
    select: (t: IssueCommentConnectionSelector) => T
  ) => Field<
    "issueComments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueCommentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of issues associated with this user.
   */

  readonly issues: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | IssueFilters;
      first?: Variable<"first"> | number;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | IssueState;
    },
    select: (t: IssueConnectionSelector) => T
  ) => Field<
    "issues",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | IssueFilters>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | IssueState>
    ],
    SelectionSet<T>
  >;

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  readonly itemShowcase: <T extends Array<Selection>>(
    select: (t: ProfileItemShowcaseSelector) => T
  ) => Field<"itemShowcase", never, SelectionSet<T>>;

  /**
   * @description The user's public profile location.
   */

  readonly location: () => Field<"location">;

  /**
   * @description The username used to login.
   */

  readonly login: () => Field<"login">;

  /**
   * @description The user's public profile name.
   */

  readonly name: () => Field<"name">;

  /**
   * @description Find an organization by its login that the user belongs to.
   */

  readonly organization: <T extends Array<Selection>>(
    variables: { login?: Variable<"login"> | string },
    select: (t: OrganizationSelector) => T
  ) => Field<
    "organization",
    [Argument<"login", Variable<"login"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Verified email addresses that match verified domains for a specified organization the user is a member of.
   */

  readonly organizationVerifiedDomainEmails: (variables: {
    login?: Variable<"login"> | string;
  }) => Field<
    "organizationVerifiedDomainEmails",
    [Argument<"login", Variable<"login"> | string>]
  >;

  /**
   * @description A list of organizations the user belongs to.
   */

  readonly organizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "organizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of packages under the owner.
   */

  readonly packages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      names?: Variable<"names"> | string;
      orderBy?: Variable<"orderBy"> | PackageOrder;
      packageType?: Variable<"packageType"> | PackageType;
      repositoryId?: Variable<"repositoryId"> | string;
    },
    select: (t: PackageConnectionSelector) => T
  ) => Field<
    "packages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"names", Variable<"names"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | PackageOrder>,
      Argument<"packageType", Variable<"packageType"> | PackageType>,
      Argument<"repositoryId", Variable<"repositoryId"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  readonly pinnableItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnableItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  readonly pinnedItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnedItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */

  readonly pinnedItemsRemaining: () => Field<"pinnedItemsRemaining">;

  /**
   * @description Find project by number.
   */

  readonly project: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: ProjectSelector) => T
  ) => Field<
    "project",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of projects under the owner.
   */

  readonly projects: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ProjectOrder;
      search?: Variable<"search"> | string;
      states?: Variable<"states"> | ProjectState;
    },
    select: (t: ProjectConnectionSelector) => T
  ) => Field<
    "projects",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ProjectOrder>,
      Argument<"search", Variable<"search"> | string>,
      Argument<"states", Variable<"states"> | ProjectState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing user's projects
   */

  readonly projectsResourcePath: () => Field<"projectsResourcePath">;

  /**
   * @description The HTTP URL listing user's projects
   */

  readonly projectsUrl: () => Field<"projectsUrl">;

  /**
   * @description A list of public keys associated with this user.
   */

  readonly publicKeys: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PublicKeyConnectionSelector) => T
  ) => Field<
    "publicKeys",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pull requests associated with this user.
   */

  readonly pullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "pullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories that the user owns.
   */

  readonly repositories: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isFork?: Variable<"isFork"> | boolean;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isFork", Variable<"isFork"> | boolean>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories that the user recently contributed to.
   */

  readonly repositoriesContributedTo: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      contributionTypes?:
        | Variable<"contributionTypes">
        | RepositoryContributionType;
      first?: Variable<"first"> | number;
      includeUserRepositories?: Variable<"includeUserRepositories"> | boolean;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "repositoriesContributedTo",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<
        "contributionTypes",
        Variable<"contributionTypes"> | RepositoryContributionType
      >,
      Argument<"first", Variable<"first"> | number>,
      Argument<
        "includeUserRepositories",
        Variable<"includeUserRepositories"> | boolean
      >,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find Repository.
   */

  readonly repository: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: RepositorySelector) => T
  ) => Field<
    "repository",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this user
   */

  readonly resourcePath: () => Field<"resourcePath">;

  /**
   * @description Replies this user has saved
   */

  readonly savedReplies: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SavedReplyOrder;
    },
    select: (t: SavedReplyConnectionSelector) => T
  ) => Field<
    "savedReplies",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SavedReplyOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  readonly sponsorsListing: <T extends Array<Selection>>(
    select: (t: SponsorsListingSelector) => T
  ) => Field<"sponsorsListing", never, SelectionSet<T>>;

  /**
   * @description This object's sponsorships as the maintainer.
   */

  readonly sponsorshipsAsMaintainer: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      includePrivate?: Variable<"includePrivate"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsMaintainer",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"includePrivate", Variable<"includePrivate"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description This object's sponsorships as the sponsor.
   */

  readonly sponsorshipsAsSponsor: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsSponsor",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Repositories the user has starred.
   */

  readonly starredRepositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
      ownedByViewer?: Variable<"ownedByViewer"> | boolean;
    },
    select: (t: StarredRepositoryConnectionSelector) => T
  ) => Field<
    "starredRepositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>,
      Argument<"ownedByViewer", Variable<"ownedByViewer"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The user's description of what they're currently doing.
   */

  readonly status: <T extends Array<Selection>>(
    select: (t: UserStatusSelector) => T
  ) => Field<"status", never, SelectionSet<T>>;

  /**
   * @description Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created
   */

  readonly topRepositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      since?: Variable<"since"> | unknown;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "topRepositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<"since", Variable<"since"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The user's Twitter username.
   */

  readonly twitterUsername: () => Field<"twitterUsername">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this user
   */

  readonly url: () => Field<"url">;

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */

  readonly viewerCanChangePinnedItems: () => Field<"viewerCanChangePinnedItems">;

  /**
   * @description Can the current viewer create new projects on this owner.
   */

  readonly viewerCanCreateProjects: () => Field<"viewerCanCreateProjects">;

  /**
   * @description Whether or not the viewer is able to follow the user.
   */

  readonly viewerCanFollow: () => Field<"viewerCanFollow">;

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */

  readonly viewerCanSponsor: () => Field<"viewerCanSponsor">;

  /**
   * @description Whether or not this user is followed by the viewer.
   */

  readonly viewerIsFollowing: () => Field<"viewerIsFollowing">;

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */

  readonly viewerIsSponsoring: () => Field<"viewerIsSponsoring">;

  /**
   * @description A list of repositories the given user is watching.
   */

  readonly watching: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "watching",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A URL pointing to the user's public website/blog.
   */

  readonly websiteUrl: () => Field<"websiteUrl">;
}

export const isUser = (
  object: Record<string, any>
): object is Partial<IUser> => {
  return object.__typename === "User";
};

export const User: UserSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */
  anyPinnableItems: (variables) => new Field("anyPinnableItems"),

  /**
   * @description A URL pointing to the user's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description The user's public profile bio.
   */
  bio: () => new Field("bio"),

  /**
   * @description The user's public profile bio as HTML.
   */
  bioHTML: () => new Field("bioHTML"),

  /**
   * @description A list of commit comments made by this user.
   */

  commitComments: (variables, select) =>
    new Field(
      "commitComments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description The user's public profile company.
   */
  company: () => new Field("company"),

  /**
   * @description The user's public profile company as HTML.
   */
  companyHTML: () => new Field("companyHTML"),

  /**
   * @description The collection of contributions this user has made to different repositories.
   */

  contributionsCollection: (variables, select) =>
    new Field(
      "contributionsCollection",
      [
        new Argument("from", variables.from),
        new Argument("organizationID", variables.organizationID),
        new Argument("to", variables.to),
      ],
      new SelectionSet(select(ContributionsCollection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The user's publicly visible profile email.
   */
  email: () => new Field("email"),

  /**
   * @description A list of users the given user is followed by.
   */

  followers: (variables, select) =>
    new Field(
      "followers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(FollowerConnection))
    ),

  /**
   * @description A list of users the given user is following.
   */

  following: (variables, select) =>
    new Field(
      "following",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(FollowingConnection))
    ),

  /**
   * @description Find gist by repo name.
   */

  gist: (variables, select) =>
    new Field(
      "gist",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Gist))
    ),

  /**
   * @description A list of gist comments made by this user.
   */

  gistComments: (variables, select) =>
    new Field(
      "gistComments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(GistCommentConnection))
    ),

  /**
   * @description A list of the Gists the user has created.
   */

  gists: (variables, select) =>
    new Field(
      "gists",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("privacy", variables.privacy, GistPrivacy),
      ],
      new SelectionSet(select(GistConnection))
    ),

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */
  hasSponsorsListing: () => new Field("hasSponsorsListing"),

  /**
   * @description The hovercard information for this user in a given context
   */

  hovercard: (variables, select) =>
    new Field(
      "hovercard",
      [new Argument("primarySubjectId", variables.primarySubjectId)],
      new SelectionSet(select(Hovercard))
    ),

  id: () => new Field("id"),

  /**
   * @description The interaction ability settings for this user.
   */

  interactionAbility: (select) =>
    new Field(
      "interactionAbility",
      undefined as never,
      new SelectionSet(select(RepositoryInteractionAbility))
    ),

  /**
   * @description Whether or not this user is a participant in the GitHub Security Bug Bounty.
   */
  isBountyHunter: () => new Field("isBountyHunter"),

  /**
   * @description Whether or not this user is a participant in the GitHub Campus Experts Program.
   */
  isCampusExpert: () => new Field("isCampusExpert"),

  /**
   * @description Whether or not this user is a GitHub Developer Program member.
   */
  isDeveloperProgramMember: () => new Field("isDeveloperProgramMember"),

  /**
   * @description Whether or not this user is a GitHub employee.
   */
  isEmployee: () => new Field("isEmployee"),

  /**
   * @description Whether or not the user has marked themselves as for hire.
   */
  isHireable: () => new Field("isHireable"),

  /**
   * @description Whether or not this user is a site administrator.
   */
  isSiteAdmin: () => new Field("isSiteAdmin"),

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */
  isSponsoringViewer: () => new Field("isSponsoringViewer"),

  /**
   * @description Whether or not this user is the viewing user.
   */
  isViewer: () => new Field("isViewer"),

  /**
   * @description A list of issue comments made by this user.
   */

  issueComments: (variables, select) =>
    new Field(
      "issueComments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IssueCommentConnection))
    ),

  /**
   * @description A list of issues associated with this user.
   */

  issues: (variables, select) =>
    new Field(
      "issues",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, IssueState),
      ],
      new SelectionSet(select(IssueConnection))
    ),

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: (select) =>
    new Field(
      "itemShowcase",
      undefined as never,
      new SelectionSet(select(ProfileItemShowcase))
    ),

  /**
   * @description The user's public profile location.
   */
  location: () => new Field("location"),

  /**
   * @description The username used to login.
   */
  login: () => new Field("login"),

  /**
   * @description The user's public profile name.
   */
  name: () => new Field("name"),

  /**
   * @description Find an organization by its login that the user belongs to.
   */

  organization: (variables, select) =>
    new Field(
      "organization",
      [new Argument("login", variables.login)],
      new SelectionSet(select(Organization))
    ),

  /**
   * @description Verified email addresses that match verified domains for a specified organization the user is a member of.
   */
  organizationVerifiedDomainEmails: (variables) =>
    new Field("organizationVerifiedDomainEmails"),

  /**
   * @description A list of organizations the user belongs to.
   */

  organizations: (variables, select) =>
    new Field(
      "organizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description A list of packages under the owner.
   */

  packages: (variables, select) =>
    new Field(
      "packages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("names", variables.names),
        new Argument("orderBy", variables.orderBy),
        new Argument("packageType", variables.packageType, PackageType),
        new Argument("repositoryId", variables.repositoryId),
      ],
      new SelectionSet(select(PackageConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: (variables, select) =>
    new Field(
      "pinnableItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: (variables, select) =>
    new Field(
      "pinnedItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */
  pinnedItemsRemaining: () => new Field("pinnedItemsRemaining"),

  /**
   * @description Find project by number.
   */

  project: (variables, select) =>
    new Field(
      "project",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Project))
    ),

  /**
   * @description A list of projects under the owner.
   */

  projects: (variables, select) =>
    new Field(
      "projects",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("search", variables.search),
        new Argument("states", variables.states, ProjectState),
      ],
      new SelectionSet(select(ProjectConnection))
    ),

  /**
   * @description The HTTP path listing user's projects
   */
  projectsResourcePath: () => new Field("projectsResourcePath"),

  /**
   * @description The HTTP URL listing user's projects
   */
  projectsUrl: () => new Field("projectsUrl"),

  /**
   * @description A list of public keys associated with this user.
   */

  publicKeys: (variables, select) =>
    new Field(
      "publicKeys",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PublicKeyConnection))
    ),

  /**
   * @description A list of pull requests associated with this user.
   */

  pullRequests: (variables, select) =>
    new Field(
      "pullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isFork", variables.isFork),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description A list of repositories that the user recently contributed to.
   */

  repositoriesContributedTo: (variables, select) =>
    new Field(
      "repositoriesContributedTo",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument(
          "contributionTypes",
          variables.contributionTypes,
          RepositoryContributionType
        ),
        new Argument("first", variables.first),
        new Argument(
          "includeUserRepositories",
          variables.includeUserRepositories
        ),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description Find Repository.
   */

  repository: (variables, select) =>
    new Field(
      "repository",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this user
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Replies this user has saved
   */

  savedReplies: (variables, select) =>
    new Field(
      "savedReplies",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SavedReplyConnection))
    ),

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: (select) =>
    new Field(
      "sponsorsListing",
      undefined as never,
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: (variables, select) =>
    new Field(
      "sponsorshipsAsMaintainer",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("includePrivate", variables.includePrivate),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: (variables, select) =>
    new Field(
      "sponsorshipsAsSponsor",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description Repositories the user has starred.
   */

  starredRepositories: (variables, select) =>
    new Field(
      "starredRepositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("ownedByViewer", variables.ownedByViewer),
      ],
      new SelectionSet(select(StarredRepositoryConnection))
    ),

  /**
   * @description The user's description of what they're currently doing.
   */

  status: (select) =>
    new Field(
      "status",
      undefined as never,
      new SelectionSet(select(UserStatus))
    ),

  /**
   * @description Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created
   */

  topRepositories: (variables, select) =>
    new Field(
      "topRepositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("since", variables.since),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description The user's Twitter username.
   */
  twitterUsername: () => new Field("twitterUsername"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this user
   */
  url: () => new Field("url"),

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */
  viewerCanChangePinnedItems: () => new Field("viewerCanChangePinnedItems"),

  /**
   * @description Can the current viewer create new projects on this owner.
   */
  viewerCanCreateProjects: () => new Field("viewerCanCreateProjects"),

  /**
   * @description Whether or not the viewer is able to follow the user.
   */
  viewerCanFollow: () => new Field("viewerCanFollow"),

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */
  viewerCanSponsor: () => new Field("viewerCanSponsor"),

  /**
   * @description Whether or not this user is followed by the viewer.
   */
  viewerIsFollowing: () => new Field("viewerIsFollowing"),

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */
  viewerIsSponsoring: () => new Field("viewerIsSponsoring"),

  /**
   * @description A list of repositories the given user is watching.
   */

  watching: (variables, select) =>
    new Field(
      "watching",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description A URL pointing to the user's public website/blog.
   */
  websiteUrl: () => new Field("websiteUrl"),
};

export interface IUserBlockedEvent extends INode {
  readonly __typename: "UserBlockedEvent";
  readonly actor: IActor | null;
  readonly blockDuration: UserBlockDuration;
  readonly createdAt: unknown;
  readonly subject: IUser | null;
}

interface UserBlockedEventSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  readonly actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Number of days that the user was blocked for.
   */

  readonly blockDuration: () => Field<"blockDuration">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  readonly id: () => Field<"id">;

  /**
   * @description The user who was blocked.
   */

  readonly subject: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isUserBlockedEvent = (
  object: Record<string, any>
): object is Partial<IUserBlockedEvent> => {
  return object.__typename === "UserBlockedEvent";
};

export const UserBlockedEvent: UserBlockedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Number of days that the user was blocked for.
   */
  blockDuration: () => new Field("blockDuration"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The user who was blocked.
   */

  subject: (select) =>
    new Field("subject", undefined as never, new SelectionSet(select(User))),
};

export interface IUserConnection {
  readonly __typename: "UserConnection";
  readonly edges: ReadonlyArray<IUserEdge> | null;
  readonly nodes: ReadonlyArray<IUser> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface UserConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: UserEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const UserConnection: UserConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(UserEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IUserContentEdit extends INode {
  readonly __typename: "UserContentEdit";
  readonly createdAt: unknown;
  readonly deletedAt: unknown | null;
  readonly deletedBy: IActor | null;
  readonly diff: string | null;
  readonly editedAt: unknown;
  readonly editor: IActor | null;
  readonly updatedAt: unknown;
}

interface UserContentEditSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the date and time when the object was deleted.
   */

  readonly deletedAt: () => Field<"deletedAt">;

  /**
   * @description The actor who deleted this content
   */

  readonly deletedBy: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"deletedBy", never, SelectionSet<T>>;

  /**
   * @description A summary of the changes for this edit
   */

  readonly diff: () => Field<"diff">;

  /**
   * @description When this content was edited
   */

  readonly editedAt: () => Field<"editedAt">;

  /**
   * @description The actor who edited this content
   */

  readonly editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  readonly id: () => Field<"id">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;
}

export const isUserContentEdit = (
  object: Record<string, any>
): object is Partial<IUserContentEdit> => {
  return object.__typename === "UserContentEdit";
};

export const UserContentEdit: UserContentEditSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the date and time when the object was deleted.
   */
  deletedAt: () => new Field("deletedAt"),

  /**
   * @description The actor who deleted this content
   */

  deletedBy: (select) =>
    new Field("deletedBy", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A summary of the changes for this edit
   */
  diff: () => new Field("diff"),

  /**
   * @description When this content was edited
   */
  editedAt: () => new Field("editedAt"),

  /**
   * @description The actor who edited this content
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IUserContentEditConnection {
  readonly __typename: "UserContentEditConnection";
  readonly edges: ReadonlyArray<IUserContentEditEdge> | null;
  readonly nodes: ReadonlyArray<IUserContentEdit> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface UserContentEditConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: UserContentEditEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserContentEditSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const UserContentEditConnection: UserContentEditConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(UserContentEditEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(UserContentEdit))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IUserContentEditEdge {
  readonly __typename: "UserContentEditEdge";
  readonly cursor: string;
  readonly node: IUserContentEdit | null;
}

interface UserContentEditEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: UserContentEditSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const UserContentEditEdge: UserContentEditEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(UserContentEdit))
    ),
};

export interface IUserEdge {
  readonly __typename: "UserEdge";
  readonly cursor: string;
  readonly node: IUser | null;
}

interface UserEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const UserEdge: UserEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),
};

export interface IUserEmailMetadata {
  readonly __typename: "UserEmailMetadata";
  readonly primary: boolean | null;
  readonly type: string | null;
  readonly value: string;
}

interface UserEmailMetadataSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Boolean to identify primary emails
   */

  readonly primary: () => Field<"primary">;

  /**
   * @description Type of email
   */

  readonly type: () => Field<"type">;

  /**
   * @description Email id
   */

  readonly value: () => Field<"value">;
}

export const UserEmailMetadata: UserEmailMetadataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Boolean to identify primary emails
   */
  primary: () => new Field("primary"),

  /**
   * @description Type of email
   */
  type: () => new Field("type"),

  /**
   * @description Email id
   */
  value: () => new Field("value"),
};

export interface IUserStatus extends INode {
  readonly __typename: "UserStatus";
  readonly createdAt: unknown;
  readonly emoji: string | null;
  readonly emojiHTML: unknown | null;
  readonly expiresAt: unknown | null;
  readonly indicatesLimitedAvailability: boolean;
  readonly message: string | null;
  readonly organization: IOrganization | null;
  readonly updatedAt: unknown;
  readonly user: IUser;
}

interface UserStatusSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  readonly createdAt: () => Field<"createdAt">;

  /**
   * @description An emoji summarizing the user's status.
   */

  readonly emoji: () => Field<"emoji">;

  /**
   * @description The status emoji as HTML.
   */

  readonly emojiHTML: () => Field<"emojiHTML">;

  /**
   * @description If set, the status will not be shown after this date.
   */

  readonly expiresAt: () => Field<"expiresAt">;

  /**
   * @description ID of the object.
   */

  readonly id: () => Field<"id">;

  /**
   * @description Whether this status indicates the user is not fully available on GitHub.
   */

  readonly indicatesLimitedAvailability: () => Field<"indicatesLimitedAvailability">;

  /**
   * @description A brief message describing what the user is doing.
   */

  readonly message: () => Field<"message">;

  /**
   * @description The organization whose members can see this status. If null, this status is publicly visible.
   */

  readonly organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  readonly updatedAt: () => Field<"updatedAt">;

  /**
   * @description The user who has this status.
   */

  readonly user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isUserStatus = (
  object: Record<string, any>
): object is Partial<IUserStatus> => {
  return object.__typename === "UserStatus";
};

export const UserStatus: UserStatusSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description An emoji summarizing the user's status.
   */
  emoji: () => new Field("emoji"),

  /**
   * @description The status emoji as HTML.
   */
  emojiHTML: () => new Field("emojiHTML"),

  /**
   * @description If set, the status will not be shown after this date.
   */
  expiresAt: () => new Field("expiresAt"),

  /**
   * @description ID of the object.
   */
  id: () => new Field("id"),

  /**
   * @description Whether this status indicates the user is not fully available on GitHub.
   */
  indicatesLimitedAvailability: () => new Field("indicatesLimitedAvailability"),

  /**
   * @description A brief message describing what the user is doing.
   */
  message: () => new Field("message"),

  /**
   * @description The organization whose members can see this status. If null, this status is publicly visible.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The user who has this status.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IUserStatusConnection {
  readonly __typename: "UserStatusConnection";
  readonly edges: ReadonlyArray<IUserStatusEdge> | null;
  readonly nodes: ReadonlyArray<IUserStatus> | null;
  readonly pageInfo: IPageInfo;
  readonly totalCount: number;
}

interface UserStatusConnectionSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  readonly edges: <T extends Array<Selection>>(
    select: (t: UserStatusEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  readonly nodes: <T extends Array<Selection>>(
    select: (t: UserStatusSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  readonly pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  readonly totalCount: () => Field<"totalCount">;
}

export const UserStatusConnection: UserStatusConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(UserStatusEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(UserStatus))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IUserStatusEdge {
  readonly __typename: "UserStatusEdge";
  readonly cursor: string;
  readonly node: IUserStatus | null;
}

interface UserStatusEdgeSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  readonly cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  readonly node: <T extends Array<Selection>>(
    select: (t: UserStatusSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const UserStatusEdge: UserStatusEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(UserStatus))),
};

export interface IViewerHovercardContext extends IHovercardContext {
  readonly __typename: "ViewerHovercardContext";
  readonly viewer: IUser;
}

interface ViewerHovercardContextSelector {
  readonly __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  readonly message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  readonly octicon: () => Field<"octicon">;

  /**
   * @description Identifies the user who is related to this context.
   */

  readonly viewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"viewer", never, SelectionSet<T>>;
}

export const isViewerHovercardContext = (
  object: Record<string, any>
): object is Partial<IViewerHovercardContext> => {
  return object.__typename === "ViewerHovercardContext";
};

export const ViewerHovercardContext: ViewerHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  /**
   * @description Identifies the user who is related to this context.
   */

  viewer: (select) =>
    new Field("viewer", undefined as never, new SelectionSet(select(User))),
};

export const query = <T extends Array<Selection>>(
  name: string,
  select: (t: typeof Query) => T
): Operation<SelectionSet<T>> =>
  new Operation(name, "query", new SelectionSet(select(Query)));

export const mutation = <T extends Array<Selection>>(
  name: string,
  select: (t: typeof Mutation) => T
): Operation<SelectionSet<T>> =>
  new Operation(name, "mutation", new SelectionSet(select(Mutation)));

export class GitHub implements Client {
  public static readonly VERSION = VERSION;
  public static readonly SCHEMA_SHA = SCHEMA_SHA;

  constructor(public readonly executor: Executor) {}

  public readonly query = {
    /**
     * @description Look up a code of conduct by its key
     */

    codeOfConduct: <T extends Array<Selection>>(
      variables: { key?: string },
      select: (t: CodeOfConductSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"codeOfConduct", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "codeOfConduct",
          "query",
          new SelectionSet([Query.codeOfConduct<T>(variables, select)])
        )
      ),

    /**
     * @description Look up a code of conduct by its key
     */

    codesOfConduct: <T extends Array<Selection>>(
      select: (t: CodeOfConductSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"codesOfConduct", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "codesOfConduct",
          "query",
          new SelectionSet([Query.codesOfConduct<T>(select)])
        )
      ),

    /**
     * @description Look up an enterprise by URL slug.
     */

    enterprise: <T extends Array<Selection>>(
      variables: { invitationToken?: string; slug?: string },
      select: (t: EnterpriseSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"enterprise", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "enterprise",
          "query",
          new SelectionSet([Query.enterprise<T>(variables, select)])
        )
      ),

    /**
     * @description Look up a pending enterprise administrator invitation by invitee, enterprise and role.
     */

    enterpriseAdministratorInvitation: <T extends Array<Selection>>(
      variables: {
        enterpriseSlug?: string;
        role?: EnterpriseAdministratorRole;
        userLogin?: string;
      },
      select: (t: EnterpriseAdministratorInvitationSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<
            [Field<"enterpriseAdministratorInvitation", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "enterpriseAdministratorInvitation",
          "query",
          new SelectionSet([
            Query.enterpriseAdministratorInvitation<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Look up a pending enterprise administrator invitation by invitation token.
     */

    enterpriseAdministratorInvitationByToken: <T extends Array<Selection>>(
      variables: { invitationToken?: string },
      select: (t: EnterpriseAdministratorInvitationSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<
            [
              Field<
                "enterpriseAdministratorInvitationByToken",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "enterpriseAdministratorInvitationByToken",
          "query",
          new SelectionSet([
            Query.enterpriseAdministratorInvitationByToken<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Look up an open source license by its key
     */

    license: <T extends Array<Selection>>(
      variables: { key?: string },
      select: (t: LicenseSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"license", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "license",
          "query",
          new SelectionSet([Query.license<T>(variables, select)])
        )
      ),

    /**
     * @description Return a list of known open source licenses
     */

    licenses: <T extends Array<Selection>>(select: (t: LicenseSelector) => T) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"licenses", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "licenses",
          "query",
          new SelectionSet([Query.licenses<T>(select)])
        )
      ),

    /**
     * @description Get alphabetically sorted list of Marketplace categories
     */

    marketplaceCategories: <T extends Array<Selection>>(
      variables: {
        excludeEmpty?: boolean;
        excludeSubcategories?: boolean;
        includeCategories?: string;
      },
      select: (t: MarketplaceCategorySelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"marketplaceCategories", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "marketplaceCategories",
          "query",
          new SelectionSet([Query.marketplaceCategories<T>(variables, select)])
        )
      ),

    /**
     * @description Look up a Marketplace category by its slug.
     */

    marketplaceCategory: <T extends Array<Selection>>(
      variables: { slug?: string; useTopicAliases?: boolean },
      select: (t: MarketplaceCategorySelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"marketplaceCategory", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "marketplaceCategory",
          "query",
          new SelectionSet([Query.marketplaceCategory<T>(variables, select)])
        )
      ),

    /**
     * @description Look up a single Marketplace listing
     */

    marketplaceListing: <T extends Array<Selection>>(
      variables: { slug?: string },
      select: (t: MarketplaceListingSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"marketplaceListing", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "marketplaceListing",
          "query",
          new SelectionSet([Query.marketplaceListing<T>(variables, select)])
        )
      ),

    /**
     * @description Look up Marketplace listings
     */

    marketplaceListings: <T extends Array<Selection>>(
      variables: {
        adminId?: string;
        after?: string;
        allStates?: boolean;
        before?: string;
        categorySlug?: string;
        first?: number;
        last?: number;
        organizationId?: string;
        primaryCategoryOnly?: boolean;
        slugs?: string;
        useTopicAliases?: boolean;
        viewerCanAdmin?: boolean;
        withFreeTrialsOnly?: boolean;
      },
      select: (t: MarketplaceListingConnectionSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"marketplaceListings", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "marketplaceListings",
          "query",
          new SelectionSet([Query.marketplaceListings<T>(variables, select)])
        )
      ),

    /**
     * @description Return information about the GitHub instance
     */

    meta: <T extends Array<Selection>>(
      select: (t: GitHubMetadataSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"meta", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "meta",
          "query",
          new SelectionSet([Query.meta<T>(select)])
        )
      ),

    /**
     * @description Fetches an object given its ID.
     */

    node: <T extends Array<Selection>>(
      variables: { id?: string },
      select: (t: NodeSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"node", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "node",
          "query",
          new SelectionSet([Query.node<T>(variables, select)])
        )
      ),

    /**
     * @description Lookup nodes by a list of IDs.
     */

    nodes: <T extends Array<Selection>>(
      variables: { ids?: string },
      select: (t: NodeSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"nodes", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "nodes",
          "query",
          new SelectionSet([Query.nodes<T>(variables, select)])
        )
      ),

    /**
     * @description Lookup a organization by login.
     */

    organization: <T extends Array<Selection>>(
      variables: { login?: string },
      select: (t: OrganizationSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"organization", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "organization",
          "query",
          new SelectionSet([Query.organization<T>(variables, select)])
        )
      ),

    /**
     * @description The client's rate limit information.
     */

    rateLimit: <T extends Array<Selection>>(
      variables: { dryRun?: boolean },
      select: (t: RateLimitSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"rateLimit", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "rateLimit",
          "query",
          new SelectionSet([Query.rateLimit<T>(variables, select)])
        )
      ),

    /**
     * @description Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object
     */

    relay: <T extends Array<Selection>>(select: (t: QuerySelector) => T) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"relay", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "relay",
          "query",
          new SelectionSet([Query.relay<T>(select)])
        )
      ),

    /**
     * @description Lookup a given repository by the owner and repository name.
     */

    repository: <T extends Array<Selection>>(
      variables: { name?: string; owner?: string },
      select: (t: RepositorySelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"repository", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "repository",
          "query",
          new SelectionSet([Query.repository<T>(variables, select)])
        )
      ),

    /**
     * @description Lookup a repository owner (ie. either a User or an Organization) by login.
     */

    repositoryOwner: <T extends Array<Selection>>(
      variables: { login?: string },
      select: (t: RepositoryOwnerSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"repositoryOwner", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "repositoryOwner",
          "query",
          new SelectionSet([Query.repositoryOwner<T>(variables, select)])
        )
      ),

    /**
     * @description Lookup resource by a URL.
     */

    resource: <T extends Array<Selection>>(
      variables: { url?: unknown },
      select: (t: UniformResourceLocatableSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"resource", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "resource",
          "query",
          new SelectionSet([Query.resource<T>(variables, select)])
        )
      ),

    /**
     * @description Perform a search across resources.
     */

    search: <T extends Array<Selection>>(
      variables: {
        after?: string;
        before?: string;
        first?: number;
        last?: number;
        query?: string;
        type?: SearchType;
      },
      select: (t: SearchResultItemConnectionSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"search", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "search",
          "query",
          new SelectionSet([Query.search<T>(variables, select)])
        )
      ),

    /**
     * @description GitHub Security Advisories
     */

    securityAdvisories: <T extends Array<Selection>>(
      variables: {
        after?: string;
        before?: string;
        first?: number;
        identifier?: SecurityAdvisoryIdentifierFilter;
        last?: number;
        orderBy?: SecurityAdvisoryOrder;
        publishedSince?: unknown;
        updatedSince?: unknown;
      },
      select: (t: SecurityAdvisoryConnectionSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"securityAdvisories", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "securityAdvisories",
          "query",
          new SelectionSet([Query.securityAdvisories<T>(variables, select)])
        )
      ),

    /**
     * @description Fetch a Security Advisory by its GHSA ID
     */

    securityAdvisory: <T extends Array<Selection>>(
      variables: { ghsaId?: string },
      select: (t: SecurityAdvisorySelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"securityAdvisory", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "securityAdvisory",
          "query",
          new SelectionSet([Query.securityAdvisory<T>(variables, select)])
        )
      ),

    /**
     * @description Software Vulnerabilities documented by GitHub Security Advisories
     */

    securityVulnerabilities: <T extends Array<Selection>>(
      variables: {
        after?: string;
        before?: string;
        ecosystem?: SecurityAdvisoryEcosystem;
        first?: number;
        last?: number;
        orderBy?: SecurityVulnerabilityOrder;
        package?: string;
        severities?: SecurityAdvisorySeverity;
      },
      select: (t: SecurityVulnerabilityConnectionSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"securityVulnerabilities", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "securityVulnerabilities",
          "query",
          new SelectionSet([
            Query.securityVulnerabilities<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Look up a single Sponsors Listing
     * @deprecated `Query.sponsorsListing` will be removed. Use `Sponsorable.sponsorsListing` instead. Removal on 2020-04-01 UTC.
     */

    sponsorsListing: <T extends Array<Selection>>(
      variables: { slug?: string },
      select: (t: SponsorsListingSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<
          SelectionSet<[Field<"sponsorsListing", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "sponsorsListing",
          "query",
          new SelectionSet([Query.sponsorsListing<T>(variables, select)])
        )
      ),

    /**
     * @description Look up a topic by name.
     */

    topic: <T extends Array<Selection>>(
      variables: { name?: string },
      select: (t: TopicSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"topic", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "topic",
          "query",
          new SelectionSet([Query.topic<T>(variables, select)])
        )
      ),

    /**
     * @description Lookup a user by login.
     */

    user: <T extends Array<Selection>>(
      variables: { login?: string },
      select: (t: UserSelector) => T
    ) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"user", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "user",
          "query",
          new SelectionSet([Query.user<T>(variables, select)])
        )
      ),

    /**
     * @description The currently authenticated user.
     */

    viewer: <T extends Array<Selection>>(select: (t: UserSelector) => T) =>
      this.executor.execute<
        IQuery,
        Operation<SelectionSet<[Field<"viewer", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "viewer",
          "query",
          new SelectionSet([Query.viewer<T>(select)])
        )
      ),
  };

  public readonly mutate = {
    /**
     * @description Accepts a pending invitation for a user to become an administrator of an enterprise.
     */

    acceptEnterpriseAdministratorInvitation: <T extends Array<Selection>>(
      variables: { input?: AcceptEnterpriseAdministratorInvitationInput },
      select: (t: AcceptEnterpriseAdministratorInvitationPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "acceptEnterpriseAdministratorInvitation",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "acceptEnterpriseAdministratorInvitation",
          "mutation",
          new SelectionSet([
            Mutation.acceptEnterpriseAdministratorInvitation<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Applies a suggested topic to the repository.
     */

    acceptTopicSuggestion: <T extends Array<Selection>>(
      variables: { input?: AcceptTopicSuggestionInput },
      select: (t: AcceptTopicSuggestionPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"acceptTopicSuggestion", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "acceptTopicSuggestion",
          "mutation",
          new SelectionSet([
            Mutation.acceptTopicSuggestion<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Adds assignees to an assignable object.
     */

    addAssigneesToAssignable: <T extends Array<Selection>>(
      variables: { input?: AddAssigneesToAssignableInput },
      select: (t: AddAssigneesToAssignablePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"addAssigneesToAssignable", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "addAssigneesToAssignable",
          "mutation",
          new SelectionSet([
            Mutation.addAssigneesToAssignable<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Adds a comment to an Issue or Pull Request.
     */

    addComment: <T extends Array<Selection>>(
      variables: { input?: AddCommentInput },
      select: (t: AddCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"addComment", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "addComment",
          "mutation",
          new SelectionSet([Mutation.addComment<T>(variables, select)])
        )
      ),

    /**
     * @description Adds labels to a labelable object.
     */

    addLabelsToLabelable: <T extends Array<Selection>>(
      variables: { input?: AddLabelsToLabelableInput },
      select: (t: AddLabelsToLabelablePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"addLabelsToLabelable", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "addLabelsToLabelable",
          "mutation",
          new SelectionSet([
            Mutation.addLabelsToLabelable<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both.
     */

    addProjectCard: <T extends Array<Selection>>(
      variables: { input?: AddProjectCardInput },
      select: (t: AddProjectCardPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"addProjectCard", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "addProjectCard",
          "mutation",
          new SelectionSet([Mutation.addProjectCard<T>(variables, select)])
        )
      ),

    /**
     * @description Adds a column to a Project.
     */

    addProjectColumn: <T extends Array<Selection>>(
      variables: { input?: AddProjectColumnInput },
      select: (t: AddProjectColumnPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"addProjectColumn", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "addProjectColumn",
          "mutation",
          new SelectionSet([Mutation.addProjectColumn<T>(variables, select)])
        )
      ),

    /**
     * @description Adds a review to a Pull Request.
     */

    addPullRequestReview: <T extends Array<Selection>>(
      variables: { input?: AddPullRequestReviewInput },
      select: (t: AddPullRequestReviewPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"addPullRequestReview", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "addPullRequestReview",
          "mutation",
          new SelectionSet([
            Mutation.addPullRequestReview<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Adds a comment to a review.
     */

    addPullRequestReviewComment: <T extends Array<Selection>>(
      variables: { input?: AddPullRequestReviewCommentInput },
      select: (t: AddPullRequestReviewCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"addPullRequestReviewComment", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "addPullRequestReviewComment",
          "mutation",
          new SelectionSet([
            Mutation.addPullRequestReviewComment<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Adds a new thread to a pending Pull Request Review.
     */

    addPullRequestReviewThread: <T extends Array<Selection>>(
      variables: { input?: AddPullRequestReviewThreadInput },
      select: (t: AddPullRequestReviewThreadPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"addPullRequestReviewThread", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "addPullRequestReviewThread",
          "mutation",
          new SelectionSet([
            Mutation.addPullRequestReviewThread<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Adds a reaction to a subject.
     */

    addReaction: <T extends Array<Selection>>(
      variables: { input?: AddReactionInput },
      select: (t: AddReactionPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"addReaction", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "addReaction",
          "mutation",
          new SelectionSet([Mutation.addReaction<T>(variables, select)])
        )
      ),

    /**
     * @description Adds a star to a Starrable.
     */

    addStar: <T extends Array<Selection>>(
      variables: { input?: AddStarInput },
      select: (t: AddStarPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"addStar", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "addStar",
          "mutation",
          new SelectionSet([Mutation.addStar<T>(variables, select)])
        )
      ),

    /**
     * @description Marks a repository as archived.
     */

    archiveRepository: <T extends Array<Selection>>(
      variables: { input?: ArchiveRepositoryInput },
      select: (t: ArchiveRepositoryPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"archiveRepository", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "archiveRepository",
          "mutation",
          new SelectionSet([Mutation.archiveRepository<T>(variables, select)])
        )
      ),

    /**
     * @description Cancels a pending invitation for an administrator to join an enterprise.
     */

    cancelEnterpriseAdminInvitation: <T extends Array<Selection>>(
      variables: { input?: CancelEnterpriseAdminInvitationInput },
      select: (t: CancelEnterpriseAdminInvitationPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"cancelEnterpriseAdminInvitation", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "cancelEnterpriseAdminInvitation",
          "mutation",
          new SelectionSet([
            Mutation.cancelEnterpriseAdminInvitation<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Update your status on GitHub.
     */

    changeUserStatus: <T extends Array<Selection>>(
      variables: { input?: ChangeUserStatusInput },
      select: (t: ChangeUserStatusPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"changeUserStatus", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "changeUserStatus",
          "mutation",
          new SelectionSet([Mutation.changeUserStatus<T>(variables, select)])
        )
      ),

    /**
     * @description Clears all labels from a labelable object.
     */

    clearLabelsFromLabelable: <T extends Array<Selection>>(
      variables: { input?: ClearLabelsFromLabelableInput },
      select: (t: ClearLabelsFromLabelablePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"clearLabelsFromLabelable", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "clearLabelsFromLabelable",
          "mutation",
          new SelectionSet([
            Mutation.clearLabelsFromLabelable<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Creates a new project by cloning configuration from an existing project.
     */

    cloneProject: <T extends Array<Selection>>(
      variables: { input?: CloneProjectInput },
      select: (t: CloneProjectPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"cloneProject", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "cloneProject",
          "mutation",
          new SelectionSet([Mutation.cloneProject<T>(variables, select)])
        )
      ),

    /**
     * @description Create a new repository with the same files and directory structure as a template repository.
     */

    cloneTemplateRepository: <T extends Array<Selection>>(
      variables: { input?: CloneTemplateRepositoryInput },
      select: (t: CloneTemplateRepositoryPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"cloneTemplateRepository", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "cloneTemplateRepository",
          "mutation",
          new SelectionSet([
            Mutation.cloneTemplateRepository<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Close an issue.
     */

    closeIssue: <T extends Array<Selection>>(
      variables: { input?: CloseIssueInput },
      select: (t: CloseIssuePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"closeIssue", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "closeIssue",
          "mutation",
          new SelectionSet([Mutation.closeIssue<T>(variables, select)])
        )
      ),

    /**
     * @description Close a pull request.
     */

    closePullRequest: <T extends Array<Selection>>(
      variables: { input?: ClosePullRequestInput },
      select: (t: ClosePullRequestPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"closePullRequest", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "closePullRequest",
          "mutation",
          new SelectionSet([Mutation.closePullRequest<T>(variables, select)])
        )
      ),

    /**
     * @description Convert a project note card to one associated with a newly created issue.
     */

    convertProjectCardNoteToIssue: <T extends Array<Selection>>(
      variables: { input?: ConvertProjectCardNoteToIssueInput },
      select: (t: ConvertProjectCardNoteToIssuePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"convertProjectCardNoteToIssue", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "convertProjectCardNoteToIssue",
          "mutation",
          new SelectionSet([
            Mutation.convertProjectCardNoteToIssue<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Create a new branch protection rule
     */

    createBranchProtectionRule: <T extends Array<Selection>>(
      variables: { input?: CreateBranchProtectionRuleInput },
      select: (t: CreateBranchProtectionRulePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"createBranchProtectionRule", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "createBranchProtectionRule",
          "mutation",
          new SelectionSet([
            Mutation.createBranchProtectionRule<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Create a check run.
     */

    createCheckRun: <T extends Array<Selection>>(
      variables: { input?: CreateCheckRunInput },
      select: (t: CreateCheckRunPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"createCheckRun", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "createCheckRun",
          "mutation",
          new SelectionSet([Mutation.createCheckRun<T>(variables, select)])
        )
      ),

    /**
     * @description Create a check suite
     */

    createCheckSuite: <T extends Array<Selection>>(
      variables: { input?: CreateCheckSuiteInput },
      select: (t: CreateCheckSuitePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"createCheckSuite", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "createCheckSuite",
          "mutation",
          new SelectionSet([Mutation.createCheckSuite<T>(variables, select)])
        )
      ),

    /**
     * @description Creates an organization as part of an enterprise account.
     */

    createEnterpriseOrganization: <T extends Array<Selection>>(
      variables: { input?: CreateEnterpriseOrganizationInput },
      select: (t: CreateEnterpriseOrganizationPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"createEnterpriseOrganization", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "createEnterpriseOrganization",
          "mutation",
          new SelectionSet([
            Mutation.createEnterpriseOrganization<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Creates a new IP allow list entry.
     */

    createIpAllowListEntry: <T extends Array<Selection>>(
      variables: { input?: CreateIpAllowListEntryInput },
      select: (t: CreateIpAllowListEntryPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"createIpAllowListEntry", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "createIpAllowListEntry",
          "mutation",
          new SelectionSet([
            Mutation.createIpAllowListEntry<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Creates a new issue.
     */

    createIssue: <T extends Array<Selection>>(
      variables: { input?: CreateIssueInput },
      select: (t: CreateIssuePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"createIssue", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "createIssue",
          "mutation",
          new SelectionSet([Mutation.createIssue<T>(variables, select)])
        )
      ),

    /**
     * @description Creates a new project.
     */

    createProject: <T extends Array<Selection>>(
      variables: { input?: CreateProjectInput },
      select: (t: CreateProjectPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"createProject", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "createProject",
          "mutation",
          new SelectionSet([Mutation.createProject<T>(variables, select)])
        )
      ),

    /**
     * @description Create a new pull request
     */

    createPullRequest: <T extends Array<Selection>>(
      variables: { input?: CreatePullRequestInput },
      select: (t: CreatePullRequestPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"createPullRequest", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "createPullRequest",
          "mutation",
          new SelectionSet([Mutation.createPullRequest<T>(variables, select)])
        )
      ),

    /**
     * @description Create a new Git Ref.
     */

    createRef: <T extends Array<Selection>>(
      variables: { input?: CreateRefInput },
      select: (t: CreateRefPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"createRef", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "createRef",
          "mutation",
          new SelectionSet([Mutation.createRef<T>(variables, select)])
        )
      ),

    /**
     * @description Create a new repository.
     */

    createRepository: <T extends Array<Selection>>(
      variables: { input?: CreateRepositoryInput },
      select: (t: CreateRepositoryPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"createRepository", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "createRepository",
          "mutation",
          new SelectionSet([Mutation.createRepository<T>(variables, select)])
        )
      ),

    /**
     * @description Creates a new team discussion.
     */

    createTeamDiscussion: <T extends Array<Selection>>(
      variables: { input?: CreateTeamDiscussionInput },
      select: (t: CreateTeamDiscussionPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"createTeamDiscussion", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "createTeamDiscussion",
          "mutation",
          new SelectionSet([
            Mutation.createTeamDiscussion<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Creates a new team discussion comment.
     */

    createTeamDiscussionComment: <T extends Array<Selection>>(
      variables: { input?: CreateTeamDiscussionCommentInput },
      select: (t: CreateTeamDiscussionCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"createTeamDiscussionComment", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "createTeamDiscussionComment",
          "mutation",
          new SelectionSet([
            Mutation.createTeamDiscussionComment<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Rejects a suggested topic for the repository.
     */

    declineTopicSuggestion: <T extends Array<Selection>>(
      variables: { input?: DeclineTopicSuggestionInput },
      select: (t: DeclineTopicSuggestionPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"declineTopicSuggestion", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "declineTopicSuggestion",
          "mutation",
          new SelectionSet([
            Mutation.declineTopicSuggestion<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Delete a branch protection rule
     */

    deleteBranchProtectionRule: <T extends Array<Selection>>(
      variables: { input?: DeleteBranchProtectionRuleInput },
      select: (t: DeleteBranchProtectionRulePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"deleteBranchProtectionRule", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "deleteBranchProtectionRule",
          "mutation",
          new SelectionSet([
            Mutation.deleteBranchProtectionRule<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Deletes a deployment.
     */

    deleteDeployment: <T extends Array<Selection>>(
      variables: { input?: DeleteDeploymentInput },
      select: (t: DeleteDeploymentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"deleteDeployment", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "deleteDeployment",
          "mutation",
          new SelectionSet([Mutation.deleteDeployment<T>(variables, select)])
        )
      ),

    /**
     * @description Deletes an IP allow list entry.
     */

    deleteIpAllowListEntry: <T extends Array<Selection>>(
      variables: { input?: DeleteIpAllowListEntryInput },
      select: (t: DeleteIpAllowListEntryPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"deleteIpAllowListEntry", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "deleteIpAllowListEntry",
          "mutation",
          new SelectionSet([
            Mutation.deleteIpAllowListEntry<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Deletes an Issue object.
     */

    deleteIssue: <T extends Array<Selection>>(
      variables: { input?: DeleteIssueInput },
      select: (t: DeleteIssuePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"deleteIssue", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "deleteIssue",
          "mutation",
          new SelectionSet([Mutation.deleteIssue<T>(variables, select)])
        )
      ),

    /**
     * @description Deletes an IssueComment object.
     */

    deleteIssueComment: <T extends Array<Selection>>(
      variables: { input?: DeleteIssueCommentInput },
      select: (t: DeleteIssueCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"deleteIssueComment", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "deleteIssueComment",
          "mutation",
          new SelectionSet([Mutation.deleteIssueComment<T>(variables, select)])
        )
      ),

    /**
     * @description Deletes a project.
     */

    deleteProject: <T extends Array<Selection>>(
      variables: { input?: DeleteProjectInput },
      select: (t: DeleteProjectPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"deleteProject", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "deleteProject",
          "mutation",
          new SelectionSet([Mutation.deleteProject<T>(variables, select)])
        )
      ),

    /**
     * @description Deletes a project card.
     */

    deleteProjectCard: <T extends Array<Selection>>(
      variables: { input?: DeleteProjectCardInput },
      select: (t: DeleteProjectCardPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"deleteProjectCard", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "deleteProjectCard",
          "mutation",
          new SelectionSet([Mutation.deleteProjectCard<T>(variables, select)])
        )
      ),

    /**
     * @description Deletes a project column.
     */

    deleteProjectColumn: <T extends Array<Selection>>(
      variables: { input?: DeleteProjectColumnInput },
      select: (t: DeleteProjectColumnPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"deleteProjectColumn", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "deleteProjectColumn",
          "mutation",
          new SelectionSet([Mutation.deleteProjectColumn<T>(variables, select)])
        )
      ),

    /**
     * @description Deletes a pull request review.
     */

    deletePullRequestReview: <T extends Array<Selection>>(
      variables: { input?: DeletePullRequestReviewInput },
      select: (t: DeletePullRequestReviewPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"deletePullRequestReview", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "deletePullRequestReview",
          "mutation",
          new SelectionSet([
            Mutation.deletePullRequestReview<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Deletes a pull request review comment.
     */

    deletePullRequestReviewComment: <T extends Array<Selection>>(
      variables: { input?: DeletePullRequestReviewCommentInput },
      select: (t: DeletePullRequestReviewCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"deletePullRequestReviewComment", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "deletePullRequestReviewComment",
          "mutation",
          new SelectionSet([
            Mutation.deletePullRequestReviewComment<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Delete a Git Ref.
     */

    deleteRef: <T extends Array<Selection>>(
      variables: { input?: DeleteRefInput },
      select: (t: DeleteRefPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"deleteRef", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "deleteRef",
          "mutation",
          new SelectionSet([Mutation.deleteRef<T>(variables, select)])
        )
      ),

    /**
     * @description Deletes a team discussion.
     */

    deleteTeamDiscussion: <T extends Array<Selection>>(
      variables: { input?: DeleteTeamDiscussionInput },
      select: (t: DeleteTeamDiscussionPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"deleteTeamDiscussion", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "deleteTeamDiscussion",
          "mutation",
          new SelectionSet([
            Mutation.deleteTeamDiscussion<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Deletes a team discussion comment.
     */

    deleteTeamDiscussionComment: <T extends Array<Selection>>(
      variables: { input?: DeleteTeamDiscussionCommentInput },
      select: (t: DeleteTeamDiscussionCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"deleteTeamDiscussionComment", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "deleteTeamDiscussionComment",
          "mutation",
          new SelectionSet([
            Mutation.deleteTeamDiscussionComment<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Dismisses an approved or rejected pull request review.
     */

    dismissPullRequestReview: <T extends Array<Selection>>(
      variables: { input?: DismissPullRequestReviewInput },
      select: (t: DismissPullRequestReviewPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"dismissPullRequestReview", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "dismissPullRequestReview",
          "mutation",
          new SelectionSet([
            Mutation.dismissPullRequestReview<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Follow a user.
     */

    followUser: <T extends Array<Selection>>(
      variables: { input?: FollowUserInput },
      select: (t: FollowUserPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"followUser", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "followUser",
          "mutation",
          new SelectionSet([Mutation.followUser<T>(variables, select)])
        )
      ),

    /**
     * @description Invite someone to become an administrator of the enterprise.
     */

    inviteEnterpriseAdmin: <T extends Array<Selection>>(
      variables: { input?: InviteEnterpriseAdminInput },
      select: (t: InviteEnterpriseAdminPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"inviteEnterpriseAdmin", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "inviteEnterpriseAdmin",
          "mutation",
          new SelectionSet([
            Mutation.inviteEnterpriseAdmin<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Creates a repository link for a project.
     */

    linkRepositoryToProject: <T extends Array<Selection>>(
      variables: { input?: LinkRepositoryToProjectInput },
      select: (t: LinkRepositoryToProjectPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"linkRepositoryToProject", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "linkRepositoryToProject",
          "mutation",
          new SelectionSet([
            Mutation.linkRepositoryToProject<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Lock a lockable object
     */

    lockLockable: <T extends Array<Selection>>(
      variables: { input?: LockLockableInput },
      select: (t: LockLockablePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"lockLockable", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "lockLockable",
          "mutation",
          new SelectionSet([Mutation.lockLockable<T>(variables, select)])
        )
      ),

    /**
     * @description Mark a pull request file as viewed
     */

    markFileAsViewed: <T extends Array<Selection>>(
      variables: { input?: MarkFileAsViewedInput },
      select: (t: MarkFileAsViewedPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"markFileAsViewed", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "markFileAsViewed",
          "mutation",
          new SelectionSet([Mutation.markFileAsViewed<T>(variables, select)])
        )
      ),

    /**
     * @description Marks a pull request ready for review.
     */

    markPullRequestReadyForReview: <T extends Array<Selection>>(
      variables: { input?: MarkPullRequestReadyForReviewInput },
      select: (t: MarkPullRequestReadyForReviewPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"markPullRequestReadyForReview", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "markPullRequestReadyForReview",
          "mutation",
          new SelectionSet([
            Mutation.markPullRequestReadyForReview<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Merge a head into a branch.
     */

    mergeBranch: <T extends Array<Selection>>(
      variables: { input?: MergeBranchInput },
      select: (t: MergeBranchPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"mergeBranch", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "mergeBranch",
          "mutation",
          new SelectionSet([Mutation.mergeBranch<T>(variables, select)])
        )
      ),

    /**
     * @description Merge a pull request.
     */

    mergePullRequest: <T extends Array<Selection>>(
      variables: { input?: MergePullRequestInput },
      select: (t: MergePullRequestPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"mergePullRequest", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "mergePullRequest",
          "mutation",
          new SelectionSet([Mutation.mergePullRequest<T>(variables, select)])
        )
      ),

    /**
     * @description Minimizes a comment on an Issue, Commit, Pull Request, or Gist
     */

    minimizeComment: <T extends Array<Selection>>(
      variables: { input?: MinimizeCommentInput },
      select: (t: MinimizeCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"minimizeComment", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "minimizeComment",
          "mutation",
          new SelectionSet([Mutation.minimizeComment<T>(variables, select)])
        )
      ),

    /**
     * @description Moves a project card to another place.
     */

    moveProjectCard: <T extends Array<Selection>>(
      variables: { input?: MoveProjectCardInput },
      select: (t: MoveProjectCardPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"moveProjectCard", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "moveProjectCard",
          "mutation",
          new SelectionSet([Mutation.moveProjectCard<T>(variables, select)])
        )
      ),

    /**
     * @description Moves a project column to another place.
     */

    moveProjectColumn: <T extends Array<Selection>>(
      variables: { input?: MoveProjectColumnInput },
      select: (t: MoveProjectColumnPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"moveProjectColumn", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "moveProjectColumn",
          "mutation",
          new SelectionSet([Mutation.moveProjectColumn<T>(variables, select)])
        )
      ),

    /**
     * @description Regenerates the identity provider recovery codes for an enterprise
     */

    regenerateEnterpriseIdentityProviderRecoveryCodes: <
      T extends Array<Selection>
    >(
      variables: {
        input?: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
      },
      select: (
        t: RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "regenerateEnterpriseIdentityProviderRecoveryCodes",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "regenerateEnterpriseIdentityProviderRecoveryCodes",
          "mutation",
          new SelectionSet([
            Mutation.regenerateEnterpriseIdentityProviderRecoveryCodes<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Removes assignees from an assignable object.
     */

    removeAssigneesFromAssignable: <T extends Array<Selection>>(
      variables: { input?: RemoveAssigneesFromAssignableInput },
      select: (t: RemoveAssigneesFromAssignablePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"removeAssigneesFromAssignable", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "removeAssigneesFromAssignable",
          "mutation",
          new SelectionSet([
            Mutation.removeAssigneesFromAssignable<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Removes an administrator from the enterprise.
     */

    removeEnterpriseAdmin: <T extends Array<Selection>>(
      variables: { input?: RemoveEnterpriseAdminInput },
      select: (t: RemoveEnterpriseAdminPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"removeEnterpriseAdmin", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "removeEnterpriseAdmin",
          "mutation",
          new SelectionSet([
            Mutation.removeEnterpriseAdmin<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Removes the identity provider from an enterprise
     */

    removeEnterpriseIdentityProvider: <T extends Array<Selection>>(
      variables: { input?: RemoveEnterpriseIdentityProviderInput },
      select: (t: RemoveEnterpriseIdentityProviderPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"removeEnterpriseIdentityProvider", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "removeEnterpriseIdentityProvider",
          "mutation",
          new SelectionSet([
            Mutation.removeEnterpriseIdentityProvider<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Removes an organization from the enterprise
     */

    removeEnterpriseOrganization: <T extends Array<Selection>>(
      variables: { input?: RemoveEnterpriseOrganizationInput },
      select: (t: RemoveEnterpriseOrganizationPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"removeEnterpriseOrganization", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "removeEnterpriseOrganization",
          "mutation",
          new SelectionSet([
            Mutation.removeEnterpriseOrganization<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Removes labels from a Labelable object.
     */

    removeLabelsFromLabelable: <T extends Array<Selection>>(
      variables: { input?: RemoveLabelsFromLabelableInput },
      select: (t: RemoveLabelsFromLabelablePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"removeLabelsFromLabelable", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "removeLabelsFromLabelable",
          "mutation",
          new SelectionSet([
            Mutation.removeLabelsFromLabelable<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Removes outside collaborator from all repositories in an organization.
     */

    removeOutsideCollaborator: <T extends Array<Selection>>(
      variables: { input?: RemoveOutsideCollaboratorInput },
      select: (t: RemoveOutsideCollaboratorPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"removeOutsideCollaborator", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "removeOutsideCollaborator",
          "mutation",
          new SelectionSet([
            Mutation.removeOutsideCollaborator<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Removes a reaction from a subject.
     */

    removeReaction: <T extends Array<Selection>>(
      variables: { input?: RemoveReactionInput },
      select: (t: RemoveReactionPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"removeReaction", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "removeReaction",
          "mutation",
          new SelectionSet([Mutation.removeReaction<T>(variables, select)])
        )
      ),

    /**
     * @description Removes a star from a Starrable.
     */

    removeStar: <T extends Array<Selection>>(
      variables: { input?: RemoveStarInput },
      select: (t: RemoveStarPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"removeStar", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "removeStar",
          "mutation",
          new SelectionSet([Mutation.removeStar<T>(variables, select)])
        )
      ),

    /**
     * @description Reopen a issue.
     */

    reopenIssue: <T extends Array<Selection>>(
      variables: { input?: ReopenIssueInput },
      select: (t: ReopenIssuePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"reopenIssue", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "reopenIssue",
          "mutation",
          new SelectionSet([Mutation.reopenIssue<T>(variables, select)])
        )
      ),

    /**
     * @description Reopen a pull request.
     */

    reopenPullRequest: <T extends Array<Selection>>(
      variables: { input?: ReopenPullRequestInput },
      select: (t: ReopenPullRequestPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"reopenPullRequest", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "reopenPullRequest",
          "mutation",
          new SelectionSet([Mutation.reopenPullRequest<T>(variables, select)])
        )
      ),

    /**
     * @description Set review requests on a pull request.
     */

    requestReviews: <T extends Array<Selection>>(
      variables: { input?: RequestReviewsInput },
      select: (t: RequestReviewsPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"requestReviews", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "requestReviews",
          "mutation",
          new SelectionSet([Mutation.requestReviews<T>(variables, select)])
        )
      ),

    /**
     * @description Rerequests an existing check suite.
     */

    rerequestCheckSuite: <T extends Array<Selection>>(
      variables: { input?: RerequestCheckSuiteInput },
      select: (t: RerequestCheckSuitePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"rerequestCheckSuite", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "rerequestCheckSuite",
          "mutation",
          new SelectionSet([Mutation.rerequestCheckSuite<T>(variables, select)])
        )
      ),

    /**
     * @description Marks a review thread as resolved.
     */

    resolveReviewThread: <T extends Array<Selection>>(
      variables: { input?: ResolveReviewThreadInput },
      select: (t: ResolveReviewThreadPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"resolveReviewThread", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "resolveReviewThread",
          "mutation",
          new SelectionSet([Mutation.resolveReviewThread<T>(variables, select)])
        )
      ),

    /**
     * @description Creates or updates the identity provider for an enterprise.
     */

    setEnterpriseIdentityProvider: <T extends Array<Selection>>(
      variables: { input?: SetEnterpriseIdentityProviderInput },
      select: (t: SetEnterpriseIdentityProviderPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"setEnterpriseIdentityProvider", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "setEnterpriseIdentityProvider",
          "mutation",
          new SelectionSet([
            Mutation.setEnterpriseIdentityProvider<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Set an organization level interaction limit for an organization's public repositories.
     */

    setOrganizationInteractionLimit: <T extends Array<Selection>>(
      variables: { input?: SetOrganizationInteractionLimitInput },
      select: (t: SetOrganizationInteractionLimitPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"setOrganizationInteractionLimit", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "setOrganizationInteractionLimit",
          "mutation",
          new SelectionSet([
            Mutation.setOrganizationInteractionLimit<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Sets an interaction limit setting for a repository.
     */

    setRepositoryInteractionLimit: <T extends Array<Selection>>(
      variables: { input?: SetRepositoryInteractionLimitInput },
      select: (t: SetRepositoryInteractionLimitPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"setRepositoryInteractionLimit", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "setRepositoryInteractionLimit",
          "mutation",
          new SelectionSet([
            Mutation.setRepositoryInteractionLimit<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Set a user level interaction limit for an user's public repositories.
     */

    setUserInteractionLimit: <T extends Array<Selection>>(
      variables: { input?: SetUserInteractionLimitInput },
      select: (t: SetUserInteractionLimitPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"setUserInteractionLimit", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "setUserInteractionLimit",
          "mutation",
          new SelectionSet([
            Mutation.setUserInteractionLimit<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Submits a pending pull request review.
     */

    submitPullRequestReview: <T extends Array<Selection>>(
      variables: { input?: SubmitPullRequestReviewInput },
      select: (t: SubmitPullRequestReviewPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"submitPullRequestReview", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "submitPullRequestReview",
          "mutation",
          new SelectionSet([
            Mutation.submitPullRequestReview<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Transfer an issue to a different repository
     */

    transferIssue: <T extends Array<Selection>>(
      variables: { input?: TransferIssueInput },
      select: (t: TransferIssuePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"transferIssue", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "transferIssue",
          "mutation",
          new SelectionSet([Mutation.transferIssue<T>(variables, select)])
        )
      ),

    /**
     * @description Unarchives a repository.
     */

    unarchiveRepository: <T extends Array<Selection>>(
      variables: { input?: UnarchiveRepositoryInput },
      select: (t: UnarchiveRepositoryPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"unarchiveRepository", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "unarchiveRepository",
          "mutation",
          new SelectionSet([Mutation.unarchiveRepository<T>(variables, select)])
        )
      ),

    /**
     * @description Unfollow a user.
     */

    unfollowUser: <T extends Array<Selection>>(
      variables: { input?: UnfollowUserInput },
      select: (t: UnfollowUserPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"unfollowUser", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "unfollowUser",
          "mutation",
          new SelectionSet([Mutation.unfollowUser<T>(variables, select)])
        )
      ),

    /**
     * @description Deletes a repository link from a project.
     */

    unlinkRepositoryFromProject: <T extends Array<Selection>>(
      variables: { input?: UnlinkRepositoryFromProjectInput },
      select: (t: UnlinkRepositoryFromProjectPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"unlinkRepositoryFromProject", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "unlinkRepositoryFromProject",
          "mutation",
          new SelectionSet([
            Mutation.unlinkRepositoryFromProject<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Unlock a lockable object
     */

    unlockLockable: <T extends Array<Selection>>(
      variables: { input?: UnlockLockableInput },
      select: (t: UnlockLockablePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"unlockLockable", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "unlockLockable",
          "mutation",
          new SelectionSet([Mutation.unlockLockable<T>(variables, select)])
        )
      ),

    /**
     * @description Unmark a pull request file as viewed
     */

    unmarkFileAsViewed: <T extends Array<Selection>>(
      variables: { input?: UnmarkFileAsViewedInput },
      select: (t: UnmarkFileAsViewedPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"unmarkFileAsViewed", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "unmarkFileAsViewed",
          "mutation",
          new SelectionSet([Mutation.unmarkFileAsViewed<T>(variables, select)])
        )
      ),

    /**
     * @description Unmark an issue as a duplicate of another issue.
     */

    unmarkIssueAsDuplicate: <T extends Array<Selection>>(
      variables: { input?: UnmarkIssueAsDuplicateInput },
      select: (t: UnmarkIssueAsDuplicatePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"unmarkIssueAsDuplicate", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "unmarkIssueAsDuplicate",
          "mutation",
          new SelectionSet([
            Mutation.unmarkIssueAsDuplicate<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Unminimizes a comment on an Issue, Commit, Pull Request, or Gist
     */

    unminimizeComment: <T extends Array<Selection>>(
      variables: { input?: UnminimizeCommentInput },
      select: (t: UnminimizeCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"unminimizeComment", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "unminimizeComment",
          "mutation",
          new SelectionSet([Mutation.unminimizeComment<T>(variables, select)])
        )
      ),

    /**
     * @description Marks a review thread as unresolved.
     */

    unresolveReviewThread: <T extends Array<Selection>>(
      variables: { input?: UnresolveReviewThreadInput },
      select: (t: UnresolveReviewThreadPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"unresolveReviewThread", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "unresolveReviewThread",
          "mutation",
          new SelectionSet([
            Mutation.unresolveReviewThread<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Create a new branch protection rule
     */

    updateBranchProtectionRule: <T extends Array<Selection>>(
      variables: { input?: UpdateBranchProtectionRuleInput },
      select: (t: UpdateBranchProtectionRulePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"updateBranchProtectionRule", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "updateBranchProtectionRule",
          "mutation",
          new SelectionSet([
            Mutation.updateBranchProtectionRule<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Update a check run
     */

    updateCheckRun: <T extends Array<Selection>>(
      variables: { input?: UpdateCheckRunInput },
      select: (t: UpdateCheckRunPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"updateCheckRun", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "updateCheckRun",
          "mutation",
          new SelectionSet([Mutation.updateCheckRun<T>(variables, select)])
        )
      ),

    /**
     * @description Modifies the settings of an existing check suite
     */

    updateCheckSuitePreferences: <T extends Array<Selection>>(
      variables: { input?: UpdateCheckSuitePreferencesInput },
      select: (t: UpdateCheckSuitePreferencesPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"updateCheckSuitePreferences", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "updateCheckSuitePreferences",
          "mutation",
          new SelectionSet([
            Mutation.updateCheckSuitePreferences<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Updates the role of an enterprise administrator.
     */

    updateEnterpriseAdministratorRole: <T extends Array<Selection>>(
      variables: { input?: UpdateEnterpriseAdministratorRoleInput },
      select: (t: UpdateEnterpriseAdministratorRolePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"updateEnterpriseAdministratorRole", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "updateEnterpriseAdministratorRole",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseAdministratorRole<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Sets whether private repository forks are enabled for an enterprise.
     */

    updateEnterpriseAllowPrivateRepositoryForkingSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
      },
      select: (
        t: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseAllowPrivateRepositoryForkingSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseAllowPrivateRepositoryForkingSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseAllowPrivateRepositoryForkingSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets the default repository permission for organizations in an enterprise.
     */

    updateEnterpriseDefaultRepositoryPermissionSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
      },
      select: (
        t: UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseDefaultRepositoryPermissionSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseDefaultRepositoryPermissionSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseDefaultRepositoryPermissionSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets whether organization members with admin permissions on a repository can change repository visibility.
     */

    updateEnterpriseMembersCanChangeRepositoryVisibilitySetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
      },
      select: (
        t: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseMembersCanChangeRepositoryVisibilitySetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseMembersCanChangeRepositoryVisibilitySetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseMembersCanChangeRepositoryVisibilitySetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets the members can create repositories setting for an enterprise.
     */

    updateEnterpriseMembersCanCreateRepositoriesSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
      },
      select: (
        t: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseMembersCanCreateRepositoriesSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseMembersCanCreateRepositoriesSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseMembersCanCreateRepositoriesSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets the members can delete issues setting for an enterprise.
     */

    updateEnterpriseMembersCanDeleteIssuesSetting: <T extends Array<Selection>>(
      variables: { input?: UpdateEnterpriseMembersCanDeleteIssuesSettingInput },
      select: (
        t: UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseMembersCanDeleteIssuesSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseMembersCanDeleteIssuesSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseMembersCanDeleteIssuesSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets the members can delete repositories setting for an enterprise.
     */

    updateEnterpriseMembersCanDeleteRepositoriesSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
      },
      select: (
        t: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseMembersCanDeleteRepositoriesSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseMembersCanDeleteRepositoriesSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseMembersCanDeleteRepositoriesSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets whether members can invite collaborators are enabled for an enterprise.
     */

    updateEnterpriseMembersCanInviteCollaboratorsSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
      },
      select: (
        t: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseMembersCanInviteCollaboratorsSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseMembersCanInviteCollaboratorsSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseMembersCanInviteCollaboratorsSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets whether or not an organization admin can make purchases.
     */

    updateEnterpriseMembersCanMakePurchasesSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseMembersCanMakePurchasesSettingInput;
      },
      select: (
        t: UpdateEnterpriseMembersCanMakePurchasesSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseMembersCanMakePurchasesSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseMembersCanMakePurchasesSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseMembersCanMakePurchasesSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets the members can update protected branches setting for an enterprise.
     */

    updateEnterpriseMembersCanUpdateProtectedBranchesSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
      },
      select: (
        t: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseMembersCanUpdateProtectedBranchesSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseMembersCanUpdateProtectedBranchesSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseMembersCanUpdateProtectedBranchesSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets the members can view dependency insights for an enterprise.
     */

    updateEnterpriseMembersCanViewDependencyInsightsSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
      },
      select: (
        t: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseMembersCanViewDependencyInsightsSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseMembersCanViewDependencyInsightsSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseMembersCanViewDependencyInsightsSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets whether organization projects are enabled for an enterprise.
     */

    updateEnterpriseOrganizationProjectsSetting: <T extends Array<Selection>>(
      variables: { input?: UpdateEnterpriseOrganizationProjectsSettingInput },
      select: (
        t: UpdateEnterpriseOrganizationProjectsSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseOrganizationProjectsSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseOrganizationProjectsSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseOrganizationProjectsSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Updates an enterprise's profile.
     */

    updateEnterpriseProfile: <T extends Array<Selection>>(
      variables: { input?: UpdateEnterpriseProfileInput },
      select: (t: UpdateEnterpriseProfilePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updateEnterpriseProfile", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updateEnterpriseProfile",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseProfile<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Sets whether repository projects are enabled for a enterprise.
     */

    updateEnterpriseRepositoryProjectsSetting: <T extends Array<Selection>>(
      variables: { input?: UpdateEnterpriseRepositoryProjectsSettingInput },
      select: (t: UpdateEnterpriseRepositoryProjectsSettingPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseRepositoryProjectsSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseRepositoryProjectsSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseRepositoryProjectsSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets whether team discussions are enabled for an enterprise.
     */

    updateEnterpriseTeamDiscussionsSetting: <T extends Array<Selection>>(
      variables: { input?: UpdateEnterpriseTeamDiscussionsSettingInput },
      select: (t: UpdateEnterpriseTeamDiscussionsSettingPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseTeamDiscussionsSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseTeamDiscussionsSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseTeamDiscussionsSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets whether two factor authentication is required for all users in an enterprise.
     */

    updateEnterpriseTwoFactorAuthenticationRequiredSetting: <
      T extends Array<Selection>
    >(
      variables: {
        input?: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
      },
      select: (
        t: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadSelector
      ) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [
              Field<
                "updateEnterpriseTwoFactorAuthenticationRequiredSetting",
                any,
                SelectionSet<T>
              >
            ]
          >
        >
      >(
        new Operation(
          "updateEnterpriseTwoFactorAuthenticationRequiredSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateEnterpriseTwoFactorAuthenticationRequiredSetting<T>(
              variables,
              select
            ),
          ])
        )
      ),

    /**
     * @description Sets whether an IP allow list is enabled on an owner.
     */

    updateIpAllowListEnabledSetting: <T extends Array<Selection>>(
      variables: { input?: UpdateIpAllowListEnabledSettingInput },
      select: (t: UpdateIpAllowListEnabledSettingPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"updateIpAllowListEnabledSetting", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "updateIpAllowListEnabledSetting",
          "mutation",
          new SelectionSet([
            Mutation.updateIpAllowListEnabledSetting<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Updates an IP allow list entry.
     */

    updateIpAllowListEntry: <T extends Array<Selection>>(
      variables: { input?: UpdateIpAllowListEntryInput },
      select: (t: UpdateIpAllowListEntryPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updateIpAllowListEntry", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updateIpAllowListEntry",
          "mutation",
          new SelectionSet([
            Mutation.updateIpAllowListEntry<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Updates an Issue.
     */

    updateIssue: <T extends Array<Selection>>(
      variables: { input?: UpdateIssueInput },
      select: (t: UpdateIssuePayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"updateIssue", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "updateIssue",
          "mutation",
          new SelectionSet([Mutation.updateIssue<T>(variables, select)])
        )
      ),

    /**
     * @description Updates an IssueComment object.
     */

    updateIssueComment: <T extends Array<Selection>>(
      variables: { input?: UpdateIssueCommentInput },
      select: (t: UpdateIssueCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updateIssueComment", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updateIssueComment",
          "mutation",
          new SelectionSet([Mutation.updateIssueComment<T>(variables, select)])
        )
      ),

    /**
     * @description Updates an existing project.
     */

    updateProject: <T extends Array<Selection>>(
      variables: { input?: UpdateProjectInput },
      select: (t: UpdateProjectPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"updateProject", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "updateProject",
          "mutation",
          new SelectionSet([Mutation.updateProject<T>(variables, select)])
        )
      ),

    /**
     * @description Updates an existing project card.
     */

    updateProjectCard: <T extends Array<Selection>>(
      variables: { input?: UpdateProjectCardInput },
      select: (t: UpdateProjectCardPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updateProjectCard", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updateProjectCard",
          "mutation",
          new SelectionSet([Mutation.updateProjectCard<T>(variables, select)])
        )
      ),

    /**
     * @description Updates an existing project column.
     */

    updateProjectColumn: <T extends Array<Selection>>(
      variables: { input?: UpdateProjectColumnInput },
      select: (t: UpdateProjectColumnPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updateProjectColumn", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updateProjectColumn",
          "mutation",
          new SelectionSet([Mutation.updateProjectColumn<T>(variables, select)])
        )
      ),

    /**
     * @description Update a pull request
     */

    updatePullRequest: <T extends Array<Selection>>(
      variables: { input?: UpdatePullRequestInput },
      select: (t: UpdatePullRequestPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updatePullRequest", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updatePullRequest",
          "mutation",
          new SelectionSet([Mutation.updatePullRequest<T>(variables, select)])
        )
      ),

    /**
     * @description Updates the body of a pull request review.
     */

    updatePullRequestReview: <T extends Array<Selection>>(
      variables: { input?: UpdatePullRequestReviewInput },
      select: (t: UpdatePullRequestReviewPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updatePullRequestReview", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updatePullRequestReview",
          "mutation",
          new SelectionSet([
            Mutation.updatePullRequestReview<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Updates a pull request review comment.
     */

    updatePullRequestReviewComment: <T extends Array<Selection>>(
      variables: { input?: UpdatePullRequestReviewCommentInput },
      select: (t: UpdatePullRequestReviewCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"updatePullRequestReviewComment", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "updatePullRequestReviewComment",
          "mutation",
          new SelectionSet([
            Mutation.updatePullRequestReviewComment<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Update a Git Ref.
     */

    updateRef: <T extends Array<Selection>>(
      variables: { input?: UpdateRefInput },
      select: (t: UpdateRefPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"updateRef", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "updateRef",
          "mutation",
          new SelectionSet([Mutation.updateRef<T>(variables, select)])
        )
      ),

    /**
     * @description Update information about a repository.
     */

    updateRepository: <T extends Array<Selection>>(
      variables: { input?: UpdateRepositoryInput },
      select: (t: UpdateRepositoryPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updateRepository", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updateRepository",
          "mutation",
          new SelectionSet([Mutation.updateRepository<T>(variables, select)])
        )
      ),

    /**
     * @description Updates the state for subscribable subjects.
     */

    updateSubscription: <T extends Array<Selection>>(
      variables: { input?: UpdateSubscriptionInput },
      select: (t: UpdateSubscriptionPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updateSubscription", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updateSubscription",
          "mutation",
          new SelectionSet([Mutation.updateSubscription<T>(variables, select)])
        )
      ),

    /**
     * @description Updates a team discussion.
     */

    updateTeamDiscussion: <T extends Array<Selection>>(
      variables: { input?: UpdateTeamDiscussionInput },
      select: (t: UpdateTeamDiscussionPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<[Field<"updateTeamDiscussion", any, SelectionSet<T>>]>
        >
      >(
        new Operation(
          "updateTeamDiscussion",
          "mutation",
          new SelectionSet([
            Mutation.updateTeamDiscussion<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Updates a discussion comment.
     */

    updateTeamDiscussionComment: <T extends Array<Selection>>(
      variables: { input?: UpdateTeamDiscussionCommentInput },
      select: (t: UpdateTeamDiscussionCommentPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<
          SelectionSet<
            [Field<"updateTeamDiscussionComment", any, SelectionSet<T>>]
          >
        >
      >(
        new Operation(
          "updateTeamDiscussionComment",
          "mutation",
          new SelectionSet([
            Mutation.updateTeamDiscussionComment<T>(variables, select),
          ])
        )
      ),

    /**
     * @description Replaces the repository's topics with the given topics.
     */

    updateTopics: <T extends Array<Selection>>(
      variables: { input?: UpdateTopicsInput },
      select: (t: UpdateTopicsPayloadSelector) => T
    ) =>
      this.executor.execute<
        IMutation,
        Operation<SelectionSet<[Field<"updateTopics", any, SelectionSet<T>>]>>
      >(
        new Operation(
          "updateTopics",
          "mutation",
          new SelectionSet([Mutation.updateTopics<T>(variables, select)])
        )
      ),
  };
}
